{"/lhfdoc.github.io/embedded_dev/index.html":{"title":"åµŒå…¥å¼å¼€å‘","content":" title: åµŒå…¥å¼å¼€å‘ keywords: åµŒå…¥å¼, å¼€å‘, å•ç‰‡æœº, RTOS, ç¡¬ä»¶ desc: åµŒå…¥å¼ç³»ç»Ÿå¼€å‘ç›¸å…³æŠ€æœ¯æ–‡æ¡£å’Œé¡¹ç›®åˆ†æ # ğŸ”§ åµŒå…¥å¼å¼€å‘ è®°å½•åµŒå…¥å¼ç³»ç»Ÿå¼€å‘ä¸­çš„æŠ€æœ¯ç ”ç©¶ã€é¡¹ç›®åˆ†æå’Œå®è·µç»éªŒã€‚ ## ğŸ“š å†…å®¹åˆ†ç±» ### ğŸš€ å¼€æºé¡¹ç›®åˆ†æ æ·±å…¥åˆ†æä¼˜ç§€çš„å¼€æºåµŒå…¥å¼é¡¹ç›®ï¼Œå­¦ä¹ å…ˆè¿›çš„æ¶æ„è®¾è®¡å’Œç¼–ç¨‹æŠ€å·§ã€‚ #### Nordic nRF5340 ç³»åˆ— **[OpenEarable 2.0](./opensource_projects/nordic_nrf5340/)** å¼€æºæ™ºèƒ½è€³æˆ´è®¾å¤‡å®Œæ•´åˆ†æ éŸ³é¢‘å¤„ç†å’Œä¼ æ„Ÿå™¨èåˆæŠ€æœ¯ Bluetooth LE Audio åè®®æ ˆå®ç° ### ğŸ’» ç¡¬ä»¶å¹³å° **Nordic nRFç³»åˆ—** ä½åŠŸè€—è“ç‰™å’ŒThreadç½‘ç»œ **ESP32ç³»åˆ—** WiFiå’Œè“ç‰™åŒæ¨¡èŠ¯ç‰‡ **STM32ç³»åˆ—** ARM Cortex Må¾®æ§åˆ¶å™¨ ### âš™ï¸ å®æ—¶æ“ä½œç³»ç»Ÿ **Zephyr RTOS** å¯æ‰©å±•çš„å®æ—¶æ“ä½œç³»ç»Ÿ **FreeRTOS** å¸‚åœºé¢†å…ˆçš„RTOSå†…æ ¸ **RT Thread** å›½äº§ç‰©è”ç½‘æ“ä½œç³»ç»Ÿ ### ğŸ”— é€šä¿¡åè®® **è“ç‰™åè®®** ç»å…¸è“ç‰™å’Œä½åŠŸè€—è“ç‰™ **WiFiåè®®** 802.11ç³»åˆ—æ— çº¿é€šä¿¡ **LoRa/LoRaWAN** é•¿è·ç¦»ä½åŠŸè€—é€šä¿¡ ### ğŸ› ï¸ å¼€å‘å·¥å…· **IDEç¯å¢ƒ** VS Code, Keil, IARç­‰ **è°ƒè¯•å·¥å…·** J Link, ST Linkç­‰ **ä»¿çœŸå¹³å°** QEMU, Renodeç­‰ <div style \"background: linear gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border radius: 10px; margin top: 30px;\"> <h3 style \"color: white; margin top: 0;\">ğŸ’¡ å­¦ä¹ è·¯å¾„å»ºè®®</h3> <p>1. <strong>åŸºç¡€ç†è®º</strong> æŒæ¡åµŒå…¥å¼ç³»ç»ŸåŸºæœ¬æ¦‚å¿µå’Œç¡¬ä»¶åŸç†</p> <p>2. <strong>å¼€å‘ç¯å¢ƒ</strong> ç†Ÿæ‚‰ä¸»æµå¼€å‘å·¥å…·å’Œè°ƒè¯•æ–¹æ³•</p> <p>3. <strong>å®æ—¶ç³»ç»Ÿ</strong> å­¦ä¹ RTOSçš„ä½¿ç”¨å’Œä»»åŠ¡è°ƒåº¦æœºåˆ¶</p> <p>4. <strong>é¡¹ç›®å®è·µ</strong> é€šè¿‡å®é™…é¡¹ç›®åŠ æ·±ç†è§£å’Œåº”ç”¨</p> <p>5. <strong>ä¼˜åŒ–è¿›é˜¶</strong> å­¦ä¹ æ€§èƒ½ä¼˜åŒ–å’Œä½åŠŸè€—è®¾è®¡æŠ€å·§</p> </div>"},"/lhfdoc.github.io/embedded_dev/openearable/utils-module.html":{"title":"OpenEarable 2.0 - ç³»ç»Ÿå·¥å…·æ¨¡å— (Utils Module)","content":"# OpenEarable 2.0 ç³»ç»Ÿå·¥å…·æ¨¡å— (Utils Module) ## æ¦‚è¿° ç³»ç»Ÿå·¥å…·æ¨¡å—æä¾›äº†OpenEarableè®¾å¤‡çš„å„ç§è¾…åŠ©åŠŸèƒ½å’Œç³»ç»Ÿçº§å·¥å…·ï¼ŒåŒ…æ‹¬çŠ¶æ€æŒ‡ç¤ºã€æ¿çº§æ”¯æŒã€ç‰ˆæœ¬ç®¡ç†ã€é”™è¯¯å¤„ç†ç­‰æ ¸å¿ƒç³»ç»ŸåŠŸèƒ½ã€‚è¯¥æ¨¡å—ä¸ºæ•´ä¸ªç³»ç»Ÿæä¾›äº†åŸºç¡€çš„æ”¯æ’‘æœåŠ¡ã€‚ ## æ ¸å¿ƒç»„ä»¶ ### 1. çŠ¶æ€æŒ‡ç¤ºå™¨ (`StateIndicator.h/cpp`) è´Ÿè´£é€šè¿‡LEDæ˜¾ç¤ºè®¾å¤‡çš„å„ç§çŠ¶æ€ï¼š #### æ ¸å¿ƒç±»å®šä¹‰ ```cpp class StateIndicator { public: void init(struct earable_state state); void set_state(struct earable_state state); void set_charging_state(enum charging_state state); void set_pairing_state(enum pairing_state state); void set_indication_mode(enum led_mode state); void set_custom_color(const RGBColor &color); private: earable_state _state; RGBColor color; }; extern StateIndicator state_indicator; ``` #### é¢„å®šä¹‰é¢œè‰² ```cpp static const RGBColor LED_OFF {0, 0, 0}; static const RGBColor LED_RED {32, 0, 0}; static const RGBColor LED_GREEN {0, 32, 0}; static const RGBColor LED_BLUE {0, 0, 32}; static const RGBColor LED_YELLOW {16, 16, 0}; static const RGBColor LED_ORANGE {24, 8, 0}; static const RGBColor LED_CYAN {0, 16, 16}; static const RGBColor LED_MAGENTA {16, 0, 16}; ``` #### çŠ¶æ€æ˜ å°„ **å……ç”µçŠ¶æ€**: çº¢è‰²ï¼ˆå……ç”µä¸­ï¼‰ã€ç»¿è‰²ï¼ˆå……ç”µå®Œæˆï¼‰ **é…å¯¹çŠ¶æ€**: è“è‰²ï¼ˆé…å¯¹æ¨¡å¼ï¼‰ã€é’è‰²ï¼ˆå·²è¿æ¥ï¼‰ **ç³»ç»ŸçŠ¶æ€**: ä¸åŒé¢œè‰²ç»„åˆè¡¨ç¤ºå„ç§å·¥ä½œæ¨¡å¼ **è‡ªå®šä¹‰æ¨¡å¼**: æ”¯æŒç”¨æˆ·å®šä¹‰é¢œè‰² ### 2. æ¿çº§æ”¯æŒ #### nRF5340å¼€å‘æ¿æ”¯æŒ (`nrf5340_audio_dk.h/c`) ```cpp // æ¿çº§åˆå§‹åŒ– int board_init(void); // ç¡¬ä»¶é…ç½® void configure_board_peripherals(void); // ç”µæºç®¡ç† void board_power_management_init(void); ``` #### OpenEarableæ¿çº§æ”¯æŒ (`openearable.h/c`) ```cpp // OpenEarableç‰¹å®šåˆå§‹åŒ– int openearable_board_init(void); // ç¡¬ä»¶æŠ½è±¡å±‚ void openearable_configure_peripherals(void); // æ¿çº§ç”µæºæ§åˆ¶ void openearable_power_control(void); ``` ### 3. ç‰ˆæœ¬ç®¡ç† (`board_version.h/c`) æä¾›ç¡¬ä»¶ç‰ˆæœ¬æ£€æµ‹å’Œç®¡ç†ï¼š ```cpp // ç‰ˆæœ¬æ£€æµ‹ enum board_version { BOARD_VERSION_UNKNOWN, BOARD_VERSION_1_0, BOARD_VERSION_2_0, BOARD_VERSION_2_1 }; // æ ¸å¿ƒæ¥å£ enum board_version get_board_version(void); const char* get_board_version_string(void); bool is_board_version_supported(enum board_version version); ``` #### ç‰ˆæœ¬æ£€æµ‹æœºåˆ¶ é€šè¿‡GPIOå¼•è„šçŠ¶æ€æ£€æµ‹ç¡¬ä»¶ç‰ˆæœ¬ æ”¯æŒå¤šç§ç‰ˆæœ¬çš„å…¼å®¹æ€§å¤„ç† ç‰ˆæœ¬ä¿¡æ¯ç”¨äºåŠŸèƒ½é€‚é… ### 4. é€šé“åˆ†é… (`channel_assignment.h/c`) ç®¡ç†éŸ³é¢‘é€šé“å’Œæ•°æ®æµçš„åˆ†é…ï¼š ```cpp // é€šé“åˆ†é…ç»“æ„ struct channel_assignment { uint8_t left_channel; uint8_t right_channel; uint8_t stream_id; }; // æ ¸å¿ƒæ¥å£ int channel_assignment_init(void); int assign_audio_channel(uint8_t stream_id, uint8_t* left, uint8_t* right); int release_audio_channel(uint8_t stream_id); ``` ### 5. å›ºä»¶ä¿¡æ¯ (`fw_info_app.h`) æä¾›å›ºä»¶ç‰ˆæœ¬å’Œæ„å»ºä¿¡æ¯ï¼š ```cpp // å›ºä»¶ä¿¡æ¯ç»“æ„ struct fw_info { uint32_t version_major; uint32_t version_minor; uint32_t version_patch; char build_date[16]; char build_time[16]; char git_commit[8]; }; // æ¥å£å‡½æ•° const struct fw_info* get_fw_info(void); void print_fw_info(void); ``` ### 6. é”™è¯¯å¤„ç† (`error_handler.c`) ç³»ç»Ÿé”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶ï¼š ```cpp // é”™è¯¯ç±»å‹å®šä¹‰ enum error_type { ERROR_HARDWARE, ERROR_MEMORY, ERROR_COMMUNICATION, ERROR_CONFIGURATION, ERROR_TIMEOUT }; // é”™è¯¯å¤„ç†å‡½æ•° void handle_error(enum error_type type, int error_code); void register_error_callback(void (*callback)(enum error_type, int)); void system_recovery(void); ``` ### 7. UICRç®¡ç† (`uicr.h/c`) ç”¨æˆ·ä¿¡æ¯é…ç½®å¯„å­˜å™¨(UICR)ç®¡ç†ï¼š ```cpp // UICRé…ç½® struct uicr_config { uint32_t device_id; uint32_t hw_version; uint32_t production_date; uint8_t calibration_data[32]; }; // æ¥å£å‡½æ•° int uicr_init(void); int uicr_read_config(struct uicr_config* config); int uicr_write_config(const struct uicr_config* config); bool uicr_is_programmed(void); ``` ## å®å®šä¹‰å·¥å…· (`macros/`) ### é€šç”¨å®å®šä¹‰ ```cpp // ä½æ“ä½œå® #define BIT_SET(val, bit) ((val) (1U << (bit))) #define BIT_CLEAR(val, bit) ((val) & ~(1U << (bit))) #define BIT_CHECK(val, bit) (((val) >> (bit)) & 1U) // æ•°ç»„æ“ä½œå® #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0])) // æ•°å­¦å® #define MIN(a, b) (((a) < (b)) ? (a) : (b)) #define MAX(a, b) (((a) > (b)) ? (a) : (b)) #define CLAMP(val, min, max) MIN(MAX(val, min), max) ``` ### è°ƒè¯•å® ```cpp #ifdef CONFIG_DEBUG #define DEBUG_PRINT(fmt, ...) printk(fmt, ##__VA_ARGS__) #define ASSERT(expr) do { \\ if (!(expr)) { \\ printk(\"ASSERT failed: %s:%d\\n\", __FILE__, __LINE__); \\ k_panic(); \\ } \\ } while(0) #else #define DEBUG_PRINT(fmt, ...) #define ASSERT(expr) #endif ``` ## çŠ¶æ€æŒ‡ç¤ºé€»è¾‘ ### 1. å¯åŠ¨çŠ¶æ€æŒ‡ç¤º ```cpp void indicate_boot_status(void) { // ç™½è‰²é—ªçƒ ç³»ç»Ÿå¯åŠ¨ state_indicator.set_custom_color({16, 16, 16}); k_sleep(K_MSEC(500)); state_indicator.set_custom_color(LED_OFF); } ``` ### 2. ç”µæ± çŠ¶æ€æŒ‡ç¤º ```cpp void indicate_battery_status(uint8_t level) { if (level > 80) { state_indicator.set_custom_color(LED_GREEN); // ç”µé‡å……è¶³ } else if (level > 30) { state_indicator.set_custom_color(LED_YELLOW); // ç”µé‡ä¸­ç­‰ } else if (level > 10) { state_indicator.set_custom_color(LED_ORANGE); // ç”µé‡è¾ƒä½ } else { state_indicator.set_custom_color(LED_RED); // ç”µé‡æä½ } } ``` ### 3. è¿æ¥çŠ¶æ€æŒ‡ç¤º ```cpp void indicate_connection_status(bool connected) { if (connected) { state_indicator.set_custom_color(LED_CYAN); // å·²è¿æ¥ } else { state_indicator.set_custom_color(LED_BLUE); // ç­‰å¾…è¿æ¥ } } ``` ## ç³»ç»Ÿåˆå§‹åŒ–æµç¨‹ ### 1. æ¿çº§åˆå§‹åŒ– ```cpp int system_init(void) { int ret; // 1. åŸºç¡€æ¿çº§åˆå§‹åŒ– ret board_init(); if (ret) return ret; // 2. ç‰ˆæœ¬æ£€æµ‹ enum board_version version get_board_version(); LOG_INF(\"Board version: %s\", get_board_version_string()); // 3. UICRåˆå§‹åŒ– ret uicr_init(); if (ret) return ret; // 4. é€šé“åˆ†é…åˆå§‹åŒ– ret channel_assignment_init(); if (ret) return ret; // 5. çŠ¶æ€æŒ‡ç¤ºå™¨åˆå§‹åŒ– struct earable_state initial_state {0}; state_indicator.init(initial_state); return 0; } ``` ### 2. å¤–è®¾é…ç½® ```cpp void configure_peripherals(void) { // GPIOé…ç½® configure_gpio_pins(); // I2Cé…ç½® configure_i2c_interfaces(); // SPIé…ç½® configure_spi_interfaces(); // ç”µæºåŸŸé…ç½® configure_power_domains(); } ``` ## é”™è¯¯å¤„ç†ç­–ç•¥ ### 1. é”™è¯¯åˆ†ç±»å¤„ç† ```cpp void handle_error(enum error_type type, int error_code) { switch (type) { case ERROR_HARDWARE: // ç¡¬ä»¶é”™è¯¯ è®°å½•å¹¶å°è¯•é‡å¯ç¡¬ä»¶ LOG_ERR(\"Hardware error: %d\", error_code); reset_hardware_peripherals(); break; case ERROR_MEMORY: // å†…å­˜é”™è¯¯ æ¸…ç†å†…å­˜å¹¶é‡å¯ LOG_ERR(\"Memory error: %d\", error_code); cleanup_memory(); system_restart(); break; case ERROR_COMMUNICATION: // é€šä¿¡é”™è¯¯ é‡ç½®é€šä¿¡æ¥å£ LOG_ERR(\"Communication error: %d\", error_code); reset_communication_interfaces(); break; default: LOG_ERR(\"Unknown error type: %d, code: %d\", type, error_code); break; } } ``` ### 2. ç³»ç»Ÿæ¢å¤æœºåˆ¶ ```cpp void system_recovery(void) { // 1. ä¿å­˜å…³é”®çŠ¶æ€ save_critical_state(); // 2. é‡ç½®å¤–è®¾ reset_all_peripherals(); // 3. é‡æ–°åˆå§‹åŒ– system_init(); // 4. æ¢å¤å…³é”®çŠ¶æ€ restore_critical_state(); // 5. çŠ¶æ€æŒ‡ç¤º indicate_recovery_complete(); } ``` ## é…ç½®ç®¡ç† ### Kconfig é€‰é¡¹ ```kconfig # è°ƒè¯•é€‰é¡¹ config UTILS_DEBUG bool \"Enable utils module debug\" default n # çŠ¶æ€æŒ‡ç¤ºé€‰é¡¹ config STATE_INDICATOR_BRIGHTNESS int \"LED brightness level (0 255)\" range 0 255 default 32 # ç‰ˆæœ¬æ£€æµ‹é€‰é¡¹ config BOARD_VERSION_DETECTION bool \"Enable board version detection\" default y # é”™è¯¯æ¢å¤é€‰é¡¹ config ERROR_RECOVERY_ENABLED bool \"Enable automatic error recovery\" default y ``` ### è®¾å¤‡æ ‘é…ç½® ```dts / { board_config { compatible \"openearable,board config\"; version gpio <&gpio0 28 GPIO_ACTIVE_HIGH>; status led <&led_rgb>; }; }; ``` ## æ€§èƒ½ç›‘æ§ ### ç³»ç»Ÿèµ„æºç›‘æ§ ```cpp struct system_stats { uint32_t cpu_usage; uint32_t memory_usage; uint32_t stack_usage; uint32_t heap_free; }; void get_system_stats(struct system_stats* stats) { // CPUä½¿ç”¨ç‡ stats >cpu_usage get_cpu_usage_percent(); // å†…å­˜ä½¿ç”¨æƒ…å†µ stats >memory_usage get_memory_usage_bytes(); stats >heap_free get_heap_free_bytes(); // æ ˆä½¿ç”¨æƒ…å†µ stats >stack_usage get_stack_usage_bytes(); } ``` ### è¿è¡Œæ—¶ç»Ÿè®¡ ```cpp void print_runtime_stats(void) { struct system_stats stats; get_system_stats(&stats); LOG_INF(\"System Stats:\"); LOG_INF(\" CPU Usage: %u%%\", stats.cpu_usage); LOG_INF(\" Memory Usage: %u bytes\", stats.memory_usage); LOG_INF(\" Heap Free: %u bytes\", stats.heap_free); LOG_INF(\" Stack Usage: %u bytes\", stats.stack_usage); } ``` ## è°ƒè¯•å’Œè¯Šæ–­ ### è¯Šæ–­ä¿¡æ¯æ”¶é›† ```cpp void collect_diagnostic_info(void) { // å›ºä»¶ä¿¡æ¯ const struct fw_info* fw get_fw_info(); LOG_INF(\"Firmware: v%u.%u.%u\", fw >version_major, fw >version_minor, fw >version_patch); // ç¡¬ä»¶ä¿¡æ¯ LOG_INF(\"Board: %s\", get_board_version_string()); // ç³»ç»ŸçŠ¶æ€ print_runtime_stats(); // UICRä¿¡æ¯ struct uicr_config uicr; if (uicr_read_config(&uicr) 0) { LOG_INF(\"Device ID: 0x%08x\", uicr.device_id); LOG_INF(\"HW Version: 0x%08x\", uicr.hw_version); } } ``` ## æ€»ç»“ ç³»ç»Ÿå·¥å…·æ¨¡å—æä¾›äº†å®Œæ•´çš„ç³»ç»Ÿæ”¯æ’‘åŠŸèƒ½ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š 1. **å…¨é¢æ€§**: æ¶µç›–çŠ¶æ€æŒ‡ç¤ºã€ç‰ˆæœ¬ç®¡ç†ã€é”™è¯¯å¤„ç†ç­‰å„ä¸ªæ–¹é¢ 2. **å¯é æ€§**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œç³»ç»Ÿæ¢å¤æœºåˆ¶ 3. **å¯ç»´æŠ¤æ€§**: æ¸…æ™°çš„ç‰ˆæœ¬ç®¡ç†å’Œè¯Šæ–­ä¿¡æ¯ 4. **å¯é…ç½®æ€§**: ä¸°å¯Œçš„é…ç½®é€‰é¡¹å’Œæ¿çº§é€‚é… 5. **å¯è§‚æµ‹æ€§**: å®Œæ•´çš„çŠ¶æ€æŒ‡ç¤ºå’Œè¿è¡Œæ—¶ç›‘æ§ è¯¥æ¨¡å—ä¸ºOpenEarableè®¾å¤‡æä¾›äº†ç¨³å®šå¯é çš„ç³»ç»ŸåŸºç¡€è®¾æ–½ï¼Œç¡®ä¿è®¾å¤‡çš„æ­£å¸¸è¿è¡Œå’Œå¯ç»´æŠ¤æ€§ã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/architecture.html":{"title":"OpenEarable 2.0 æºç æ¶æ„åˆ†æ","content":"# OpenEarable 2.0 æºç æ¶æ„åˆ†æ ## é¡¹ç›®ç»“æ„æ¦‚è§ˆ ``` openearable v2/ â”œâ”€â”€ CMakeLists.txt # ä¸»æ„å»ºé…ç½®æ–‡ä»¶ â”œâ”€â”€ prj.conf # é¡¹ç›®é…ç½®æ–‡ä»¶ â”œâ”€â”€ prj_release.conf # å‘å¸ƒç‰ˆæœ¬é…ç½® â”œâ”€â”€ prj_fota.conf # FOTAç‰ˆæœ¬é…ç½® â”œâ”€â”€ boards/ # æ¿çº§æ”¯æŒåŒ… â”‚ â””â”€â”€ teco/openearable_v2/ # OpenEarable v2ç¡¬ä»¶é…ç½® â”œâ”€â”€ src/ # æºä»£ç ç›®å½• â”‚ â”œâ”€â”€ audio/ # éŸ³é¢‘å¤„ç†æ¨¡å— â”‚ â”œâ”€â”€ Battery/ # ç”µæºç®¡ç†æ¨¡å— â”‚ â”œâ”€â”€ bluetooth/ # è“ç‰™é€šä¿¡æ¨¡å— â”‚ â”œâ”€â”€ buttons/ # æŒ‰é”®å¤„ç†æ¨¡å— â”‚ â”œâ”€â”€ drivers/ # ç¡¬ä»¶é©±åŠ¨æ¨¡å— â”‚ â”œâ”€â”€ modules/ # é€šç”¨åŠŸèƒ½æ¨¡å— â”‚ â”œâ”€â”€ SensorManager/ # ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— â”‚ â”œâ”€â”€ SD_Card/ # SDå¡ç®¡ç†æ¨¡å— â”‚ â”œâ”€â”€ ParseInfo/ # æ•°æ®è§£ææ¨¡å— â”‚ â”œâ”€â”€ Wire/ # I2Cé€šä¿¡æ¨¡å— â”‚ â””â”€â”€ utils/ # å·¥å…·å‡½æ•°æ¨¡å— â”œâ”€â”€ unicast_server/ # å•æ’­æœåŠ¡å™¨åº”ç”¨ â”‚ â””â”€â”€ main.cpp # ä¸»å…¥å£æ–‡ä»¶ â”œâ”€â”€ broadcast_sink/ # å¹¿æ’­æ¥æ”¶å™¨åº”ç”¨ â”œâ”€â”€ include/ # å…¬å…±å¤´æ–‡ä»¶ â””â”€â”€ tools/ # æ„å»ºå’Œçƒ§å½•å·¥å…· ``` ## åº”ç”¨æ¶æ„åˆ†æ ### ä¸»åº”ç”¨å…¥å£ (unicast_server/main.cpp) é¡¹ç›®ä¸»è¦ä»¥å•æ’­æœåŠ¡å™¨æ¨¡å¼è¿è¡Œï¼Œä¸»è¦åˆå§‹åŒ–æµç¨‹ï¼š 1. **ç³»ç»Ÿåˆå§‹åŒ–** ç”µæºç®¡ç†å™¨åˆå§‹åŒ– USBè®¾å¤‡æ ˆä½¿èƒ½ éŸ³é¢‘æµæ§åˆ¶å¯åŠ¨ 2. **çŠ¶æ€ç®¡ç†** SIRK (Set Identity Resolving Key) æ£€æŸ¥ é…å¯¹çŠ¶æ€è®¾ç½® LEDçŠ¶æ€æŒ‡ç¤ºå™¨åˆå§‹åŒ– 3. **æœåŠ¡åˆå§‹åŒ–** ä¼ æ„Ÿå™¨ç®¡ç†å™¨åˆå§‹åŒ– è“ç‰™æœåŠ¡åˆå§‹åŒ–ï¼ˆLEDã€ç”µæ± ã€æŒ‰é”®ã€ä¼ æ„Ÿå™¨ç­‰ï¼‰ æ•°æ®è§£ææœåŠ¡åˆå§‹åŒ– ### æ ¸å¿ƒæ¨¡å—æ¶æ„ #### 1. ç”µæºç®¡ç†æ¨¡å— (src/Battery/) **PowerManager**: ç”µæºçŠ¶æ€ç®¡ç† **BQ27220**: ç”µæ± ç›‘æµ‹èŠ¯ç‰‡é©±åŠ¨ **BQ25120a**: ç”µæ± å……ç”µç®¡ç†èŠ¯ç‰‡é©±åŠ¨ **BootState**: å¯åŠ¨çŠ¶æ€ç®¡ç† #### 2. éŸ³é¢‘å¤„ç†æ¨¡å— (src/audio/) **audio_datapath**: éŸ³é¢‘æ•°æ®è·¯å¾„å¤„ç† **audio_system**: éŸ³é¢‘å­ç³»ç»Ÿç®¡ç† **Equalizer**: éŸ³é¢‘å‡è¡¡å™¨ **streamctrl**: éŸ³é¢‘æµæ§åˆ¶ **pdm_mic**: PDMéº¦å…‹é£é©±åŠ¨ #### 3. è“ç‰™é€šä¿¡æ¨¡å— (src/bluetooth/) **bt_management**: è“ç‰™è¿æ¥ç®¡ç† **bt_stream**: è“ç‰™éŸ³é¢‘æµå¤„ç† **gatt_services**: GATTæœåŠ¡å®ç° device_info: è®¾å¤‡ä¿¡æ¯æœåŠ¡ battery_service: ç”µæ± æœåŠ¡ sensor_service: ä¼ æ„Ÿå™¨æœåŠ¡ led_service: LEDæ§åˆ¶æœåŠ¡ button_service: æŒ‰é”®æœåŠ¡ #### 4. ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— (src/SensorManager/) **SensorManager**: ä¼ æ„Ÿå™¨ç»Ÿä¸€ç®¡ç†æ¥å£ **DefaultSensors**: é»˜è®¤ä¼ æ„Ÿå™¨é…ç½® **SensorScheme**: ä¼ æ„Ÿå™¨æ–¹æ¡ˆå®šä¹‰ #### 5. ç¡¬ä»¶é©±åŠ¨æ¨¡å— (src/drivers/) **ADAU1860**: éŸ³é¢‘ç¼–è§£ç å™¨é©±åŠ¨ **LED_Controller**: LEDæ§åˆ¶é©±åŠ¨ #### 6. æ•°æ®å­˜å‚¨æ¨¡å— (src/SD_Card/) **SDLogger**: SDå¡æ•°æ®è®°å½• **SD_Card_Manager**: SDå¡ç®¡ç† **Benchmark**: æ€§èƒ½æµ‹è¯• #### 7. é€šä¿¡æ¨¡å— (src/Wire/) I2Cé€šä¿¡åè®®å®ç° ä¼ æ„Ÿå™¨é€šä¿¡æ¥å£ #### 8. å·¥å…·æ¨¡å— (src/utils/) **StateIndicator**: çŠ¶æ€æŒ‡ç¤ºå™¨ **macros**: é€šç”¨å®å®šä¹‰ **fw_info**: å›ºä»¶ä¿¡æ¯ç®¡ç† ## å…³é”®ç‰¹æ€§ ### å¤šåº”ç”¨æ¶æ„æ”¯æŒ **å•æ’­æœåŠ¡å™¨** (unicast_server): ä¸»è¦åº”ç”¨æ¨¡å¼ï¼Œä½œä¸ºéŸ³é¢‘æ¥æ”¶ç«¯ **å¹¿æ’­æ¥æ”¶å™¨** (broadcast_sink): å¹¿æ’­éŸ³é¢‘æ¥æ”¶æ¨¡å¼ ### æ¨¡å—åŒ–è®¾è®¡ æ¯ä¸ªåŠŸèƒ½æ¨¡å—éƒ½æœ‰ç‹¬ç«‹çš„CMakeLists.txt æ¨¡å—é—´é€šè¿‡å®šä¹‰è‰¯å¥½çš„æ¥å£é€šä¿¡ æ”¯æŒæ¨¡å—çš„ç‹¬ç«‹å¼€å‘å’Œæµ‹è¯• ### ç¡¬ä»¶æŠ½è±¡ é€šè¿‡è®¾å¤‡æ ‘(DTS)æ–‡ä»¶è¿›è¡Œç¡¬ä»¶é…ç½® é©±åŠ¨å±‚ä¸åº”ç”¨å±‚åˆ†ç¦» æ”¯æŒå¤šç§ç¡¬ä»¶å¹³å° ### ç”µæºç®¡ç† å®Œæ•´çš„ç”µæ± çŠ¶æ€ç›‘æ§ å……ç”µçŠ¶æ€ç®¡ç† ä½åŠŸè€—ä¼˜åŒ– ### ä¼ æ„Ÿå™¨é›†æˆ ç»Ÿä¸€çš„ä¼ æ„Ÿå™¨ç®¡ç†æ¥å£ æ”¯æŒå¤šç§ä¼ æ„Ÿå™¨ç±»å‹ å¯é…ç½®çš„é‡‡æ ·ç‡å’Œæ•°æ®æ ¼å¼ ## æ„å»ºç³»ç»Ÿ ### CMakeé…ç½® ä½¿ç”¨Zephyr RTOSæ„å»ºç³»ç»Ÿ æ”¯æŒæ¡ä»¶ç¼–è¯‘é…ç½® æ¨¡å—åŒ–çš„å­ç›®å½•æ„å»º ### é…ç½®æ–‡ä»¶ **prj.conf**: åŸºç¡€é…ç½® **prj_release.conf**: å‘å¸ƒç‰ˆæœ¬ä¼˜åŒ–é…ç½® **prj_fota.conf**: æ”¯æŒå›ºä»¶å‡çº§çš„é…ç½® ### ç¼–è¯‘æ ‡å¿— `HEADSET 1`: è€³æœºæ¨¡å¼ `GATEWAY 2`: ç½‘å…³æ¨¡å¼ æ”¯æŒä¸åŒçš„éŸ³é¢‘é…ç½®å’ŒåŠŸèƒ½ ## æ¨¡å—é—´é€šä¿¡æœºåˆ¶ ### ZBus æ¶ˆæ¯æ€»çº¿ åŸºäºZephyr ZBusçš„å‘å¸ƒ è®¢é˜…æ¨¡å¼ æ¨¡å—é—´è§£è€¦çš„å¼‚æ­¥é€šä¿¡ æ”¯æŒå¤šè®¢é˜…è€…çš„äº‹ä»¶åˆ†å‘ ### å…³é”®æ¶ˆæ¯ç±»å‹ **button_msg**: æŒ‰é”®äº‹ä»¶æ¶ˆæ¯ **sensor_msg**: ä¼ æ„Ÿå™¨æ•°æ®æ¶ˆæ¯ **battery_msg**: ç”µæ± çŠ¶æ€æ¶ˆæ¯ **audio_msg**: éŸ³é¢‘çŠ¶æ€æ¶ˆæ¯ ### å·¥ä½œé˜Ÿåˆ—å’Œçº¿ç¨‹ å„æ¨¡å—ä½¿ç”¨ç‹¬ç«‹çš„å·¥ä½œé˜Ÿåˆ— ä¼˜å…ˆçº§é…ç½®çš„å¤šçº¿ç¨‹æ¶æ„ ä¸­æ–­å®‰å…¨çš„æ¶ˆæ¯ä¼ é€’ ## æ•°æ®æµåˆ†æ ### éŸ³é¢‘æ•°æ®æµ ``` PDMéº¦å…‹é£ â†’ éŸ³é¢‘æ•°æ®è·¯å¾„ â†’ å‡è¡¡å™¨å¤„ç† â†’ è“ç‰™LE Audio â†’ è¿œç¨‹è®¾å¤‡ ``` ### ä¼ æ„Ÿå™¨æ•°æ®æµ ``` ç‰©ç†ä¼ æ„Ÿå™¨ â†’ ä¼ æ„Ÿå™¨ç®¡ç†å™¨ â†’ æ•°æ®èåˆ â†’ è“ç‰™GATT â†’ å®¢æˆ·ç«¯åº”ç”¨ â†“ SDå¡å­˜å‚¨ ``` ### æ§åˆ¶æµ ``` ç‰©ç†æŒ‰é”® â†’ æŒ‰é”®ç®¡ç†å™¨ â†’ ZBusæ¶ˆæ¯ â†’ å„åŠŸèƒ½æ¨¡å— â†’ çŠ¶æ€æ›´æ–° â†’ LEDæŒ‡ç¤º ``` ## åŠŸè€—ä¼˜åŒ–ç­–ç•¥ ### åŠ¨æ€é¢‘ç‡è°ƒèŠ‚ æ ¹æ®å·¥ä½œè´Ÿè½½è°ƒæ•´CPUé¢‘ç‡ ä¼ æ„Ÿå™¨æŒ‰éœ€é‡‡æ · éŸ³é¢‘æµè‡ªé€‚åº”æ¯”ç‰¹ç‡ ### å¤–è®¾ç®¡ç† æœªä½¿ç”¨å¤–è®¾çš„è‡ªåŠ¨å…³é—­ I2C/SPIæ¥å£çš„ä½åŠŸè€—æ¨¡å¼ GPIOå¼•è„šçš„åˆç†é…ç½® ### ç¡çœ æœºåˆ¶ ç³»ç»Ÿç©ºé—²æ—¶è¿›å…¥ä½åŠŸè€—æ¨¡å¼ ä¸­æ–­å”¤é†’æœºåˆ¶ ç”µæ± ç”µé‡ç›‘æ§å’Œä¿æŠ¤ ## å®Œæ•´æ¨¡å—æ–‡æ¡£ ä»¥ä¸‹æ˜¯å„æ ¸å¿ƒæ¨¡å—çš„è¯¦ç»†åˆ†ææ–‡æ¡£ï¼š ### æ ¸å¿ƒåŠŸèƒ½æ¨¡å— 1. **[ç”µæºç®¡ç†æ¨¡å—](../modules/battery module.html)** ç”µæ± ç›‘æ§ã€å……ç”µç®¡ç†ã€åŠŸè€—ä¼˜åŒ– 2. **[éŸ³é¢‘å¤„ç†æ¨¡å—](../modules/audio module.html)** éŸ³é¢‘é‡‡é›†ã€å¤„ç†ã€æµæ§åˆ¶ 3. **[ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—](../modules/sensor module.html)** å¤šä¼ æ„Ÿå™¨èåˆã€æ•°æ®å¤„ç† 4. **[è“ç‰™é€šä¿¡æ¨¡å—](../modules/bluetooth module.html)** LE Audioã€GATTæœåŠ¡ã€è¿æ¥ç®¡ç† 5. **[æ•°æ®å­˜å‚¨æ¨¡å—](../modules/storage module.html)** SDå¡ç®¡ç†ã€æ•°æ®è®°å½• 6. **[ç¡¬ä»¶é©±åŠ¨æ¨¡å—](../modules/drivers module.html)** éŸ³é¢‘ç¼–è§£ç å™¨ã€LEDæ§åˆ¶å™¨ ### è¾…åŠ©åŠŸèƒ½æ¨¡å— 7. **[æŒ‰é”®å¤„ç†æ¨¡å—](../modules/buttons module.html)** ç‰©ç†æŒ‰é”®ã€é˜²æŠ–å¤„ç†ã€äº‹ä»¶åˆ†å‘ 8. **[æ•°æ®è§£ææ¨¡å—](../modules/parseinfo module.html)** ä¼ æ„Ÿå™¨æ•°æ®æ ¼å¼ã€è“ç‰™é…ç½®ä¿¡æ¯ 9. **[I2Cé€šä¿¡æ¨¡å—](../modules/wire module.html)** Arduinoå…¼å®¹I2Cæ¥å£ã€è®¾å¤‡é€šä¿¡ 10. **[ç³»ç»Ÿå·¥å…·æ¨¡å—](../modules/utils module.html)** çŠ¶æ€æŒ‡ç¤ºã€ç‰ˆæœ¬ç®¡ç†ã€é”™è¯¯å¤„ç† ## å¼€å‘æŒ‡å— ### æ·»åŠ æ–°ä¼ æ„Ÿå™¨ 1. åœ¨ `src/drivers/` ä¸‹åˆ›å»ºé©±åŠ¨æ–‡ä»¶ 2. åœ¨ `src/SensorManager/` ä¸­æ³¨å†Œä¼ æ„Ÿå™¨ 3. åœ¨ `src/ParseInfo/` ä¸­å®šä¹‰æ•°æ®æ ¼å¼ 4. åœ¨ `src/bluetooth/gatt_services/` ä¸­æ·»åŠ GATTç‰¹æ€§ ### æ·»åŠ æ–°åŠŸèƒ½æ¨¡å— 1. åˆ›å»ºæ¨¡å—ç›®å½•å’ŒCMakeLists.txt 2. å®šä¹‰æ¨¡å—æ¥å£å’Œæ•°æ®ç»“æ„ 3. å®ç°ZBusæ¶ˆæ¯å¤„ç† 4. åœ¨ä¸»åº”ç”¨ä¸­é›†æˆæ¨¡å— ### è°ƒè¯•å’Œæµ‹è¯• ä½¿ç”¨Zephyræ—¥å¿—ç³»ç»Ÿ é€šè¿‡UARTæˆ–RTTè¾“å‡ºè°ƒè¯•ä¿¡æ¯ å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•æ¡†æ¶ ## æ€»ç»“ OpenEarable 2.0é‡‡ç”¨äº†ç°ä»£åŒ–çš„åµŒå…¥å¼ç³»ç»Ÿæ¶æ„è®¾è®¡ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š 1. **æ¨¡å—åŒ–è®¾è®¡**: åŠŸèƒ½æ¨¡å—é«˜åº¦è§£è€¦ï¼Œä¾¿äºå¼€å‘å’Œç»´æŠ¤ 2. **æ¶ˆæ¯é©±åŠ¨**: åŸºäºZBusçš„å¼‚æ­¥æ¶ˆæ¯é€šä¿¡æœºåˆ¶ 3. **å¤šåº”ç”¨æ”¯æŒ**: æ”¯æŒä¸åŒçš„åº”ç”¨åœºæ™¯å’Œé…ç½® 4. **ç¡¬ä»¶æŠ½è±¡**: è‰¯å¥½çš„ç¡¬ä»¶æŠ½è±¡å±‚ï¼Œæ”¯æŒå¤šå¹³å°ç§»æ¤ 5. **åŠŸè€—ä¼˜åŒ–**: å…¨é¢çš„åŠŸè€—ç®¡ç†å’Œä¼˜åŒ–ç­–ç•¥ 6. **å¯æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°åŠŸèƒ½å’Œä¼ æ„Ÿå™¨ 7. **å¯è°ƒè¯•æ€§**: å®Œå–„çš„æ—¥å¿—å’Œè°ƒè¯•æœºåˆ¶ è¯¥æ¶æ„ä¸ºæ™ºèƒ½å¯ç©¿æˆ´è®¾å¤‡çš„å¼€å‘æä¾›äº†å®Œæ•´çš„è§£å†³æ–¹æ¡ˆï¼Œæ˜¯ä¸€ä¸ªå€¼å¾—å­¦ä¹ å’Œå€Ÿé‰´çš„ä¼˜ç§€å¼€æºé¡¹ç›®ã€‚ *æœ¬æ–‡æ¡£åŸºäºOpenEarable 2.0æºç æ·±åº¦åˆ†æç”Ÿæˆï¼Œå„æ¨¡å—çš„è¯¦ç»†æŠ€æœ¯æ–‡æ¡£è¯·å‚è€ƒç›¸å…³é“¾æ¥ã€‚*"},"/lhfdoc.github.io/embedded_dev/openearable/drivers-module.html":{"title":"ç¡¬ä»¶é©±åŠ¨æ¨¡å—è¯¦ç»†åˆ†æ","content":"# ç¡¬ä»¶é©±åŠ¨æ¨¡å—è¯¦ç»†åˆ†æ ## æ¨¡å—æ¦‚è¿° ç¡¬ä»¶é©±åŠ¨æ¨¡å—æä¾›OpenEarable 2.0ç¡¬ä»¶ç»„ä»¶çš„åº•å±‚é©±åŠ¨æ”¯æŒï¼Œä¸»è¦åŒ…æ‹¬éŸ³é¢‘ç¼–è§£ç å™¨ã€LEDæ§åˆ¶å™¨ç­‰å…³é”®ç¡¬ä»¶çš„é©±åŠ¨ç¨‹åºã€‚ ## æ–‡ä»¶ç»“æ„ ``` src/drivers/ â”œâ”€â”€ ADAU1860.h/.cpp # ADAU1860éŸ³é¢‘ç¼–è§£ç å™¨é©±åŠ¨ â”œâ”€â”€ LED_Controller/ # LEDæ§åˆ¶å™¨é©±åŠ¨ â”‚ â””â”€â”€ KTD2026.h/.cpp # KTD2026 RGB LEDé©±åŠ¨ â”œâ”€â”€ Lark eq.c # Larkå‡è¡¡å™¨ç®—æ³• â”œâ”€â”€ Lark fdsp.c # Larkæ•°å­—ä¿¡å·å¤„ç† â”œâ”€â”€ CMakeLists.txt # æ„å»ºé…ç½® â””â”€â”€ Kconfig # é…ç½®é€‰é¡¹ ``` ## æ ¸å¿ƒé©±åŠ¨ ### 1. ADAU1860 éŸ³é¢‘ç¼–è§£ç å™¨é©±åŠ¨ ADAU1860æ˜¯é«˜æ€§èƒ½ä½åŠŸè€—éŸ³é¢‘ç¼–è§£ç å™¨ï¼Œæ”¯æŒé«˜è´¨é‡éŸ³é¢‘è¾“å…¥è¾“å‡ºã€‚ #### ä¸»è¦ç‰¹æ€§ **é«˜è´¨é‡DAC/ADC**: 24ä½åˆ†è¾¨ç‡ï¼ŒSNR >100dB **ä½åŠŸè€—è®¾è®¡**: ä¼˜åŒ–çš„åŠŸè€—ç®¡ç† **çµæ´»è·¯ç”±**: å¯é…ç½®çš„éŸ³é¢‘ä¿¡å·è·¯ç”± **æ•°å­—éŸ³æ•ˆ**: å†…ç½®EQã€å‹ç¼©å™¨ç­‰éŸ³æ•ˆå¤„ç† ### 2. KTD2026 RGB LEDé©±åŠ¨ KTD2026æ˜¯ä¸‰é€šé“LEDé©±åŠ¨å™¨ï¼Œç”¨äºçŠ¶æ€æŒ‡ç¤ºå’Œç”¨æˆ·ç•Œé¢ã€‚ #### ä¸»è¦ç‰¹æ€§ **ä¸‰é€šé“æ§åˆ¶**: ç‹¬ç«‹çš„RGBé€šé“æ§åˆ¶ **PWMè°ƒå…‰**: é«˜ç²¾åº¦PWMäº®åº¦æ§åˆ¶ **ä½åŠŸè€—**: å¾…æœºç”µæµ<1Î¼A **I2Cæ§åˆ¶**: ç®€å•çš„I2Cæ¥å£ ## æ€»ç»“ ç¡¬ä»¶é©±åŠ¨æ¨¡å—ä¸ºOpenEarable 2.0çš„å…³é”®ç¡¬ä»¶ç»„ä»¶æä¾›äº†ç¨³å®šå¯é çš„é©±åŠ¨æ”¯æŒï¼Œç¡®ä¿äº†éŸ³é¢‘è´¨é‡å’Œç”¨æˆ·ç•Œé¢ä½“éªŒã€‚ä¸»è¦ç‰¹ç‚¹åŒ…æ‹¬ï¼š 1. **é«˜è´¨é‡éŸ³é¢‘æ”¯æŒ**: ADAU1860æä¾›ä¸“ä¸šçº§éŸ³é¢‘å¤„ç†èƒ½åŠ› 2. **ä¸°å¯Œè§†è§‰åé¦ˆ**: RGB LEDæ”¯æŒå¤šæ ·åŒ–çš„çŠ¶æ€æŒ‡ç¤º 3. **ä¼˜åŒ–åŠŸè€—ç®¡ç†**: æ‰€æœ‰é©±åŠ¨éƒ½è€ƒè™‘äº†ä½åŠŸè€—è®¾è®¡ 4. **æ ‡å‡†åŒ–æ¥å£**: åŸºäºI2Cç­‰æ ‡å‡†æ¥å£ï¼Œæ˜“äºé›†æˆå’Œç»´æŠ¤ è¯¥æ¨¡å—ä¸ºOpenEarable 2.0çš„ç¡¬ä»¶åŠŸèƒ½æä¾›äº†åšå®çš„è½¯ä»¶åŸºç¡€ã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/audio-module.html":{"title":"éŸ³é¢‘å¤„ç†æ¨¡å—è¯¦ç»†åˆ†æ","content":"# éŸ³é¢‘å¤„ç†æ¨¡å—è¯¦ç»†åˆ†æ ## æ¨¡å—æ¦‚è¿° éŸ³é¢‘å¤„ç†æ¨¡å—æ˜¯OpenEarable 2.0çš„æ ¸å¿ƒåŠŸèƒ½ç»„ä»¶ï¼Œè´Ÿè´£å®Œæ•´çš„éŸ³é¢‘ä¿¡å·é“¾å¤„ç†ï¼ŒåŒ…æ‹¬éŸ³é¢‘æ•è·ã€ç¼–è§£ç ã€æµæ§åˆ¶ã€ä¿¡å·å¤„ç†ç­‰åŠŸèƒ½ã€‚è¯¥æ¨¡å—åŸºäºnRF5340 Audio DKçš„æˆç†ŸéŸ³é¢‘æ¶æ„ï¼Œæ”¯æŒLE Audioåè®®å’Œé«˜è´¨é‡éŸ³é¢‘å¤„ç†ã€‚ ## æ–‡ä»¶ç»“æ„ ``` src/audio/ â”œâ”€â”€ streamctrl.h/.c # éŸ³é¢‘æµæ§åˆ¶æ ¸å¿ƒ â”œâ”€â”€ audio_datapath.h/.c # éŸ³é¢‘æ•°æ®è·¯å¾„å¤„ç† â”œâ”€â”€ audio_system.h/.c # éŸ³é¢‘å­ç³»ç»Ÿç®¡ç† â”œâ”€â”€ le_audio_rx.h/.c # LE Audioæ¥æ”¶å¤„ç† â”œâ”€â”€ pdm_mic.h/.c # PDMéº¦å…‹é£é©±åŠ¨ â”œâ”€â”€ sw_codec_select.h/.c # è½¯ä»¶ç¼–è§£ç å™¨é€‰æ‹© â”œâ”€â”€ Equalizer.h/.cpp # éŸ³é¢‘å‡è¡¡å™¨ â”œâ”€â”€ sdlogger_wrapper.h/.cpp # SDå¡æ—¥å¿—åŒ…è£…å™¨ â”œâ”€â”€ CMakeLists.txt # æ„å»ºé…ç½® â”œâ”€â”€ Kconfig # é…ç½®é€‰é¡¹ â””â”€â”€ Kconfig.defaults # é»˜è®¤é…ç½® ``` ## æ ¸å¿ƒç»„ä»¶åˆ†æ ### 1. StreamCtrl éŸ³é¢‘æµæ§åˆ¶å™¨ StreamCtrlæ˜¯éŸ³é¢‘æµå¤„ç†çš„æ ¸å¿ƒæ§åˆ¶ç»„ä»¶ï¼Œè´Ÿè´£ç®¡ç†éŸ³é¢‘æµçš„çŠ¶æ€å’Œæ•°æ®ä¼ è¾“ã€‚ #### ä¸»è¦åŠŸèƒ½ **æµçŠ¶æ€ç®¡ç†**: æ§åˆ¶æ’­æ”¾/æš‚åœçŠ¶æ€ **æ•°æ®ä¼ è¾“**: å¤„ç†éŸ³é¢‘æ•°æ®çš„å‘é€ **åŒæ­¥æ§åˆ¶**: ç¡®ä¿éŸ³é¢‘æ•°æ®çš„åŒæ­¥ä¼ è¾“ #### æ¥å£å®šä¹‰ ```cpp // æµçŠ¶æ€æšä¸¾ enum stream_state { STATE_STREAMING, // æ­£åœ¨æµä¼ è¾“ STATE_PAUSED, // æš‚åœçŠ¶æ€ }; // æ ¸å¿ƒæ¥å£å‡½æ•° uint8_t stream_state_get(void); // è·å–å½“å‰æµçŠ¶æ€ void streamctrl_send(const void *data, size_t size, uint8_t num_ch); // å‘é€éŸ³é¢‘æ•°æ® int streamctrl_start(); // å¯åŠ¨æµæ§åˆ¶ ``` #### å®ç°ç‰¹ç‚¹ **çŠ¶æ€æœºç®¡ç†**: ä½¿ç”¨çŠ¶æ€æœºæ§åˆ¶æµä¼ è¾“çŠ¶æ€ **å¤šå£°é“æ”¯æŒ**: æ”¯æŒå•å£°é“å’Œç«‹ä½“å£°éŸ³é¢‘ **ç¼“å†²ç®¡ç†**: æ™ºèƒ½çš„éŸ³é¢‘ç¼“å†²åŒºç®¡ç† ### 2. Audio Datapath éŸ³é¢‘æ•°æ®è·¯å¾„ éŸ³é¢‘æ•°æ®è·¯å¾„æ¨¡å—è´Ÿè´£éŸ³é¢‘æ•°æ®çš„å®Œæ•´å¤„ç†æµç¨‹ï¼Œä»è¾“å…¥åˆ°è¾“å‡ºçš„æ‰€æœ‰å¤„ç†ç¯èŠ‚ã€‚ #### ä¸»è¦åŠŸèƒ½ **éŸ³é¢‘åŒæ­¥**: åŸºäºæ—¶é—´æˆ³çš„éŸ³é¢‘åŒæ­¥ **æ ¼å¼è½¬æ¢**: éŸ³é¢‘æ ¼å¼å’Œé‡‡æ ·ç‡è½¬æ¢ **ä¿¡å·å¤„ç†**: éŸ³é¢‘å¢å¼ºå’Œé™å™ªå¤„ç† **æµ‹è¯•éŸ³ç”Ÿæˆ**: ç³»ç»Ÿæµ‹è¯•éŸ³é¢‘ä¿¡å·ç”Ÿæˆ #### æ ¸å¿ƒæ¥å£ ```cpp // ä¸»è¦å¤„ç†æ¥å£ void audio_datapath_stream_out(const uint8_t *buf, size_t size, uint32_t sdu_ref_us, bool bad_frame, uint32_t recv_frame_ts_us); // ç³»ç»Ÿæ§åˆ¶æ¥å£ int audio_datapath_start(struct data_fifo *fifo_rx); // å¯åŠ¨æ•°æ®è·¯å¾„ int audio_datapath_stop(void); // åœæ­¢æ•°æ®è·¯å¾„ int audio_datapath_init(void); // åˆå§‹åŒ–æ•°æ®è·¯å¾„ // éŸ³é¢‘å¢å¼ºåŠŸèƒ½ int audio_datapath_tone_play(uint16_t freq, uint16_t dur_ms, float amplitude); void audio_datapath_tone_stop(void); // åœæ­¢æµ‹è¯•éŸ³ // å»¶è¿Ÿæ§åˆ¶ int audio_datapath_pres_delay_us_set(uint32_t delay_us); void audio_datapath_pres_delay_us_get(uint32_t *delay_us); ``` #### æ•°æ®æµæ¶æ„ ``` [LE Audio RX] â†’ [Decoder] â†’ [Equalizer] â†’ [I2S Output] â†“ [SD Logger] (å¯é€‰) â†“ [Sensor Data] (å¯é€‰) ``` #### åŒæ­¥æœºåˆ¶ ```cpp // æ—¶é—´æˆ³åŒæ­¥å¤„ç† void audio_datapath_stream_out(const uint8_t *buf, size_t size, uint32_t sdu_ref_us, bool bad_frame, uint32_t recv_frame_ts_us) { // 1. è§£ç éŸ³é¢‘æ•°æ® // 2. è®¡ç®—æ’­æ”¾æ—¶é—´æˆ³ // 3. åº”ç”¨å‘ˆç°å»¶è¿Ÿ // 4. åŒæ­¥åˆ°I2Sè¾“å‡º // 5. è®°å½•åˆ°SDå¡(å¯é€‰) } ``` ### 3. Audio System éŸ³é¢‘å­ç³»ç»Ÿ éŸ³é¢‘å­ç³»ç»Ÿæä¾›é«˜å±‚æ¬¡çš„éŸ³é¢‘ç®¡ç†æ¥å£ï¼Œé›†æˆç¼–è§£ç å™¨ã€éŸ³é¢‘å¤„ç†å’Œç³»ç»Ÿæ§åˆ¶ã€‚ #### ä¸»è¦åŠŸèƒ½ **ç¼–è§£ç ç®¡ç†**: LC3ç¼–è§£ç å™¨æ§åˆ¶ **ç³»ç»Ÿé…ç½®**: éŸ³é¢‘å‚æ•°é…ç½®ç®¡ç† **æµ‹è¯•åŠŸèƒ½**: å†…ç½®æµ‹è¯•éŸ³ç”Ÿæˆ **æ€§èƒ½ä¼˜åŒ–**: éŸ³é¢‘å¤„ç†æ€§èƒ½ä¼˜åŒ– #### æ ¸å¿ƒæ¥å£ ```cpp // ç³»ç»Ÿæ§åˆ¶ void audio_system_start(void); // å¯åŠ¨éŸ³é¢‘ç³»ç»Ÿ void audio_system_stop(void); // åœæ­¢éŸ³é¢‘ç³»ç»Ÿ // ç¼–ç å™¨æ§åˆ¶ void audio_system_encoder_start(void); // å¯åŠ¨ç¼–ç å™¨ void audio_system_encoder_stop(void); // åœæ­¢ç¼–ç å™¨ // é…ç½®ç®¡ç† int audio_system_config_set(uint32_t encoder_sample_rate_hz, uint32_t encoder_bitrate, uint32_t decoder_sample_rate_hz); // è§£ç å¤„ç† int audio_system_decode(const void *encoded_data, size_t encoded_data_size, bool bad_frame); // æµ‹è¯•åŠŸèƒ½ int audio_system_encode_test_tone_set(uint32_t freq); int audio_system_encode_test_tone_step(void); // ç¼“å†²ç®¡ç† int audio_system_fifo_rx_block_drop(void); ``` #### é…ç½®å‚æ•° ```cpp struct audio_config { uint32_t sample_rate_hz; // é‡‡æ ·ç‡ uint32_t bitrate_bps; // æ¯”ç‰¹ç‡ uint8_t channels; // å£°é“æ•° uint16_t frame_size_us; // å¸§é•¿åº¦(å¾®ç§’) }; ``` ### 4. PDM Microphone PDMéº¦å…‹é£é©±åŠ¨ PDMéº¦å…‹é£æ¨¡å—è´Ÿè´£æ¿è½½éº¦å…‹é£çš„éŸ³é¢‘æ•è·åŠŸèƒ½ã€‚ #### ä¸»è¦åŠŸèƒ½ **PDMä¿¡å·é‡‡é›†**: è„‰å†²å¯†åº¦è°ƒåˆ¶ä¿¡å·é‡‡é›† **æ•°å­—æ»¤æ³¢**: PDMåˆ°PCMè½¬æ¢å’Œæ»¤æ³¢ **ç¼“å†²ç®¡ç†**: éŸ³é¢‘æ•°æ®ç¼“å†²å’Œé˜Ÿåˆ—ç®¡ç† #### æ¥å£å®šä¹‰ ```cpp // éº¦å…‹é£æ§åˆ¶ void pdm_mic_start(void); // å¯åŠ¨éº¦å…‹é£ void pdm_mic_stop(void); // åœæ­¢éº¦å…‹é£ int pdm_mic_init(void); // åˆå§‹åŒ–éº¦å…‹é£ // æ•°æ®è·¯å¾„ int pdm_datapath_start(struct data_fifo *fifo_rx); // å¯åŠ¨PDMæ•°æ®è·¯å¾„ ``` #### PDMé…ç½® ```cpp // PDMé…ç½®å‚æ•° struct pdm_config { uint32_t sample_rate; // é‡‡æ ·ç‡ (é€šå¸¸16kHz) uint8_t gain_l; // å·¦å£°é“å¢ç›Š uint8_t gain_r; // å³å£°é“å¢ç›Š uint8_t clock_freq; // PDMæ—¶é’Ÿé¢‘ç‡ }; ``` ### 5. Equalizer éŸ³é¢‘å‡è¡¡å™¨ éŸ³é¢‘å‡è¡¡å™¨æä¾›å®æ—¶éŸ³é¢‘å¢å¼ºå’Œé¢‘ç‡å“åº”è°ƒæ•´åŠŸèƒ½ã€‚ #### ä¸»è¦åŠŸèƒ½ **é¢‘ç‡å“åº”è°ƒæ•´**: å¤šé¢‘æ®µå‡è¡¡å¤„ç† **å®æ—¶å¤„ç†**: ä½å»¶è¿ŸéŸ³é¢‘å¤„ç† **å‚æ•°å¯è°ƒ**: æ”¯æŒåŠ¨æ€å‚æ•°è°ƒæ•´ #### æ¥å£å®šä¹‰ ```cpp #define EQ_ORDER 9 // å‡è¡¡å™¨é˜¶æ•° // å‡è¡¡å™¨æ§åˆ¶ void reset_eq(); // é‡ç½®å‡è¡¡å™¨ void equalize(int16_t *data, int length); // éŸ³é¢‘å‡è¡¡å¤„ç† ``` #### å‡è¡¡å™¨ç»“æ„ ```cpp // 9é˜¶æ•°å­—æ»¤æ³¢å™¨å®ç° struct eq_filter { float coeffs[EQ_ORDER]; // æ»¤æ³¢å™¨ç³»æ•° float delays[EQ_ORDER]; // å»¶è¿Ÿç¼“å†² float gain; // å¢ç›Šå‚æ•° }; ``` ### 6. LE Audio RX LE Audioæ¥æ”¶å¤„ç† LE Audioæ¥æ”¶æ¨¡å—è´Ÿè´£è“ç‰™LE Audioåè®®çš„éŸ³é¢‘æ•°æ®æ¥æ”¶å’Œå¤„ç†ã€‚ #### ä¸»è¦åŠŸèƒ½ **ISOæ•°æ®æ¥æ”¶**: æ¥æ”¶ISOéŸ³é¢‘æ•°æ®åŒ… **é”™è¯¯å¤„ç†**: ä¸¢åŒ…æ£€æµ‹å’Œé”™è¯¯æ¢å¤ **åŒæ­¥ç»´æŠ¤**: éŸ³é¢‘æµåŒæ­¥ç»´æŠ¤ **è´¨é‡ç›‘æ§**: éŸ³é¢‘è´¨é‡ç›‘æ§å’Œç»Ÿè®¡ #### æ•°æ®åŒ…å¤„ç† ```cpp // LE Audioæ•°æ®åŒ…ç»“æ„ struct le_audio_packet { uint32_t timestamp; // æ—¶é—´æˆ³ uint16_t seq_num; // åºåˆ—å· uint8_t *payload; // éŸ³é¢‘è´Ÿè½½ size_t payload_len; // è´Ÿè½½é•¿åº¦ bool crc_ok; // CRCæ ¡éªŒçŠ¶æ€ }; ``` ### 7. Software Codec Select è½¯ä»¶ç¼–è§£ç å™¨é€‰æ‹© è½¯ä»¶ç¼–è§£ç å™¨é€‰æ‹©æ¨¡å—æä¾›LC3ç­‰éŸ³é¢‘ç¼–è§£ç å™¨çš„é›†æˆæ¥å£ã€‚ #### æ”¯æŒçš„ç¼–è§£ç å™¨ **LC3**: LE Audioæ ‡å‡†ç¼–è§£ç å™¨ **SBC**: ç»å…¸è“ç‰™ç¼–è§£ç å™¨(å…¼å®¹æ€§) **Raw PCM**: æœªå‹ç¼©éŸ³é¢‘æ ¼å¼ #### ç¼–è§£ç å™¨æ¥å£ ```cpp // ç¼–è§£ç å™¨æ“ä½œæ¥å£ struct codec_interface { int (*init)(void); int (*encode)(const int16_t *input, uint8_t *output, size_t *output_size); int (*decode)(const uint8_t *input, size_t input_size, int16_t *output); void (*deinit)(void); }; ``` ## éŸ³é¢‘å¤„ç†æµç¨‹ ### æ’­æ”¾æµç¨‹ ``` [LE Audio RX] â†’ [LC3 Decode] â†’ [Equalizer] â†’ [I2S DAC] â†’ [æ‰¬å£°å™¨] â†“ [SD Logger] (å¯é€‰å½•åˆ¶) ``` ### å½•éŸ³æµç¨‹ ``` [PDM Mic] â†’ [Filter] â†’ [LC3 Encode] â†’ [LE Audio TX] â†’ [è“ç‰™ä¼ è¾“] â†“ [SD Logger] (å¯é€‰å½•åˆ¶) ``` ### åŒå‘é€šä¿¡æµç¨‹ ``` æ¥æ”¶: [LE Audio RX] â†’ [Decode] â†’ [Mix] â†’ [I2S Output] â†‘ å‘é€: [PDM Mic] â†’ [Encode] â†’ [LE Audio TX] ``` ## åŒæ­¥å’Œæ—¶åº ### éŸ³é¢‘åŒæ­¥æœºåˆ¶ ```cpp // æ—¶é—´æˆ³åŒæ­¥å¤„ç† void audio_sync_process(uint32_t sdu_ref_us, uint32_t recv_ts_us) { // 1. è®¡ç®—ä¼ è¾“å»¶è¿Ÿ uint32_t transport_delay recv_ts_us sdu_ref_us; // 2. åº”ç”¨å‘ˆç°å»¶è¿Ÿ uint32_t presentation_delay get_presentation_delay(); // 3. è®¡ç®—æ’­æ”¾æ—¶é—´ uint32_t play_time sdu_ref_us + presentation_delay; // 4. åŒæ­¥åˆ°I2Sæ’­æ”¾ schedule_i2s_playback(play_time); } ``` ### ç¼“å†²ç®¡ç† ```cpp // è‡ªé€‚åº”ç¼“å†²ç®¡ç† void adaptive_buffer_management() { // ç›‘æ§ç¼“å†²åŒºæ°´ä½ size_t buffer_level get_buffer_level(); if (buffer_level < LOW_THRESHOLD) { // ç¼“å†²åŒºè¿‡ä½ï¼Œå¢åŠ å»¶è¿Ÿ increase_buffer_size(); } else if (buffer_level > HIGH_THRESHOLD) { // ç¼“å†²åŒºè¿‡é«˜ï¼Œå‡å°‘å»¶è¿Ÿ decrease_buffer_size(); } } ``` ## éŸ³é¢‘è´¨é‡ä¼˜åŒ– ### 1. é™å™ªå¤„ç† ```cpp // æ•°å­—é™å™ªç®—æ³• void noise_reduction(int16_t *audio_data, size_t length) { // å®ç°è‡ªé€‚åº”æ»¤æ³¢é™å™ª for (size_t i 0; i < length; i++) { audio_data[i] apply_noise_filter(audio_data[i]); } } ``` ### 2. åŠ¨æ€èŒƒå›´æ§åˆ¶ ```cpp // è‡ªåŠ¨å¢ç›Šæ§åˆ¶ void agc_process(int16_t *audio_data, size_t length) { // è®¡ç®—éŸ³é¢‘èƒ½é‡ float energy calculate_energy(audio_data, length); // è°ƒæ•´å¢ç›Š float gain calculate_optimal_gain(energy); apply_gain(audio_data, length, gain); } ``` ### 3. å›å£°æ¶ˆé™¤ ```cpp // å£°å­¦å›å£°æ¶ˆé™¤(AEC) void echo_cancellation(int16_t *mic_data, int16_t *speaker_data, int16_t *output, size_t length) { // å®ç°è‡ªé€‚åº”å›å£°æ¶ˆé™¤ç®—æ³• adaptive_filter_process(mic_data, speaker_data, output, length); } ``` ## é…ç½®å‚æ•° ### éŸ³é¢‘é…ç½®é€‰é¡¹ ```kconfig # é‡‡æ ·ç‡é…ç½® CONFIG_AUDIO_SAMPLE_RATE_48000 y CONFIG_AUDIO_SAMPLE_RATE_16000 n # ç¼–è§£ç å™¨é…ç½® CONFIG_AUDIO_CODEC_LC3 y CONFIG_AUDIO_CODEC_SBC n # éŸ³é¢‘å¢å¼º CONFIG_AUDIO_EQUALIZER y CONFIG_AUDIO_NOISE_REDUCTION y CONFIG_AUDIO_AGC y # ç¼“å†²é…ç½® CONFIG_AUDIO_BUFFER_SIZE 4096 CONFIG_AUDIO_BUFFER_COUNT 4 ``` ### æ€§èƒ½å‚æ•° ```cpp // éŸ³é¢‘æ€§èƒ½å‚æ•° #define AUDIO_FRAME_SIZE_US 10000 // 10mså¸§é•¿ #define AUDIO_SAMPLE_RATE_HZ 48000 // 48kHzé‡‡æ ·ç‡ #define AUDIO_CHANNELS 2 // ç«‹ä½“å£° #define AUDIO_BITS_PER_SAMPLE 16 // 16ä½é‡‡æ ·æ·±åº¦ // å»¶è¿Ÿå‚æ•° #define PRESENTATION_DELAY_US 40000 // 40mså‘ˆç°å»¶è¿Ÿ #define PROCESSING_DELAY_US 5000 // 5mså¤„ç†å»¶è¿Ÿ ``` ## é”™è¯¯å¤„ç†å’Œæ¢å¤ ### éŸ³é¢‘ä¸­æ–­å¤„ç† ```cpp void audio_error_handler(audio_error_t error) { switch (error) { case AUDIO_UNDERRUN: // ç¼“å†²åŒºä¸‹æº¢å¤„ç† refill_audio_buffer(); break; case AUDIO_OVERRUN: // ç¼“å†²åŒºä¸Šæº¢å¤„ç† drop_old_audio_frames(); break; case AUDIO_SYNC_LOST: // åŒæ­¥ä¸¢å¤±å¤„ç† reinitialize_sync(); break; default: // é€šç”¨é”™è¯¯å¤„ç† restart_audio_system(); break; } } ``` ### è´¨é‡ç›‘æ§ ```cpp // éŸ³é¢‘è´¨é‡ç»Ÿè®¡ struct audio_quality_stats { uint32_t packets_received; // æ¥æ”¶åŒ…æ•° uint32_t packets_lost; // ä¸¢åŒ…æ•° uint32_t late_packets; // å»¶è¿ŸåŒ…æ•° float average_latency_ms; // å¹³å‡å»¶è¿Ÿ float jitter_ms; // æŠ–åŠ¨ }; ``` ## åŠŸè€—ä¼˜åŒ– ### åŠ¨æ€åŠŸè€—ç®¡ç† ```cpp void audio_power_management() { if (audio_stream_active()) { // æµä¼ è¾“æ´»è·ƒæ—¶ï¼Œä¿æŒé«˜æ€§èƒ½æ¨¡å¼ set_cpu_frequency(HIGH_FREQ); enable_audio_pll(); } else { // æµä¼ è¾“ç©ºé—²æ—¶ï¼Œé™ä½åŠŸè€— set_cpu_frequency(LOW_FREQ); disable_audio_pll(); } } ``` ## æ€»ç»“ éŸ³é¢‘å¤„ç†æ¨¡å—æ˜¯OpenEarable 2.0çš„æ ¸å¿ƒåŠŸèƒ½ç»„ä»¶ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š 1. **å®Œæ•´çš„éŸ³é¢‘é“¾**: ä»éŸ³é¢‘æ•è·åˆ°æ’­æ”¾çš„å®Œæ•´å¤„ç†é“¾ 2. **LE Audioæ”¯æŒ**: å®Œæ•´æ”¯æŒè“ç‰™LE Audioåè®®æ ˆ 3. **é«˜è´¨é‡å¤„ç†**: é›†æˆå‡è¡¡å™¨ã€é™å™ªç­‰éŸ³é¢‘å¢å¼ºåŠŸèƒ½ 4. **ä½å»¶è¿Ÿè®¾è®¡**: ä¼˜åŒ–çš„ç¼“å†²å’ŒåŒæ­¥æœºåˆ¶ 5. **æ¨¡å—åŒ–æ¶æ„**: å„åŠŸèƒ½æ¨¡å—ç‹¬ç«‹ï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±• 6. **å®æ—¶æ€§èƒ½**: æ»¡è¶³å®æ—¶éŸ³é¢‘å¤„ç†è¦æ±‚ 7. **åŠŸè€—ä¼˜åŒ–**: æ™ºèƒ½çš„åŠŸè€—ç®¡ç†ç­–ç•¥ è¯¥æ¨¡å—ä¸ºOpenEarable 2.0æä¾›äº†ä¸“ä¸šçº§çš„éŸ³é¢‘å¤„ç†èƒ½åŠ›ï¼Œæ”¯æŒé«˜è´¨é‡çš„éŸ³ä¹æ’­æ”¾ã€é€šè¯å’ŒéŸ³é¢‘é‡‡é›†åŠŸèƒ½ã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/storage-module.html":{"title":"æ•°æ®å­˜å‚¨æ¨¡å—è¯¦ç»†åˆ†æ","content":"# æ•°æ®å­˜å‚¨æ¨¡å—è¯¦ç»†åˆ†æ ## æ¨¡å—æ¦‚è¿° æ•°æ®å­˜å‚¨æ¨¡å—è´Ÿè´£OpenEarable 2.0çš„æœ¬åœ°æ•°æ®å­˜å‚¨åŠŸèƒ½ï¼Œä¸»è¦é€šè¿‡SDå¡å®ç°ä¼ æ„Ÿå™¨æ•°æ®å’ŒéŸ³é¢‘æ•°æ®çš„æœ¬åœ°è®°å½•ã€‚è¯¥æ¨¡å—æä¾›é«˜æ•ˆçš„æ•°æ®ç¼“å†²ã€æ–‡ä»¶ç®¡ç†å’Œå­˜å‚¨ä¼˜åŒ–åŠŸèƒ½ã€‚ ## æ–‡ä»¶ç»“æ„ ``` src/SD_Card/ â”œâ”€â”€ SDLogger/ # SDå¡æ•°æ®è®°å½•å™¨ â”‚ â”œâ”€â”€ SDLogger.h/.cpp # ä¸»è¦æ—¥å¿—è®°å½•ç±» â”‚ â””â”€â”€ CMakeLists.txt # æ„å»ºé…ç½® â”œâ”€â”€ SD_Card_Manager/ # SDå¡ç®¡ç†å™¨ â”‚ â”œâ”€â”€ SD_Card_Manager.h/.cpp # SDå¡ç®¡ç†æ¥å£ â”‚ â””â”€â”€ CMakeLists.txt # æ„å»ºé…ç½® â”œâ”€â”€ Benchmark/ # æ€§èƒ½æµ‹è¯• â”‚ â”œâ”€â”€ Benchmark.h/.cpp # å­˜å‚¨æ€§èƒ½æµ‹è¯• â”‚ â””â”€â”€ CMakeLists.txt # æ„å»ºé…ç½® â””â”€â”€ CMakeLists.txt # æ¨¡å—æ„å»ºé…ç½® ``` ## æ ¸å¿ƒç»„ä»¶ ### 1. SDLogger SDå¡æ—¥å¿—è®°å½•å™¨ SDLoggeræ˜¯æ•°æ®å­˜å‚¨çš„æ ¸å¿ƒç»„ä»¶ï¼Œæä¾›é«˜æ•ˆçš„ä¼ æ„Ÿå™¨æ•°æ®è®°å½•åŠŸèƒ½ã€‚ #### ä¸»è¦ç‰¹æ€§ **ç¼“å†²å†™å…¥**: ä½¿ç”¨ç¯å½¢ç¼“å†²åŒºä¼˜åŒ–å†™å…¥æ€§èƒ½ **å—å¯¹é½**: 4KBå—å¯¹é½ç¡®ä¿æœ€ä½³å­˜å‚¨æ€§èƒ½ **æ–‡ä»¶æ ¼å¼**: è‡ªå®šä¹‰äºŒè¿›åˆ¶æ ¼å¼(.oe)ä¼˜åŒ–å­˜å‚¨æ•ˆç‡ **ç‰ˆæœ¬ç®¡ç†**: æ–‡ä»¶å¤´åŒ…å«ç‰ˆæœ¬å’Œæ—¶é—´æˆ³ä¿¡æ¯ #### ç¼“å†²æ¶æ„ ```cpp class SDLogger { private: static constexpr size_t SD_BLOCK_SIZE 4096; // SDå¡å—å¤§å° static constexpr size_t BUFFER_BLOCK_COUNT 8; // ç¼“å†²åŒºå—æ•° static constexpr size_t BUFFER_SIZE SD_BLOCK_SIZE * BUFFER_BLOCK_COUNT; // 32KBç¼“å†²åŒº // æ–‡ä»¶å¤´ç»“æ„ struct __attribute__((packed)) FileHeader { uint16_t version; // æ–‡ä»¶æ ¼å¼ç‰ˆæœ¬ uint64_t timestamp; // åˆ›å»ºæ—¶é—´æˆ³ }; }; ``` ### 2. SD_Card_Manager SDå¡ç®¡ç†å™¨ SDå¡ç®¡ç†å™¨æä¾›SDå¡çš„åº•å±‚æ“ä½œæ¥å£ï¼ŒåŒ…æ‹¬æŒ‚è½½ã€å¸è½½ã€æ–‡ä»¶ç³»ç»Ÿç®¡ç†ç­‰ã€‚ #### ä¸»è¦åŠŸèƒ½ **SDå¡æ£€æµ‹**: è‡ªåŠ¨æ£€æµ‹SDå¡æ’å…¥å’Œç§»é™¤ **æ–‡ä»¶ç³»ç»Ÿç®¡ç†**: FAT32æ–‡ä»¶ç³»ç»Ÿæ”¯æŒ **é”™è¯¯å¤„ç†**: SDå¡é”™è¯¯æ£€æµ‹å’Œæ¢å¤ **æ€§èƒ½ç›‘æ§**: è¯»å†™æ€§èƒ½ç»Ÿè®¡ ### 3. æ•°æ®æ ¼å¼ #### ä¼ æ„Ÿå™¨æ•°æ®æ ¼å¼ ```cpp // ä¼ æ„Ÿå™¨æ•°æ®è®°å½•æ ¼å¼ struct sensor_log_entry { uint64_t timestamp; // æ—¶é—´æˆ³ (å¾®ç§’) uint8_t sensor_id; // ä¼ æ„Ÿå™¨ID uint8_t data_size; // æ•°æ®å¤§å° uint8_t data[]; // ä¼ æ„Ÿå™¨æ•°æ® } __attribute__((packed)); ``` #### æ–‡ä»¶æ ¼å¼ç»“æ„ ``` .oeæ–‡ä»¶æ ¼å¼: + + æ–‡ä»¶å¤´ (10å­—èŠ‚) ç‰ˆæœ¬ (2å­—èŠ‚) æ—¶é—´æˆ³ (8å­—èŠ‚) + + ä¼ æ„Ÿå™¨æ•°æ®è®°å½•1 + + ä¼ æ„Ÿå™¨æ•°æ®è®°å½•2 + + ... + + ``` ## æ€§èƒ½ä¼˜åŒ– ### ç¼“å†²å†™å…¥ç­–ç•¥ ```cpp void SDLogger::write_sensor_data(const sensor_data* data) { // 1. æ•°æ®å†™å…¥ç¯å½¢ç¼“å†²åŒº ring_buffer_put(&sd_buffer, (uint8_t*)data, sizeof(sensor_data)); // 2. æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å†™å…¥é˜ˆå€¼ if (ring_buffer_size_get(&sd_buffer) > WRITE_THRESHOLD) { // è§¦å‘æ‰¹é‡å†™å…¥ schedule_bulk_write(); } } ``` ### å—å¯¹é½ä¼˜åŒ– ```cpp // ç¡®ä¿å†™å…¥æ•°æ®å—å¯¹é½ static_assert(BUFFER_SIZE % SD_BLOCK_SIZE 0, \"BUFFER_SIZE must be a multiple of SD_BLOCK_SIZE\"); ``` ## æ€»ç»“ æ•°æ®å­˜å‚¨æ¨¡å—ä¸ºOpenEarable 2.0æä¾›äº†é«˜æ•ˆå¯é çš„æœ¬åœ°æ•°æ®å­˜å‚¨åŠŸèƒ½ï¼Œæ”¯æŒ: 1. **é«˜æ€§èƒ½å†™å…¥**: ç¼“å†²å’Œå—å¯¹é½ä¼˜åŒ– 2. **å¯é å­˜å‚¨**: é”™è¯¯æ£€æµ‹å’Œæ¢å¤æœºåˆ¶ 3. **æ ‡å‡†æ ¼å¼**: è‡ªå®šä¹‰äºŒè¿›åˆ¶æ ¼å¼ä¼˜åŒ–å­˜å‚¨æ•ˆç‡ 4. **æ˜“äºè§£æ**: Pythonå·¥å…·æ”¯æŒæ•°æ®è§£æå’Œåˆ†æ è¯¥æ¨¡å—ç¡®ä¿äº†ä¼ æ„Ÿå™¨æ•°æ®çš„å¯é æœ¬åœ°å­˜å‚¨ï¼Œä¸ºç¦»çº¿æ•°æ®åˆ†æå’Œç ”ç©¶æä¾›äº†é‡è¦æ”¯æŒã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/index.html":{"title":"OpenEarable 2.0 é¡¹ç›®åˆ†æ","content":"# OpenEarable 2.0 é¡¹ç›®åˆ†æ ## é¡¹ç›®æ¦‚è¿° OpenEarableæ˜¯ä¸€ä¸ªåŸºäºNordic nRF5340çš„å¼€æºæ™ºèƒ½è€³æˆ´è®¾å¤‡é¡¹ç›®ï¼Œæ—¨åœ¨æä¾›ä¸€ä¸ªå®Œæ•´çš„å¯ç©¿æˆ´è®¾å¤‡å¼€å‘å¹³å°ã€‚ ## é¡¹ç›®ç‰¹ç‚¹ åŒæ ¸å¤„ç†å™¨: åŸºäºNordic nRF5340åŒæ ¸SoC å¤šä¼ æ„Ÿå™¨æ”¯æŒ: é›†æˆå¤šç§ä¼ æ„Ÿå™¨ç”¨äºç”Ÿç†æ•°æ®ç›‘æµ‹ ä½åŠŸè€—è®¾è®¡: ä¼˜åŒ–çš„ç”µæºç®¡ç†ç³»ç»Ÿ æ— çº¿è¿æ¥: æ”¯æŒè“ç‰™BLEé€šä¿¡ å¼€æºæ¶æ„: å®Œå…¨å¼€æºçš„ç¡¬ä»¶å’Œè½¯ä»¶è®¾è®¡ ## ç³»ç»Ÿæ¶æ„ OpenEarable 2.0é‡‡ç”¨æ¨¡å—åŒ–æ¶æ„è®¾è®¡ï¼Œä¸»è¦åŒ…å«ä»¥ä¸‹æ ¸å¿ƒæ¨¡å—ï¼š ### æ ¸å¿ƒåŠŸèƒ½æ¨¡å— ç”µæºç®¡ç†æ¨¡å—: è´Ÿè´£è®¾å¤‡çš„ç”µæºæ§åˆ¶å’Œç”µæ± ç®¡ç† éŸ³é¢‘å¤„ç†æ¨¡å—: å¤„ç†éŸ³é¢‘è¾“å…¥è¾“å‡ºå’Œä¿¡å·å¤„ç† ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—: ç®¡ç†å„ç±»ä¼ æ„Ÿå™¨çš„æ•°æ®é‡‡é›† è“ç‰™é€šä¿¡æ¨¡å—: å¤„ç†ä¸å¤–éƒ¨è®¾å¤‡çš„æ— çº¿é€šä¿¡ æ•°æ®å­˜å‚¨æ¨¡å—: è´Ÿè´£æ•°æ®çš„æœ¬åœ°å­˜å‚¨å’Œç®¡ç† ç¡¬ä»¶é©±åŠ¨æ¨¡å—: åº•å±‚ç¡¬ä»¶è®¾å¤‡çš„é©±åŠ¨ç¨‹åº ### è¾…åŠ©åŠŸèƒ½æ¨¡å— æŒ‰é”®å¤„ç†æ¨¡å—: å¤„ç†ç”¨æˆ·è¾“å…¥å’Œäº¤äº’ æ•°æ®è§£ææ¨¡å—: è§£æå’Œå¤„ç†ä¼ æ„Ÿå™¨æ•°æ® I2Cé€šä¿¡æ¨¡å—: å¤„ç†I2Cæ€»çº¿é€šä¿¡ ç³»ç»Ÿå·¥å…·æ¨¡å—: æä¾›ç³»ç»Ÿçº§çš„å·¥å…·å‡½æ•° ## å¿«é€Ÿå¼€å§‹ 1. ç¡¬ä»¶å‡†å¤‡: è·å–OpenEarable 2.0å¼€å‘æ¿ 2. å¼€å‘ç¯å¢ƒ: è®¾ç½®Nordic nRF5340å¼€å‘ç¯å¢ƒ 3. ä»£ç ä¸‹è½½: ä»GitHubè·å–æœ€æ–°ä»£ç  4. ç¼–è¯‘çƒ§å½•: ç¼–è¯‘å›ºä»¶å¹¶çƒ§å½•åˆ°è®¾å¤‡ ## æ–‡æ¡£å¯¼èˆª ä½¿ç”¨å·¦ä¾§å¯¼èˆªæ æµè§ˆå„ä¸ªæ¨¡å—çš„è¯¦ç»†æ–‡æ¡£ï¼Œæ¯ä¸ªæ¨¡å—éƒ½åŒ…å«ï¼š åŠŸèƒ½ä»‹ç»å’Œè®¾è®¡åŸç† APIæ¥å£è¯´æ˜ ä½¿ç”¨ç¤ºä¾‹å’Œæœ€ä½³å®è·µ æ•…éšœæ’é™¤å’Œè°ƒè¯•æŒ‡å— æœ¬æ–‡æ¡£åŸºäºOpenEarable 2.0é¡¹ç›®è¿›è¡Œåˆ†ææ•´ç†ï¼Œæ—¨åœ¨å¸®åŠ©å¼€å‘è€…æ›´å¥½åœ°ç†è§£å’Œä½¿ç”¨è¯¥å¹³å°ã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/parseinfo-module.html":{"title":"OpenEarable 2.0 - æ•°æ®è§£ææ¨¡å— (ParseInfo Module)","content":"# OpenEarable 2.0 æ•°æ®è§£ææ¨¡å— (ParseInfo Module) ## æ¦‚è¿° æ•°æ®è§£ææ¨¡å—è´Ÿè´£å®šä¹‰å’Œç®¡ç†ä¼ æ„Ÿå™¨æ•°æ®çš„è§£ææ–¹æ¡ˆï¼Œä¸ºè“ç‰™é€šä¿¡æä¾›ä¼ æ„Ÿå™¨é…ç½®ä¿¡æ¯å’Œæ•°æ®æ ¼å¼æè¿°ã€‚è¯¥æ¨¡å—é€šè¿‡æ ‡å‡†åŒ–çš„æ•°æ®ç»“æ„å®šä¹‰ï¼Œä½¿å®¢æˆ·ç«¯èƒ½å¤Ÿæ­£ç¡®è§£æå’Œå¤„ç†æ¥è‡ªOpenEarableè®¾å¤‡çš„ä¼ æ„Ÿå™¨æ•°æ®ã€‚ ## æ ¸å¿ƒç»„ä»¶ ### 1. ä¼ æ„Ÿå™¨æ–¹æ¡ˆ (`SensorScheme.h/cpp`) å®šä¹‰ä¼ æ„Ÿå™¨çš„å®Œæ•´é…ç½®å’Œè§£ææ–¹æ¡ˆï¼š #### æ ¸å¿ƒæ•°æ®ç»“æ„ ```cpp struct SensorScheme { const char* name; // ä¼ æ„Ÿå™¨åç§° uint8_t id; // ä¼ æ„Ÿå™¨ID uint8_t groupCount; // ç»„ä»¶ç»„æ•°é‡ struct SensorComponentGroup* groups; // ç»„ä»¶ç»„æ•°ç»„ struct SensorConfigOptions configOptions; // é…ç½®é€‰é¡¹ }; struct ParseInfoScheme { uint8_t sensorCount; // ä¼ æ„Ÿå™¨æ•°é‡ uint8_t* sensorIds; // ä¼ æ„Ÿå™¨IDæ•°ç»„ }; ``` #### é…ç½®é€‰é¡¹ ```cpp enum SensorConfigOptionsMasks { DATA_STREAMING 0x01, // æ”¯æŒæ•°æ®æµä¼ è¾“ DATA_STORAGE 0x02, // æ”¯æŒæ•°æ®å­˜å‚¨ FREQUENCIES_DEFINED 0x10, // å®šä¹‰äº†é¢‘ç‡é€‰é¡¹ }; struct FrequencyOptions { uint8_t frequencyCount; // é¢‘ç‡é€‰é¡¹æ•°é‡ uint8_t defaultFrequencyIndex; // é»˜è®¤é¢‘ç‡ç´¢å¼• uint8_t maxBleFrequencyIndex; // æœ€å¤§è“ç‰™é¢‘ç‡ç´¢å¼• const float* frequencies; // é¢‘ç‡æ•°ç»„ }; struct SensorConfigOptions { uint8_t availableOptions; // å¯ç”¨é€‰é¡¹æ©ç  struct FrequencyOptions frequencyOptions; // é¢‘ç‡é€‰é¡¹ }; ``` #### æ ¸å¿ƒæ¥å£ ```cpp int initParseInfoService(struct ParseInfoScheme* scheme, struct SensorScheme* sensorSchemes); struct SensorScheme* getSensorSchemeForId(uint8_t id); struct ParseInfoScheme* getParseInfoScheme(); float getSampleRateForSensorId(uint8_t id, uint8_t frequencyIndex); float getSampleRateForSensor(struct SensorScheme* sensorScheme, uint8_t frequencyIndex); ``` ### 2. ä¼ æ„Ÿå™¨ç»„ä»¶ (`SensorComponent.h/cpp`) å®šä¹‰ä¼ æ„Ÿå™¨æ•°æ®çš„ç»„ä»¶ç»“æ„ï¼š #### åŸºæœ¬ç»„ä»¶ ```cpp struct SensorComponent { const char* name; // ç»„ä»¶åç§° (å¦‚ \"x\", \"y\", \"z\") const char* unit; // å•ä½ (å¦‚ \"m/sÂ²\", \"Â°/s\") enum ParseType parseType; // æ•°æ®ç±»å‹ }; ``` #### ç»„ä»¶ç»„ ```cpp struct SensorComponentGroup { const char* name; // ç»„åç§° (å¦‚ \"Accelerometer\") size_t componentCount; // ç»„ä»¶æ•°é‡ struct SensorComponent* components; // ç»„ä»¶æ•°ç»„ }; ``` #### åºåˆ—åŒ–æ¥å£ ```cpp size_t getSensorComponentGroupSize(struct SensorComponentGroup* group); ssize_t serializeSensorComponentGroup(struct SensorComponentGroup* group, char* buffer, size_t bufferSize); ``` ### 3. æ•°æ®ç±»å‹å®šä¹‰ (`ParseType.h`) å®šä¹‰æ”¯æŒçš„æ•°æ®è§£æç±»å‹ï¼š ```cpp enum ParseType { PARSE_TYPE_INT8, // 8ä½æœ‰ç¬¦å·æ•´æ•° PARSE_TYPE_UINT8, // 8ä½æ— ç¬¦å·æ•´æ•° PARSE_TYPE_INT16, // 16ä½æœ‰ç¬¦å·æ•´æ•° PARSE_TYPE_UINT16, // 16ä½æ— ç¬¦å·æ•´æ•° PARSE_TYPE_INT32, // 32ä½æœ‰ç¬¦å·æ•´æ•° PARSE_TYPE_UINT32, // 32ä½æ— ç¬¦å·æ•´æ•° PARSE_TYPE_FLOAT, // 32ä½æµ®ç‚¹æ•° PARSE_TYPE_DOUBLE, // 64ä½åŒç²¾åº¦æµ®ç‚¹æ•° }; const int parseTypeSizes[] { 1, // INT8/UINT8 1, 2, // INT16/UINT16 2, 4, // INT32/UINT32 4, 4, // FLOAT 8, // DOUBLE }; ``` ### 4. é»˜è®¤ä¼ æ„Ÿå™¨å®šä¹‰ (`DefaultSensors.h`) é¢„å®šä¹‰å¸¸ç”¨ä¼ æ„Ÿå™¨çš„é…ç½®æ–¹æ¡ˆï¼ˆå…·ä½“å®ç°å¯èƒ½åœ¨ç›¸åº”çš„.cppæ–‡ä»¶ä¸­ï¼‰ã€‚ ## è“ç‰™æœåŠ¡é›†æˆ ### GATT æœåŠ¡å®šä¹‰ ```cpp #define BT_UUID_PARSE_INFO_SERVICE_VAL \\ BT_UUID_128_ENCODE(0xcaa25cb7, 0x7e1b, 0x44f2, 0xadc9, 0xe8c06c9ced43) #define BT_UUID_PARSE_INFO_CHARAC_VAL \\ BT_UUID_128_ENCODE(0xcaa25cb9, 0x7e1b, 0x44f2, 0xadc9, 0xe8c06c9ced43) #define BT_UUID_PARSE_INFO_REQUEST_CHARAC_VAL \\ BT_UUID_128_ENCODE(0xcaa25cba, 0x7e1b, 0x44f2, 0xadc9, 0xe8c06c9ced43) #define BT_UUID_PARSE_INFO_RESPONSE_CHARAC_VAL \\ BT_UUID_128_ENCODE(0xcaa25cbb, 0x7e1b, 0x44f2, 0xadc9, 0xe8c06c9ced43) ``` ### ç‰¹æ€§åŠŸèƒ½ **Parse Info Service**: ä¸»æœåŠ¡ **Parse Info Characteristic**: åŸºæœ¬è§£æä¿¡æ¯ **Request Characteristic**: å®¢æˆ·ç«¯è¯·æ±‚ç‰¹å®šä¼ æ„Ÿå™¨ä¿¡æ¯ **Response Characteristic**: æœåŠ¡å™¨å“åº”ä¼ æ„Ÿå™¨é…ç½® ## å…¸å‹ä¼ æ„Ÿå™¨é…ç½®ç¤ºä¾‹ ### IMU ä¼ æ„Ÿå™¨æ–¹æ¡ˆ ```cpp // åŠ é€Ÿåº¦è®¡ç»„ä»¶ struct SensorComponent accel_components[] { {\"x\", \"m/sÂ²\", PARSE_TYPE_FLOAT}, {\"y\", \"m/sÂ²\", PARSE_TYPE_FLOAT}, {\"z\", \"m/sÂ²\", PARSE_TYPE_FLOAT} }; struct SensorComponentGroup accel_group { \"Accelerometer\", 3, accel_components }; // é™€èºä»ªç»„ä»¶ struct SensorComponent gyro_components[] { {\"x\", \"Â°/s\", PARSE_TYPE_FLOAT}, {\"y\", \"Â°/s\", PARSE_TYPE_FLOAT}, {\"z\", \"Â°/s\", PARSE_TYPE_FLOAT} }; struct SensorComponentGroup gyro_group { \"Gyroscope\", 3, gyro_components }; // é¢‘ç‡é€‰é¡¹ const float imu_frequencies[] {1.0f, 10.0f, 25.0f, 50.0f, 100.0f}; struct FrequencyOptions imu_freq_options { 5, // 5ä¸ªé¢‘ç‡é€‰é¡¹ 2, // é»˜è®¤25Hz (ç´¢å¼•2) 3, // è“ç‰™æœ€å¤§50Hz (ç´¢å¼•3) imu_frequencies }; // IMUä¼ æ„Ÿå™¨æ–¹æ¡ˆ struct SensorComponentGroup imu_groups[] {accel_group, gyro_group}; struct SensorScheme imu_scheme { \"IMU\", SENSOR_ID_IMU, 2, // 2ä¸ªç»„ä»¶ç»„ imu_groups, { DATA_STREAMING DATA_STORAGE FREQUENCIES_DEFINED, imu_freq_options } }; ``` ### PPG ä¼ æ„Ÿå™¨æ–¹æ¡ˆ ```cpp struct SensorComponent ppg_components[] { {\"raw\", \"counts\", PARSE_TYPE_UINT32}, {\"heart_rate\", \"bpm\", PARSE_TYPE_FLOAT} }; struct SensorComponentGroup ppg_group { \"PPG\", 2, ppg_components }; const float ppg_frequencies[] {25.0f, 50.0f, 100.0f}; struct FrequencyOptions ppg_freq_options { 3, 1, 2, // 3ä¸ªé€‰é¡¹ï¼Œé»˜è®¤50Hzï¼Œè“ç‰™æœ€å¤§100Hz ppg_frequencies }; struct SensorScheme ppg_scheme { \"PPG\", SENSOR_ID_PPG, 1, &ppg_group, { DATA_STREAMING DATA_STORAGE FREQUENCIES_DEFINED, ppg_freq_options } }; ``` ## æ•°æ®åºåˆ—åŒ– ### ç»„ä»¶ç»„å¤§å°è®¡ç®— ```cpp size_t getSensorComponentGroupSize(struct SensorComponentGroup* group) { size_t size 0; // ç»„åé•¿åº¦ + ç»„ä»¶æ•°é‡ size + strlen(group >name) + 1 + sizeof(group >componentCount); // æ¯ä¸ªç»„ä»¶çš„ä¿¡æ¯ for (size_t i 0; i < group >componentCount; i++) { size + strlen(group >components[i].name) + 1; size + strlen(group >components[i].unit) + 1; size + sizeof(group >components[i].parseType); } return size; } ``` ### åºåˆ—åŒ–æ ¼å¼ ``` [Group Name][Component Count] [Component 1 Name][Component 1 Unit][Component 1 Type] [Component 2 Name][Component 2 Unit][Component 2 Type] ... ``` ## åˆå§‹åŒ–æµç¨‹ ### 1. æœåŠ¡åˆå§‹åŒ– ```cpp int initParseInfoService(struct ParseInfoScheme* scheme, struct SensorScheme* sensorSchemes) { // 1. å­˜å‚¨ä¼ æ„Ÿå™¨æ–¹æ¡ˆå¼•ç”¨ // 2. åˆå§‹åŒ–è“ç‰™GATTæœåŠ¡ // 3. æ³¨å†Œç‰¹æ€§å›è°ƒå‡½æ•° // 4. å‡†å¤‡é»˜è®¤å“åº”æ•°æ® return 0; } ``` ### 2. æ–¹æ¡ˆæŸ¥è¯¢ ```cpp struct SensorScheme* getSensorSchemeForId(uint8_t id) { // éå†å·²æ³¨å†Œçš„ä¼ æ„Ÿå™¨æ–¹æ¡ˆ // æ ¹æ®IDåŒ¹é…å¹¶è¿”å›å¯¹åº”æ–¹æ¡ˆ return matching_scheme; } ``` ## å®¢æˆ·ç«¯äº¤äº’åè®® ### 1. è·å–ä¼ æ„Ÿå™¨åˆ—è¡¨ ``` Client Request: [REQUEST_SENSOR_LIST] Server Response: [SENSOR_COUNT][SENSOR_ID_1][SENSOR_ID_2]... ``` ### 2. è·å–ä¼ æ„Ÿå™¨é…ç½® ``` Client Request: [REQUEST_SENSOR_CONFIG][SENSOR_ID] Server Response: [SENSOR_NAME][GROUP_COUNT][GROUP_DATA...] ``` ### 3. è·å–é¢‘ç‡é€‰é¡¹ ``` Client Request: [REQUEST_FREQUENCIES][SENSOR_ID] Server Response: [FREQ_COUNT][DEFAULT_INDEX][MAX_BLE_INDEX][FREQ_1][FREQ_2]... ``` ## å†…å­˜ç®¡ç† ### é™æ€é…ç½® ä¼ æ„Ÿå™¨æ–¹æ¡ˆä½¿ç”¨é™æ€åˆ†é… ç»„ä»¶å®šä¹‰å­˜å‚¨åœ¨å¸¸é‡åŒºåŸŸ é¿å…è¿è¡Œæ—¶å†…å­˜åˆ†é… ### ç¼“å†²åŒºç®¡ç† åºåˆ—åŒ–ä½¿ç”¨é¢„åˆ†é…ç¼“å†²åŒº é˜²æ­¢ç¼“å†²åŒºæº¢å‡ºæ£€æŸ¥ é€‚å½“çš„é”™è¯¯å¤„ç† ## æ‰©å±•æ€§è®¾è®¡ ### æ–°ä¼ æ„Ÿå™¨æ·»åŠ  1. å®šä¹‰ä¼ æ„Ÿå™¨ç»„ä»¶ç»“æ„ 2. åˆ›å»ºä¼ æ„Ÿå™¨æ–¹æ¡ˆ 3. åœ¨é»˜è®¤æ–¹æ¡ˆä¸­æ³¨å†Œ 4. æ›´æ–°ä¼ æ„Ÿå™¨IDæšä¸¾ ### æ–°æ•°æ®ç±»å‹æ”¯æŒ 1. æ‰©å±• `ParseType` æšä¸¾ 2. æ›´æ–° `parseTypeSizes` æ•°ç»„ 3. ä¿®æ”¹åºåˆ—åŒ–/ååºåˆ—åŒ–é€»è¾‘ ## è°ƒè¯•å’ŒéªŒè¯ ### é…ç½®éªŒè¯ æ£€æŸ¥ç»„ä»¶æ•°é‡ä¸€è‡´æ€§ éªŒè¯é¢‘ç‡é€‰é¡¹æœ‰æ•ˆæ€§ ç¡®è®¤æ•°æ®ç±»å‹æ”¯æŒ ### åºåˆ—åŒ–æµ‹è¯• ç¼“å†²åŒºå¤§å°éªŒè¯ æ•°æ®å®Œæ•´æ€§æ£€æŸ¥ è·¨å¹³å°å…¼å®¹æ€§æµ‹è¯• ## æ€»ç»“ æ•°æ®è§£ææ¨¡å—æä¾›äº†å®Œæ•´çš„ä¼ æ„Ÿå™¨æ•°æ®æ ¼å¼å®šä¹‰å’Œç®¡ç†æ¡†æ¶ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š 1. **æ ‡å‡†åŒ–**: ç»Ÿä¸€çš„æ•°æ®æ ¼å¼å®šä¹‰å’Œè§£ææ–¹æ¡ˆ 2. **çµæ´»æ€§**: æ”¯æŒå¤šç§æ•°æ®ç±»å‹å’Œä¼ æ„Ÿå™¨é…ç½® 3. **å¯æ‰©å±•**: æ˜“äºæ·»åŠ æ–°ä¼ æ„Ÿå™¨å’Œæ•°æ®ç±»å‹ 4. **é«˜æ•ˆæ€§**: é™æ€é…ç½®å’Œä¼˜åŒ–çš„åºåˆ—åŒ–æœºåˆ¶ 5. **å…¼å®¹æ€§**: è“ç‰™GATTæœåŠ¡é›†æˆå’Œè·¨å¹³å°æ”¯æŒ è¯¥æ¨¡å—ä¸ºOpenEarableè®¾å¤‡çš„æ•°æ®é€šä¿¡æä¾›äº†å¯é çš„æ ¼å¼åŒ–åŸºç¡€è®¾æ–½ï¼Œç¡®ä¿å®¢æˆ·ç«¯èƒ½å¤Ÿæ­£ç¡®è§£æå’Œå¤„ç†ä¼ æ„Ÿå™¨æ•°æ®ã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/bluetooth-module.html":{"title":"è“ç‰™é€šä¿¡æ¨¡å—è¯¦ç»†åˆ†æ","content":"# è“ç‰™é€šä¿¡æ¨¡å—è¯¦ç»†åˆ†æ ## æ¨¡å—æ¦‚è¿° è“ç‰™é€šä¿¡æ¨¡å—æ˜¯OpenEarable 2.0ä¸å¤–éƒ¨è®¾å¤‡é€šä¿¡çš„æ ¸å¿ƒç»„ä»¶ï¼ŒåŸºäºBluetooth LE Audioåè®®æ ˆæ„å»ºï¼Œæä¾›éŸ³é¢‘æµä¼ è¾“ã€GATTæœåŠ¡ã€è®¾å¤‡ç®¡ç†ç­‰åŠŸèƒ½ã€‚è¯¥æ¨¡å—ä¸ä»…æ”¯æŒé«˜è´¨é‡éŸ³é¢‘ä¼ è¾“ï¼Œè¿˜æä¾›äº†ä¸°å¯Œçš„ä¼ æ„Ÿå™¨æ•°æ®ä¼ è¾“å’Œè®¾å¤‡æ§åˆ¶æ¥å£ã€‚ ## æ–‡ä»¶ç»“æ„ ``` src/bluetooth/ â”œâ”€â”€ bt_management/ # è“ç‰™è¿æ¥ç®¡ç† â”œâ”€â”€ bt_stream/ # è“ç‰™éŸ³é¢‘æµå¤„ç† â”œâ”€â”€ bt_content_control/ # å†…å®¹æ§åˆ¶ â”œâ”€â”€ bt_rendering_and_capture/ # éŸ³é¢‘æ¸²æŸ“å’Œæ•è· â”œâ”€â”€ gatt_services/ # GATTæœåŠ¡å®ç° â”‚ â”œâ”€â”€ device_info.h/.c # è®¾å¤‡ä¿¡æ¯æœåŠ¡ â”‚ â”œâ”€â”€ battery_service.h/.cpp # ç”µæ± æœåŠ¡ â”‚ â”œâ”€â”€ sensor_service.h/.c # ä¼ æ„Ÿå™¨æœåŠ¡ â”‚ â”œâ”€â”€ led_service.h/.cpp # LEDæ§åˆ¶æœåŠ¡ â”‚ â”œâ”€â”€ button_service.h/.c # æŒ‰é”®æœåŠ¡ â”‚ â””â”€â”€ audio_config_service.h/.c # éŸ³é¢‘é…ç½®æœåŠ¡ â”œâ”€â”€ CMakeLists.txt # æ„å»ºé…ç½® â”œâ”€â”€ Kconfig # é…ç½®é€‰é¡¹ â””â”€â”€ Kconfig.defaults # é»˜è®¤é…ç½® ``` ## æ ¸å¿ƒæ¶æ„ ### 1. GATTæœåŠ¡æ¶æ„ OpenEarable 2.0å®ç°äº†å¤šä¸ªè‡ªå®šä¹‰GATTæœåŠ¡ï¼Œä¸ºå®¢æˆ·ç«¯æä¾›å®Œæ•´çš„è®¾å¤‡æ§åˆ¶å’Œæ•°æ®è®¿é—®æ¥å£ã€‚ #### æœåŠ¡æ¦‚è§ˆ æœåŠ¡åç§° åŠŸèƒ½æè¿° ä¸»è¦ç‰¹å¾ Device Info è®¾å¤‡ä¿¡æ¯æŸ¥è¯¢ åˆ¶é€ å•†ã€å‹å·ã€å›ºä»¶ç‰ˆæœ¬ç­‰ Battery Service ç”µæ± çŠ¶æ€ç›‘æ§ ç”µé‡ã€å……ç”µçŠ¶æ€ã€å¥åº·çŠ¶æ€ Sensor Service ä¼ æ„Ÿå™¨æ•°æ®ä¼ è¾“ é…ç½®ã€æ•°æ®æµã€å½•åˆ¶æ§åˆ¶ LED Service LEDçŠ¶æ€æ§åˆ¶ é¢œè‰²ã€æ¨¡å¼ã€äº®åº¦æ§åˆ¶ Button Service æŒ‰é”®äº‹ä»¶é€šçŸ¥ æŒ‰é”®çŠ¶æ€ã€äº‹ä»¶é€šçŸ¥ Audio Config éŸ³é¢‘å‚æ•°é…ç½® é‡‡æ ·ç‡ã€ç¼–è§£ç å™¨è®¾ç½® ### 2. ä¼ æ„Ÿå™¨æœåŠ¡è¯¦è§£ ä¼ æ„Ÿå™¨æœåŠ¡æ˜¯OpenEarableçš„æ ¸å¿ƒåˆ›æ–°æœåŠ¡ï¼Œæä¾›å®Œæ•´çš„ä¼ æ„Ÿå™¨æ•°æ®è®¿é—®å’Œæ§åˆ¶æ¥å£ã€‚ #### UUIDå®šä¹‰ ```cpp // ä¼ æ„Ÿå™¨æœåŠ¡UUID #define BT_UUID_SENSOR_VAL \\ BT_UUID_128_ENCODE(0x34c2e3bb, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) // ä¼ æ„Ÿå™¨é…ç½®ç‰¹å¾UUID #define BT_UUID_SENSOR_CONFIG_VAL \\ BT_UUID_128_ENCODE(0x34c2e3be, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) // ä¼ æ„Ÿå™¨æ•°æ®ç‰¹å¾UUID #define BT_UUID_SENSOR_DATA_VAL \\ BT_UUID_128_ENCODE(0x34c2e3bc, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) // é…ç½®çŠ¶æ€ç‰¹å¾UUID #define BT_UUID_SENSOR_CONFIG_STATUS_VAL \\ BT_UUID_128_ENCODE(0x34c2e3bf, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) // å½•åˆ¶åç§°ç‰¹å¾UUID #define BT_UUID_SENSOR_RECORDING_NAME_VAL \\ BT_UUID_128_ENCODE(0x34c2e3c0, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) ``` #### æœåŠ¡æ¥å£ ```cpp // ä¼ æ„Ÿå™¨æœåŠ¡åˆå§‹åŒ– int init_sensor_service(); // ä¼ æ„Ÿå™¨é…ç½®çŠ¶æ€è®¾ç½® int set_sensor_config_status(struct sensor_config config); // è·å–å½•åˆ¶åç§° const char *get_sensor_recording_name(); ``` #### ä¼ æ„Ÿå™¨é…ç½®åè®® ```cpp // ä¼ æ„Ÿå™¨é…ç½®ç»“æ„ struct sensor_config { uint8_t sensorId; // ä¼ æ„Ÿå™¨ID uint8_t sampleRateIndex; // é‡‡æ ·ç‡ç´¢å¼• uint8_t storageOptions; // å­˜å‚¨é€‰é¡¹ä½å›¾ } __attribute__((packed)); // å­˜å‚¨é€‰é¡¹ä½å›¾å®šä¹‰ #define STORAGE_SD_CARD (1 << 0) // SDå¡å­˜å‚¨ #define STORAGE_BLE_STREAM (1 << 1) // è“ç‰™æµä¼ è¾“ #define STORAGE_FLASH (1 << 2) // å†…éƒ¨Flashå­˜å‚¨ ``` ### 3. ç”µæ± æœåŠ¡è¯¦è§£ ç”µæ± æœåŠ¡æä¾›å®Œæ•´çš„ç”µæºçŠ¶æ€ä¿¡æ¯ï¼Œæ”¯æŒæ ‡å‡†GATTç”µæ± æœåŠ¡æ‰©å±•ã€‚ #### ç”µæ± çŠ¶æ€ç»“æ„ ```cpp // ç”µæ± ç”µé‡çŠ¶æ€ struct battery_level_status { uint8_t flags; // çŠ¶æ€æ ‡å¿— uint16_t power_state; // ç”µæºçŠ¶æ€ } __attribute__((packed)); // ç”µæ± èƒ½é‡çŠ¶æ€ struct battery_energy_status { uint8_t flags; // çŠ¶æ€æ ‡å¿— struct sfloat voltage; // ç”µå‹(V) struct sfloat available_capacity; // å¯ç”¨å®¹é‡(mAh) struct sfloat charge_rate; // å……ç”µé€Ÿç‡(mA) } __attribute__((packed)); // ç”µæ± å¥åº·çŠ¶æ€ struct battery_health_status { uint8_t flags; // çŠ¶æ€æ ‡å¿— uint8_t battery_health_summary; // å¥åº·çŠ¶æ€æ‘˜è¦ uint16_t cycle_count; // å¾ªç¯æ¬¡æ•° int8_t current_temperature; // å½“å‰æ¸©åº¦(Â°C) } __attribute__((packed)); ``` #### æœåŠ¡æ¥å£ ```cpp // ç”µæ± æœåŠ¡åˆå§‹åŒ– int init_battery_service(); // å‘é€ç”µæ± ç”µé‡æ•°æ® int bt_send_battery_level(struct battery_data *data); ``` ### 4. LEDæœåŠ¡è¯¦è§£ LEDæœåŠ¡æä¾›LEDçŠ¶æ€çš„å®Œæ•´æ§åˆ¶æ¥å£ï¼Œæ”¯æŒé¢œè‰²ã€äº®åº¦ã€æ¨¡å¼æ§åˆ¶ã€‚ #### LEDæ§åˆ¶ç»“æ„ ```cpp // RGBé¢œè‰²å®šä¹‰ typedef uint8_t RGBColor[3]; // LEDæ¨¡å¼æšä¸¾ enum led_mode { STATE_INDICATION, // çŠ¶æ€æŒ‡ç¤ºæ¨¡å¼ CUSTOM, // è‡ªå®šä¹‰æ¨¡å¼ }; // LEDé…ç½®ç»“æ„ struct led_config { enum led_mode mode; // LEDæ¨¡å¼ RGBColor color; // RGBé¢œè‰² uint8_t brightness; // äº®åº¦(0 255) uint16_t pattern; // é—ªçƒæ¨¡å¼ } __attribute__((packed)); ``` ### 5. æŒ‰é”®æœåŠ¡è¯¦è§£ æŒ‰é”®æœåŠ¡æä¾›æŒ‰é”®äº‹ä»¶çš„å®æ—¶é€šçŸ¥åŠŸèƒ½ã€‚ #### æŒ‰é”®äº‹ä»¶ç»“æ„ ```cpp // æŒ‰é”®çŠ¶æ€ç»“æ„ struct button_event { uint8_t button_id; // æŒ‰é”®ID uint8_t event_type; // äº‹ä»¶ç±»å‹ uint32_t timestamp; // æ—¶é—´æˆ³ } __attribute__((packed)); // äº‹ä»¶ç±»å‹å®šä¹‰ enum button_event_type { BUTTON_PRESS, // æŒ‰é”®æŒ‰ä¸‹ BUTTON_RELEASE, // æŒ‰é”®é‡Šæ”¾ BUTTON_LONG_PRESS, // é•¿æŒ‰ BUTTON_DOUBLE_CLICK, // åŒå‡» }; ``` ## LE Audio éŸ³é¢‘æµå¤„ç† ### éŸ³é¢‘æµæ¶æ„ OpenEarableåŸºäºNordicçš„nRF5340 Audioåº”ç”¨ï¼Œæ”¯æŒå®Œæ•´çš„LE Audioåè®®æ ˆã€‚ #### éŸ³é¢‘æµç±»å‹ ```cpp // éŸ³é¢‘æµç±»å‹ enum audio_stream_type { STREAM_TYPE_CIS, // Connected Isochronous Stream (å•æ’­) STREAM_TYPE_BIS, // Broadcast Isochronous Stream (å¹¿æ’­) }; // éŸ³é¢‘é…ç½®å‚æ•° struct audio_config { uint32_t sample_rate_hz; // é‡‡æ ·ç‡ uint8_t channels; // å£°é“æ•° uint16_t frame_duration_us; // å¸§é•¿åº¦ uint8_t codec_type; // ç¼–è§£ç å™¨ç±»å‹ uint32_t bitrate_bps; // æ¯”ç‰¹ç‡ }; ``` #### ç¼–è§£ç å™¨æ”¯æŒ ```cpp // æ”¯æŒçš„ç¼–è§£ç å™¨ enum audio_codec { CODEC_LC3, // LC3 (LE Audioæ ‡å‡†) CODEC_SBC, // SBC (ç»å…¸è“ç‰™) CODEC_PCM, // æœªå‹ç¼©PCM }; // LC3ç¼–è§£ç å™¨é…ç½® struct lc3_config { uint32_t sample_rate; // é‡‡æ ·ç‡ (8000, 16000, 24000, 32000, 48000) uint16_t frame_duration; // å¸§é•¿åº¦ (7.5ms, 10ms) uint8_t channels; // å£°é“æ•° (1, 2) uint32_t bitrate; // æ¯”ç‰¹ç‡ (16000 320000 bps) }; ``` ## è¿æ¥ç®¡ç† ### é…å¯¹å’Œç»‘å®š ```cpp // é…å¯¹çŠ¶æ€ç®¡ç† enum pairing_state { SET_PAIRING, // è®¾ç½®é…å¯¹æ¨¡å¼ BONDING, // æ­£åœ¨ç»‘å®š PAIRED, // å·²é…å¯¹ CONNECTED, // å·²è¿æ¥ }; // è¿æ¥å‚æ•° struct connection_params { uint16_t interval_min; // æœ€å°è¿æ¥é—´éš” uint16_t interval_max; // æœ€å¤§è¿æ¥é—´éš” uint16_t latency; // ä»è®¾å¤‡å»¶è¿Ÿ uint16_t timeout; // è¶…æ—¶æ—¶é—´ }; ``` ### å®‰å…¨ç®¡ç† ```cpp // å®‰å…¨å‚æ•° struct security_params { uint8_t auth_req; // è®¤è¯è¦æ±‚ uint8_t oob_flag; // OOBæ•°æ®æ ‡å¿— uint8_t min_key_size; // æœ€å°å¯†é’¥é•¿åº¦ uint8_t max_key_size; // æœ€å¤§å¯†é’¥é•¿åº¦ uint8_t init_key_dist; // åˆå§‹å¯†é’¥åˆ†å‘ uint8_t resp_key_dist; // å“åº”å¯†é’¥åˆ†å‘ }; // SIRK (Set Identity Resolving Key) ç®¡ç† uint32_t uicr_sirk_get(void); // è·å–SIRK int uicr_sirk_set(uint32_t sirk); // è®¾ç½®SIRK ``` ## æ•°æ®ä¼ è¾“ä¼˜åŒ– ### æ•°æ®åˆ†åŒ…ä¼ è¾“ ```cpp // å¤§æ•°æ®åŒ…åˆ†åŒ…ä¼ è¾“ struct data_packet { uint8_t packet_id; // åŒ…ID uint8_t total_packets; // æ€»åŒ…æ•° uint8_t sequence; // åºåˆ—å· uint16_t data_size; // æ•°æ®å¤§å° uint8_t data[]; // æ•°æ®è½½è· } __attribute__((packed)); // åˆ†åŒ…ä¼ è¾“æ§åˆ¶ int send_large_data(const uint8_t *data, size_t size, uint16_t mtu_size); ``` ### æµé‡æ§åˆ¶ ```cpp // æµé‡æ§åˆ¶å‚æ•° struct flow_control { uint16_t window_size; // çª—å£å¤§å° uint16_t credit_count; // ä¿¡ç”¨è®¡æ•° bool flow_enabled; // æµæ§ä½¿èƒ½ }; // è‡ªé€‚åº”æµæ§ void adaptive_flow_control(uint16_t buffer_level) { if (buffer_level > HIGH_THRESHOLD) { // ç¼“å†²åŒºæ»¡ï¼Œå‡å°‘å‘é€é€Ÿç‡ reduce_transmission_rate(); } else if (buffer_level < LOW_THRESHOLD) { // ç¼“å†²åŒºç©ºï¼Œå¢åŠ å‘é€é€Ÿç‡ increase_transmission_rate(); } } ``` ## åŠŸè€—ä¼˜åŒ– ### è¿æ¥é—´éš”ä¼˜åŒ– ```cpp // åŠ¨æ€è¿æ¥é—´éš”è°ƒæ•´ void optimize_connection_interval() { if (high_data_rate_required()) { // é«˜æ•°æ®ä¼ è¾“éœ€æ±‚ï¼Œä½¿ç”¨çŸ­è¿æ¥é—´éš” set_connection_interval(7.5); // 7.5ms } else { // ä½åŠŸè€—éœ€æ±‚ï¼Œä½¿ç”¨é•¿è¿æ¥é—´éš” set_connection_interval(100); // 100ms } } ``` ### å¹¿å‘ŠåŠŸè€—ç®¡ç† ```cpp // å¹¿å‘Šå‚æ•°ä¼˜åŒ– struct adv_params { uint16_t interval_min; // æœ€å°å¹¿å‘Šé—´éš” uint16_t interval_max; // æœ€å¤§å¹¿å‘Šé—´éš” uint8_t type; // å¹¿å‘Šç±»å‹ uint8_t tx_power; // å‘å°„åŠŸç‡ }; // è‡ªé€‚åº”å¹¿å‘Š void adaptive_advertising() { if (battery_low()) { // ä½ç”µé‡æ—¶å‡å°‘å¹¿å‘Šé¢‘ç‡ set_adv_interval(1000); // 1ç§’ set_tx_power( 20); // é™ä½å‘å°„åŠŸç‡ } else { // æ­£å¸¸ç”µé‡æ—¶æ­£å¸¸å¹¿å‘Š set_adv_interval(100); // 100ms set_tx_power(0); // æ ‡å‡†å‘å°„åŠŸç‡ } } ``` ## é”™è¯¯å¤„ç†å’Œæ¢å¤ ### è¿æ¥é”™è¯¯å¤„ç† ```cpp // è¿æ¥é”™è¯¯ç±»å‹ enum connection_error { CONN_ERR_TIMEOUT, // è¿æ¥è¶…æ—¶ CONN_ERR_AUTH_FAILED, // è®¤è¯å¤±è´¥ CONN_ERR_PARAM_INVALID, // å‚æ•°æ— æ•ˆ CONN_ERR_RESOURCES, // èµ„æºä¸è¶³ }; // é”™è¯¯æ¢å¤ç­–ç•¥ void handle_connection_error(enum connection_error error) { switch (error) { case CONN_ERR_TIMEOUT: // è¶…æ—¶é”™è¯¯ï¼Œé‡æ–°å°è¯•è¿æ¥ restart_connection(); break; case CONN_ERR_AUTH_FAILED: // è®¤è¯å¤±è´¥ï¼Œæ¸…é™¤é…å¯¹ä¿¡æ¯ clear_bonding_info(); start_pairing_mode(); break; case CONN_ERR_PARAM_INVALID: // å‚æ•°é”™è¯¯ï¼Œä½¿ç”¨é»˜è®¤å‚æ•° reset_to_default_params(); break; default: // é€šç”¨é”™è¯¯ï¼Œé‡å¯è“ç‰™æ ˆ restart_bluetooth_stack(); break; } } ``` ### éŸ³é¢‘æµé”™è¯¯å¤„ç† ```cpp // éŸ³é¢‘æµé”™è¯¯å¤„ç† void handle_audio_stream_error(int error_code) { if (error_code AUDIO_UNDERRUN) { // éŸ³é¢‘ç¼“å†²åŒºä¸‹æº¢ increase_buffer_size(); adjust_presentation_delay(); } else if (error_code AUDIO_SYNC_LOST) { // éŸ³é¢‘åŒæ­¥ä¸¢å¤± reinitialize_audio_sync(); } } ``` ## é…ç½®é€‰é¡¹ ### Kconfigé…ç½® ```kconfig # è“ç‰™åŸºç¡€é…ç½® CONFIG_BT y CONFIG_BT_PERIPHERAL y CONFIG_BT_CENTRAL y CONFIG_BT_GATT_CLIENT y # LE Audioé…ç½® CONFIG_BT_AUDIO y CONFIG_BT_BAP_UNICAST_SERVER y CONFIG_BT_BAP_BROADCAST_SINK y CONFIG_LC3_CODEC y # GATTæœåŠ¡é…ç½® CONFIG_BT_GATT_DYNAMIC_DB y CONFIG_BT_GATT_SERVICE_CHANGED y # å®‰å…¨é…ç½® CONFIG_BT_SMP y CONFIG_BT_PRIVACY y CONFIG_BT_RPA y # éŸ³é¢‘é…ç½® CONFIG_AUDIO_SAMPLE_RATE_48000 y CONFIG_AUDIO_FRAME_DURATION_10MS y CONFIG_LC3_BITRATE_96000 y ``` ### æœåŠ¡é…ç½® ```cpp // GATTæœåŠ¡é…ç½® #define MAX_SENSOR_DATA_SIZE 256 #define MAX_RECORDING_NAME_LEN 32 #define BATTERY_UPDATE_INTERVAL K_SECONDS(30) #define SENSOR_DATA_INTERVAL K_MSEC(100) // è¿æ¥é…ç½® #define MIN_CONN_INTERVAL 6 // 7.5ms #define MAX_CONN_INTERVAL 80 // 100ms #define SLAVE_LATENCY 0 #define CONN_SUP_TIMEOUT 400 // 4s ``` ## æ€§èƒ½ç›‘æ§ ### è¿æ¥è´¨é‡ç›‘æ§ ```cpp // è¿æ¥è´¨é‡ç»Ÿè®¡ struct connection_stats { uint32_t packets_sent; // å‘é€åŒ…æ•° uint32_t packets_received; // æ¥æ”¶åŒ…æ•° uint32_t packets_lost; // ä¸¢åŒ…æ•° float rssi_average; // å¹³å‡RSSI uint16_t connection_interval; // è¿æ¥é—´éš” uint16_t slave_latency; // ä»è®¾å¤‡å»¶è¿Ÿ }; // è´¨é‡ç›‘æ§ void monitor_connection_quality() { struct connection_stats stats; get_connection_stats(&stats); // è®¡ç®—ä¸¢åŒ…ç‡ float packet_loss_rate (float)stats.packets_lost / (stats.packets_sent + stats.packets_lost); // ä¿¡å·è´¨é‡è¯„ä¼° if (stats.rssi_average < 80 packet_loss_rate > 0.05) { LOG_WRN(\"Poor connection quality detected\"); optimize_connection_params(); } } ``` ## æ€»ç»“ è“ç‰™é€šä¿¡æ¨¡å—æ˜¯OpenEarable 2.0çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š 1. **å®Œæ•´çš„LE Audioæ”¯æŒ**: åŸºäºæœ€æ–°çš„LE Audioæ ‡å‡†ï¼Œæ”¯æŒé«˜è´¨é‡éŸ³é¢‘ä¼ è¾“ 2. **ä¸°å¯Œçš„GATTæœåŠ¡**: æä¾›ä¼ æ„Ÿå™¨ã€ç”µæ± ã€LEDã€æŒ‰é”®ç­‰å®Œæ•´çš„è®¾å¤‡æ§åˆ¶æ¥å£ 3. **é«˜æ•ˆæ•°æ®ä¼ è¾“**: ä¼˜åŒ–çš„æ•°æ®åˆ†åŒ…å’Œæµé‡æ§åˆ¶æœºåˆ¶ 4. **æ™ºèƒ½åŠŸè€—ç®¡ç†**: è‡ªé€‚åº”çš„è¿æ¥å‚æ•°å’Œå¹¿å‘Šç­–ç•¥ 5. **å¯é çš„é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯æ£€æµ‹å’Œæ¢å¤æœºåˆ¶ 6. **å®‰å…¨é€šä¿¡**: æ”¯æŒé…å¯¹ã€ç»‘å®šå’ŒåŠ å¯†é€šä¿¡ 7. **æ€§èƒ½ç›‘æ§**: å®æ—¶çš„è¿æ¥è´¨é‡ç›‘æ§å’Œä¼˜åŒ– è¯¥æ¨¡å—ä¸ºOpenEarable 2.0æä¾›äº†ç¨³å®šå¯é çš„æ— çº¿é€šä¿¡èƒ½åŠ›ï¼Œæ”¯æŒé«˜è´¨é‡éŸ³é¢‘æ’­æ”¾ã€ä¸°å¯Œçš„ä¼ æ„Ÿå™¨æ•°æ®ä¼ è¾“å’Œå®Œæ•´çš„è®¾å¤‡æ§åˆ¶åŠŸèƒ½ã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/buttons-module.html":{"title":"OpenEarable 2.0 - æŒ‰é”®æ¨¡å— (Buttons Module)","content":"# OpenEarable 2.0 æŒ‰é”®æ¨¡å— (Buttons Module) ## æ¦‚è¿° æŒ‰é”®æ¨¡å—è´Ÿè´£å¤„ç†OpenEarableè®¾å¤‡ä¸Šçš„ç‰©ç†æŒ‰é”®è¾“å…¥ï¼ŒåŒ…æ‹¬æŒ‰é”®äº‹ä»¶æ£€æµ‹ã€é˜²æŠ–å¤„ç†ã€çŠ¶æ€ç®¡ç†å’Œäº‹ä»¶åˆ†å‘ã€‚è¯¥æ¨¡å—ä¸ºç”¨æˆ·æä¾›äº¤äº’æ¥å£ï¼Œæ”¯æŒæ’­æ”¾/æš‚åœã€éŸ³é‡æ§åˆ¶ç­‰åŠŸèƒ½ã€‚ ## æ ¸å¿ƒç»„ä»¶ ### 1. Button ç±» (`Button.h/cpp`) ä¸»è¦çš„æŒ‰é”®æŠ½è±¡ç±»ï¼Œå¤„ç†å•ä¸ªæŒ‰é”®çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸï¼š #### æ ¸å¿ƒæ¥å£ ```cpp class Button { public: Button(gpio_dt_spec spec); void begin(); // åˆå§‹åŒ–æŒ‰é”® void end(); // æ¸…ç†æŒ‰é”®èµ„æº button_action getState() const; // è·å–å½“å‰çŠ¶æ€ private: k_work_delayable button_work; // å»¶æ—¶å·¥ä½œé˜Ÿåˆ— const struct gpio_dt_spec button; // GPIOè§„æ ¼ static struct gpio_callback button_cb_data; // ä¸­æ–­å›è°ƒæ•°æ® button_action _buttonState; // å½“å‰çŠ¶æ€ button_action _temp_buttonState; // ä¸´æ—¶çŠ¶æ€ static void button_isr(const struct device *dev, struct gpio_callback *cb, uint32_t pins); int update_state(); static void button_work_handler(struct k_work * work); }; ``` #### çŠ¶æ€ç®¡ç† **BUTTON_RELEASED**: æŒ‰é”®é‡Šæ”¾çŠ¶æ€ **BUTTON_PRESS**: æŒ‰é”®æŒ‰ä¸‹çŠ¶æ€ ä½¿ç”¨é˜²æŠ–æœºåˆ¶é¿å…è¯¯è§¦å‘ #### é˜²æŠ–æœºåˆ¶ ```cpp #define BUTTON_DEBOUNCE K_MSEC(10) // 10msé˜²æŠ–å»¶æ—¶ ``` ä¸­æ–­è§¦å‘æ—¶å¯åŠ¨å»¶æ—¶å·¥ä½œ å»¶æ—¶ç»“æŸåç¡®è®¤çŠ¶æ€å˜åŒ– çŠ¶æ€æœªå˜åŒ–æ—¶å–æ¶ˆå»¶æ—¶å·¥ä½œ ### 2. æŒ‰é”®ç®¡ç†å™¨ (`button_manager.h/c`) è´Ÿè´£æŒ‰é”®äº‹ä»¶çš„æ¶ˆæ¯é˜Ÿåˆ—ç®¡ç†å’Œäº‹ä»¶åˆ†å‘ï¼š #### æ¶ˆæ¯é˜Ÿåˆ— ```c K_MSGQ_DEFINE(button_queue, sizeof(struct button_msg), 1, 4); ``` #### ZBus é€šé“ ```c ZBUS_CHAN_DEFINE(button_chan, struct button_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY, ZBUS_MSG_INIT(0)); ``` #### å‘å¸ƒçº¿ç¨‹ ```c void button_pub_task() { int ret; struct button_msg msg; while (1) { k_msgq_get(&button_queue, &msg, K_FOREVER); ret zbus_chan_pub(&button_chan, &msg, K_FOREVER); if (ret) { LOG_ERR(\"Failed to publish button msg, ret: %d\", ret); } } } K_THREAD_DEFINE(button_publish, CONFIG_BUTTON_PUBLISH_STACK_SIZE, button_pub_task, NULL, NULL, NULL, K_PRIO_PREEMPT(CONFIG_BUTTON_PUBLISH_THREAD_PRIO), 0, 0); ``` ### 3. æŒ‰é”®åˆ†é… (`button_assignments.h`) å®šä¹‰æŒ‰é”®æ˜ å°„å’Œæšä¸¾ï¼š ```cpp enum button_pin_names { BUTTON_EARABLE DT_GPIO_PIN(DT_ALIAS(sw0), gpios), BUTTON_VOLUME_UP, // é¢„ç•™ BUTTON_VOLUME_DOWN, // é¢„ç•™ BUTTON_4, // é¢„ç•™ BUTTON_5, // é¢„ç•™ }; #define BUTTON_PLAY_PAUSE BUTTON_EARABLE // åˆ«åå®šä¹‰ ``` ### 4. æŒ‰é”®çŠ¶æ€æŸ¥è¯¢ (`button_pressed.cpp`) æä¾›æŒ‰é”®çŠ¶æ€æŸ¥è¯¢æ¥å£ï¼š ```cpp int button_pressed(enum button_pin_names pin, bool * pressed) { switch (pin) { case BUTTON_EARABLE: *pressed (earable_btn.getState() BUTTON_PRESS); return 0; default: *pressed false; return 0; } } ``` ## å·¥ä½œæµç¨‹ ### 1. åˆå§‹åŒ–æµç¨‹ ``` Buttonæ„é€  â†’ GPIOé…ç½® â†’ ä¸­æ–­é…ç½® â†’ å›è°ƒæ³¨å†Œ â†’ åˆå§‹çŠ¶æ€è¯»å– ``` ### 2. æŒ‰é”®äº‹ä»¶å¤„ç†æµç¨‹ ``` GPIOä¸­æ–­è§¦å‘ â†’ button_isr() â†’ å¯åŠ¨å»¶æ—¶å·¥ä½œ â†’ button_work_handler() â†’ update_state() â†’ æ¶ˆæ¯å…¥é˜Ÿ â†’ button_pub_task() â†’ ZBuså‘å¸ƒ ``` ### 3. é˜²æŠ–å¤„ç† ``` ä¸­æ–­è§¦å‘ â†’ è¯»å–ä¸´æ—¶çŠ¶æ€ â†’ å¦‚æœçŠ¶æ€ç›¸åŒ â†’ å–æ¶ˆå»¶æ—¶å·¥ä½œ å¦‚æœçŠ¶æ€ä¸åŒ â†’ é‡æ–°è°ƒåº¦å»¶æ—¶å·¥ä½œ â†’ å»¶æ—¶åç¡®è®¤çŠ¶æ€å˜åŒ– ``` ## ç¡¬ä»¶æ¥å£ ### GPIO é…ç½® ä½¿ç”¨è®¾å¤‡æ ‘åˆ«å `sw0` å®šä¹‰ä¸»æŒ‰é”® é…ç½®ä¸ºè¾“å…¥æ¨¡å¼ (`GPIO_INPUT`) å¯ç”¨åŒè¾¹æ²¿ä¸­æ–­ (`GPIO_INT_EDGE_BOTH`) ### ä¸­æ–­å¤„ç† å…±äº«ä¸­æ–­å›è°ƒå‡½æ•° `button_isr` æ”¯æŒå¤šæŒ‰é”®æ‰©å±•ï¼ˆå½“å‰ä»…å®ç°ä¸»æŒ‰é”®ï¼‰ ä¸­æ–­å®‰å…¨çš„çŠ¶æ€æ›´æ–° ## é…ç½®é€‰é¡¹ ### Kconfig é…ç½® ``` CONFIG_BUTTON_PUBLISH_STACK_SIZE # å‘å¸ƒçº¿ç¨‹æ ˆå¤§å° CONFIG_BUTTON_PUBLISH_THREAD_PRIO # å‘å¸ƒçº¿ç¨‹ä¼˜å…ˆçº§ CONFIG_MODULE_BUTTON_HANDLER_LOG_LEVEL # æ—¥å¿—çº§åˆ« ``` ### è®¾å¤‡æ ‘é…ç½® ```dts aliases { sw0 &button0; // ä¸»æŒ‰é”®åˆ«å }; ``` ## æ‰©å±•æ€§è®¾è®¡ ### å¤šæŒ‰é”®æ”¯æŒ ä»£ç ä¸­é¢„ç•™äº†å¤šä¸ªæŒ‰é”®çš„å®ç°æ¡†æ¶ å¯é€šè¿‡å–æ¶ˆæ³¨é‡Šè½»æ¾æ·»åŠ éŸ³é‡æŒ‰é”®ç­‰ æ”¯æŒä¸åŒæŒ‰é”®çš„ç‹¬ç«‹å¤„ç† ### æŒ‰é”®åŠŸèƒ½æ˜ å°„ é€šè¿‡ `button_assignments.h` é›†ä¸­ç®¡ç†æŒ‰é”®åŠŸèƒ½ æ”¯æŒåˆ«åå®šä¹‰ï¼Œä¾¿äºåŠŸèƒ½é‡æ˜ å°„ å¯æ‰©å±•å¤æ‚æŒ‰é”®ç»„åˆåŠŸèƒ½ ## é›†æˆæ¥å£ ### ZBus æ¶ˆæ¯ ```cpp struct button_msg { uint32_t button_pin; // æŒ‰é”®å¼•è„š button_action button_action; // æŒ‰é”®åŠ¨ä½œ }; ``` ### è®¢é˜…è€…æ¥å£ å…¶ä»–æ¨¡å—å¯é€šè¿‡ZBusè®¢é˜…æŒ‰é”®äº‹ä»¶ï¼š ```c ZBUS_SUBSCRIBER_DEFINE(button_sub, 1); ZBUS_CHAN_ADD_OBS(button_chan, button_sub, 0); ``` ## æ—¥å¿—å’Œè°ƒè¯• ### æ—¥å¿—æ¨¡å— ```c LOG_MODULE_REGISTER(button, CONFIG_MODULE_BUTTON_HANDLER_LOG_LEVEL); ``` ### å…³é”®æ—¥å¿—ç‚¹ æŒ‰é”®çŠ¶æ€å˜åŒ–è®°å½• æ¶ˆæ¯é˜Ÿåˆ—æ»¡è­¦å‘Š GPIOé…ç½®é”™è¯¯ ä¸­æ–­é…ç½®å¤±è´¥ ## åŠŸè€—ä¼˜åŒ– ### ä¸­æ–­é©±åŠ¨ ä½¿ç”¨GPIOä¸­æ–­è€Œéè½®è¯¢ æŒ‰é”®ç©ºé—²æ—¶é›¶åŠŸè€— ä¸­æ–­å”¤é†’ç³»ç»Ÿ ### å·¥ä½œé˜Ÿåˆ—ä¼˜åŒ– ä½¿ç”¨å»¶æ—¶å·¥ä½œé˜Ÿåˆ—è¿›è¡Œé˜²æŠ– é¿å…æŒç»­CPUå ç”¨ é€‚å½“çš„çº¿ç¨‹ä¼˜å…ˆçº§é…ç½® ## é”™è¯¯å¤„ç† ### GPIO é”™è¯¯ è®¾å¤‡å°±ç»ªæ£€æŸ¥ å¼•è„šé…ç½®å¤±è´¥å¤„ç† ä¸­æ–­é…ç½®é”™è¯¯å¤„ç† ### æ¶ˆæ¯é˜Ÿåˆ—é”™è¯¯ é˜Ÿåˆ—æ»¡æ—¶çš„è­¦å‘Šæ—¥å¿— å‘å¸ƒå¤±è´¥çš„é”™è¯¯å¤„ç† èµ„æºç«äº‰ä¿æŠ¤ ## å…¸å‹ä½¿ç”¨åœºæ™¯ ### 1. æ’­æ”¾/æš‚åœæ§åˆ¶ ```cpp // åœ¨éŸ³é¢‘æ¨¡å—ä¸­è®¢é˜…æŒ‰é”®äº‹ä»¶ void audio_button_handler(const struct zbus_channel *chan) { struct button_msg msg; zbus_chan_read(chan, &msg, K_FOREVER); if (msg.button_pin BUTTON_EARABLE && msg.button_action BUTTON_PRESS) { // æ‰§è¡Œæ’­æ”¾/æš‚åœé€»è¾‘ toggle_playback(); } } ``` ### 2. ç³»ç»ŸçŠ¶æ€åˆ‡æ¢ ```cpp // åœ¨çŠ¶æ€ç®¡ç†æ¨¡å—ä¸­å¤„ç†æŒ‰é”® void state_button_handler(const struct zbus_channel *chan) { struct button_msg msg; zbus_chan_read(chan, &msg, K_FOREVER); if (msg.button_pin BUTTON_EARABLE && msg.button_action BUTTON_PRESS) { // çŠ¶æ€åˆ‡æ¢æˆ–åŠŸèƒ½æ¿€æ´» switch_system_state(); } } ``` ## æ€»ç»“ æŒ‰é”®æ¨¡å—æä¾›äº†å®Œæ•´çš„ç‰©ç†æŒ‰é”®äº¤äº’æ”¯æŒï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š 1. **å¯é æ€§**: ç¡¬ä»¶é˜²æŠ–å’Œè½¯ä»¶çŠ¶æ€ç¡®è®¤ 2. **æ‰©å±•æ€§**: æ”¯æŒå¤šæŒ‰é”®å’Œå¤æ‚åŠŸèƒ½æ˜ å°„ 3. **é«˜æ•ˆæ€§**: ä¸­æ–­é©±åŠ¨å’Œäº‹ä»¶å‘å¸ƒæœºåˆ¶ 4. **é›†æˆæ€§**: é€šè¿‡ZBusä¸å…¶ä»–æ¨¡å—æ— ç¼é›†æˆ 5. **ä½åŠŸè€—**: ä¸­æ–­å”¤é†’å’Œé€‚å½“çš„çº¿ç¨‹è°ƒåº¦ è¯¥æ¨¡å—ä¸ºOpenEarableè®¾å¤‡çš„ç”¨æˆ·äº¤äº’æä¾›äº†ç¨³å®šå¯é çš„åŸºç¡€è®¾æ–½ã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/deployment.html":{"title":"éƒ¨ç½²æŒ‡å—","content":"# éƒ¨ç½²æŒ‡å— ## æ¦‚è¿° æœ¬æŒ‡å—ä»‹ç»å¦‚ä½•å°† OpenEarable 2.0 æ–‡æ¡£ç½‘ç«™éƒ¨ç½²åˆ°å„ç§å¹³å°ï¼ŒåŒ…æ‹¬ GitHub Pagesã€Netlifyã€Vercel ç­‰ã€‚ ## æ„å»ºç”Ÿäº§ç‰ˆæœ¬ åœ¨éƒ¨ç½²ä¹‹å‰ï¼Œéœ€è¦æ„å»ºç”Ÿäº§ç‰ˆæœ¬çš„æ–‡æ¡£ï¼š ```bash # è¿›å…¥é¡¹ç›®ç›®å½• cd my_site # æ„å»ºæ–‡æ¡£ teedoc build # æ„å»ºå®Œæˆåï¼Œé™æ€æ–‡ä»¶ä½äº out/ ç›®å½• ``` ## GitHub Pages éƒ¨ç½² ### æ–¹æ³•ä¸€ï¼šGitHub Actions è‡ªåŠ¨éƒ¨ç½² 1. **åˆ›å»º GitHub Actions å·¥ä½œæµ** åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º `.github/workflows/deploy.yml`ï¼š ```yaml name: Deploy to GitHub Pages on: push: branches: [ main ] pull_request: branches: [ main ] jobs: build and deploy: runs on: ubuntu latest steps: uses: actions/checkout@v3 name: Setup Python uses: actions/setup python@v4 with: python version: '3.9' name: Install dependencies run: cd docs pip install r requirements.txt name: Build documentation run: cd docs/my_site teedoc build name: Deploy to GitHub Pages uses: peaceiris/actions gh pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs/my_site/out ``` 2. **é…ç½® GitHub Pages** è¿›å…¥ GitHub ä»“åº“è®¾ç½® æ‰¾åˆ° \"Pages\" é€‰é¡¹ é€‰æ‹© \"Deploy from a branch\" é€‰æ‹© \"gh pages\" åˆ†æ”¯ ### æ–¹æ³•äºŒï¼šæ‰‹åŠ¨éƒ¨ç½² 1. **æ„å»ºæ–‡æ¡£** ```bash cd docs/my_site teedoc build ``` 2. **æ¨é€åˆ° gh pages åˆ†æ”¯** ```bash # åˆ›å»ºå¹¶åˆ‡æ¢åˆ° gh pages åˆ†æ”¯ git checkout orphan gh pages # å¤åˆ¶æ„å»ºæ–‡ä»¶ cp r docs/my_site/out/* . # æäº¤å¹¶æ¨é€ git add . git commit m \"Deploy documentation\" git push origin gh pages ``` ## Netlify éƒ¨ç½² ### æ–¹æ³•ä¸€ï¼šGit é›†æˆéƒ¨ç½² 1. **è¿æ¥ GitHub ä»“åº“** ç™»å½• Netlify é€‰æ‹© \"New site from Git\" è¿æ¥ GitHub ä»“åº“ 2. **é…ç½®æ„å»ºè®¾ç½®** Build command: `cd docs && pip install r requirements.txt && cd my_site && teedoc build` Publish directory: `docs/my_site/out` Base directory: `/` 3. **åˆ›å»º netlify.toml** ```toml [build] command \"cd docs && pip install r requirements.txt && cd my_site && teedoc build\" publish \"docs/my_site/out\" [build.environment] PYTHON_VERSION \"3.9\" ``` ### æ–¹æ³•äºŒï¼šæ‰‹åŠ¨éƒ¨ç½² 1. **æ„å»ºæ–‡æ¡£** ```bash cd docs/my_site teedoc build ``` 2. **ä¸Šä¼ åˆ° Netlify** å°† `out/` ç›®å½•æ‰“åŒ…ä¸º zip æ–‡ä»¶ åœ¨ Netlify æ§åˆ¶å°æ‰‹åŠ¨ä¸Šä¼  ## Vercel éƒ¨ç½² 1. **åˆ›å»º vercel.json** ```json { \"version\": 2, \"builds\": [ { \"src\": \"docs/my_site/build.py\", \"use\": \"@vercel/python\" } ], \"routes\": [ { \"src\": \"/(.*)\", \"dest\": \"/docs/my_site/out/$1\" } ] } ``` 2. **åˆ›å»ºæ„å»ºè„šæœ¬** ```python # docs/my_site/build.py import subprocess import os os.chdir('docs') subprocess.run(['pip', 'install', ' r', 'requirements.txt']) os.chdir('my_site') subprocess.run(['teedoc', 'build']) ``` ## è‡ªå®šä¹‰åŸŸå ### é…ç½® CNAME 1. **æ·»åŠ  CNAME æ–‡ä»¶** ```bash # åœ¨ out/ ç›®å½•åˆ›å»º CNAME æ–‡ä»¶ echo \"docs.openearable.com\" > docs/my_site/out/CNAME ``` 2. **é…ç½® DNS** åœ¨åŸŸåæœåŠ¡å•†æ·»åŠ  CNAME è®°å½• æŒ‡å‘ GitHub Pages æˆ–éƒ¨ç½²å¹³å°çš„åŸŸå ### æ›´æ–°é…ç½® ä¿®æ”¹ `site_config.json`ï¼š ```json { \"site_domain\": \"docs.openearable.com\", \"site_protocol\": \"https\", \"site_root_url\": \"/\" } ``` ## æ€§èƒ½ä¼˜åŒ– ### å¯ç”¨å‹ç¼© å¤§å¤šæ•°æ‰˜ç®¡å¹³å°éƒ½æ”¯æŒ Gzip å‹ç¼©ï¼Œç¡®ä¿å·²å¯ç”¨ï¼š ```json // netlify.toml [[headers]] for \"/*\" [headers.values] Content Encoding \"gzip\" ``` ### CDN åŠ é€Ÿ ä½¿ç”¨ CDN åŠ é€Ÿé™æ€èµ„æºï¼š ```json // site_config.json { \"plugins\": { \"teedoc plugin assets\": { \"config\": { \"header_items\": [ \"<link rel \\\"preload\\\" href \\\"/static/css/main.css\\\" as \\\"style\\\">\", \"<link rel \\\"dns prefetch\\\" href \\\"//fonts.googleapis.com\\\">\" ] } } } } ``` ## ç›‘æ§å’Œç»´æŠ¤ ### æ„å»ºçŠ¶æ€ç›‘æ§ è®¾ç½® GitHub Actions é€šçŸ¥ ç›‘æ§éƒ¨ç½²çŠ¶æ€ é…ç½®é”™è¯¯æŠ¥å‘Š ### å®šæœŸæ›´æ–° ```bash # æ›´æ–°ä¾èµ– pip install upgrade teedoc # é‡æ–°æ„å»º teedoc build ``` ## æ•…éšœæ’é™¤ ### å¸¸è§é—®é¢˜ **é—®é¢˜**ï¼šæ„å»ºå¤±è´¥ **è§£å†³**ï¼šæ£€æŸ¥ Python ç‰ˆæœ¬å’Œä¾èµ–åŒ…ç‰ˆæœ¬ **é—®é¢˜**ï¼šæ ·å¼ä¸¢å¤± **è§£å†³**ï¼šæ£€æŸ¥é™æ€æ–‡ä»¶è·¯å¾„é…ç½® **é—®é¢˜**ï¼šæœç´¢ä¸å·¥ä½œ **è§£å†³**ï¼šç¡®ä¿æœç´¢ç´¢å¼•æ–‡ä»¶å·²æ­£ç¡®ç”Ÿæˆ ### è°ƒè¯•æŠ€å·§ 1. **æœ¬åœ°æµ‹è¯•** ```bash # æœ¬åœ°æ„å»ºæµ‹è¯• teedoc build teedoc serve ``` 2. **æ£€æŸ¥æ—¥å¿—** ```bash # æŸ¥çœ‹æ„å»ºæ—¥å¿— teedoc build verbose ``` 3. **éªŒè¯é…ç½®** ```bash # éªŒè¯é…ç½®æ–‡ä»¶ python m json.tool site_config.json ``` ## å¤‡ä»½å’Œæ¢å¤ ### å¤‡ä»½ç­–ç•¥ 1. **æºç å¤‡ä»½**ï¼šå®šæœŸæ¨é€åˆ° Git ä»“åº“ 2. **æ„å»ºå¤‡ä»½**ï¼šä¿å­˜æ„å»ºäº§ç‰© 3. **é…ç½®å¤‡ä»½**ï¼šå¤‡ä»½é‡è¦é…ç½®æ–‡ä»¶ ### æ¢å¤æµç¨‹ 1. **ä» Git æ¢å¤** ```bash git clone <repository> cd docs pip install r requirements.txt cd my_site teedoc build ``` 2. **é‡æ–°éƒ¨ç½²** ```bash # æ ¹æ®é€‰æ‹©çš„éƒ¨ç½²æ–¹å¼é‡æ–°éƒ¨ç½² ``` ## å‚è€ƒèµ„æº [GitHub Pages æ–‡æ¡£](https://docs.github.com/en/pages) [Netlify æ–‡æ¡£](https://docs.netlify.com/) [Vercel æ–‡æ¡£](https://vercel.com/docs) [TeeDoc éƒ¨ç½²æŒ‡å—](https://teedoc.github.io/)"},"/lhfdoc.github.io/embedded_dev/openearable/teedoc-guide.html":{"title":"TeeDoc å¿«é€Ÿå¯åŠ¨æŒ‡å—","content":"# TeeDoc å¿«é€Ÿå¯åŠ¨æŒ‡å— ## ç®€ä»‹ TeeDoc æ˜¯ä¸€ä¸ªåŸºäº Python çš„é™æ€æ–‡æ¡£ç”Ÿæˆå™¨ï¼Œå¯ä»¥å°† Markdown æ–‡æ¡£è½¬æ¢ä¸ºç¾è§‚çš„é™æ€ç½‘ç«™ã€‚æœ¬æŒ‡å—å°†å¸®åŠ©ä½ å¿«é€Ÿå¯åŠ¨ OpenEarable 2.0 é¡¹ç›®çš„æ–‡æ¡£ç½‘ç«™ã€‚ ## ç¯å¢ƒè¦æ±‚ Python 3.7 æˆ–æ›´é«˜ç‰ˆæœ¬ pip åŒ…ç®¡ç†å™¨ ## å¿«é€Ÿå¯åŠ¨ ### æ–¹æ³•ä¸€ï¼šä½¿ç”¨å¯åŠ¨è„šæœ¬ï¼ˆæ¨èï¼‰ æˆ‘ä»¬æä¾›äº†è‡ªåŠ¨åŒ–çš„å¯åŠ¨è„šæœ¬ï¼Œå¯ä»¥ä¸€é”®å®Œæˆç¯å¢ƒé…ç½®å’Œæ–‡æ¡£æ„å»ºã€‚ #### Windows ç”¨æˆ· ```bash # åŒå‡»è¿è¡Œæˆ–åœ¨å‘½ä»¤è¡Œä¸­æ‰§è¡Œ .\\å¯åŠ¨TeeDocæœåŠ¡å™¨.bat ``` #### Linux/macOS ç”¨æˆ· ```bash # ç»™è„šæœ¬æ·»åŠ æ‰§è¡Œæƒé™ chmod +x å¯åŠ¨TeeDocæœåŠ¡å™¨.sh # è¿è¡Œè„šæœ¬ ./å¯åŠ¨TeeDocæœåŠ¡å™¨.sh ``` ### æ–¹æ³•äºŒï¼šæ‰‹åŠ¨å¯åŠ¨ å¦‚æœä½ å¸Œæœ›æ‰‹åŠ¨æ§åˆ¶æ¯ä¸ªæ­¥éª¤ï¼Œå¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ“ä½œï¼š 1. **åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ** ```bash python m venv venv ``` 2. **æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ** ```bash # Windows venv\\Scripts\\activate # Linux/macOS source venv/bin/activate ``` 3. **å®‰è£…ä¾èµ–åŒ…** ```bash pip install r requirements.txt ``` 4. **æ„å»ºæ–‡æ¡£** ```bash cd my_site teedoc build ``` 5. **å¯åŠ¨æœåŠ¡å™¨** ```bash teedoc serve ``` ## è®¿é—®æ–‡æ¡£ å¯åŠ¨æˆåŠŸåï¼Œåœ¨æµè§ˆå™¨ä¸­è®¿é—®ï¼š æœ¬åœ°åœ°å€ï¼šhttp://127.0.0.1:2333 æˆ–è€…ï¼šhttp://localhost:2333 !!! tip \"å°è´´å£«\" é¦–æ¬¡å¯åŠ¨å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿæ—¶é—´å®‰è£…ä¾èµ–åŒ…ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚ ## æ–‡æ¡£ç»“æ„ ``` my_site/ â”œâ”€â”€ site_config.json # ç½‘ç«™ä¸»é…ç½®æ–‡ä»¶ â”œâ”€â”€ docs/ # æ–‡æ¡£ç›®å½• â”‚ â”œâ”€â”€ guide/ # é¡¹ç›®æŒ‡å— â”‚ â”‚ â”œâ”€â”€ config.json â”‚ â”‚ â”œâ”€â”€ sidebar.yaml â”‚ â”‚ â””â”€â”€ *.md â”‚ â””â”€â”€ modules/ # æ¨¡å—æ–‡æ¡£ â”‚ â”œâ”€â”€ config.json â”‚ â”œâ”€â”€ sidebar.yaml â”‚ â””â”€â”€ *.md â”œâ”€â”€ static/ # é™æ€èµ„æº â””â”€â”€ out/ # æ„å»ºè¾“å‡ºç›®å½• ``` ## ç¼–è¾‘æ–‡æ¡£ 1. **æ·»åŠ æ–°æ–‡æ¡£**ï¼šåœ¨å¯¹åº”ç›®å½•ä¸‹åˆ›å»º `.md` æ–‡ä»¶ 2. **ä¿®æ”¹å¯¼èˆª**ï¼šç¼–è¾‘ `sidebar.yaml` æ–‡ä»¶ 3. **æ›´æ–°é…ç½®**ï¼šä¿®æ”¹ `config.json` æ–‡ä»¶ 4. **é‡æ–°æ„å»º**ï¼šè¿è¡Œ `teedoc build` å‘½ä»¤ ## å¸¸è§é—®é¢˜ ### å¯åŠ¨å¤±è´¥ **é—®é¢˜**ï¼šæç¤º Python æœªæ‰¾åˆ° **è§£å†³**ï¼šç¡®ä¿å·²å®‰è£… Python 3.7+ å¹¶æ·»åŠ åˆ°ç³»ç»Ÿ PATH **é—®é¢˜**ï¼šç«¯å£è¢«å ç”¨ **è§£å†³**ï¼šä¿®æ”¹ `site_config.json` ä¸­çš„ç«¯å£é…ç½® ### æ„å»ºé”™è¯¯ **é—®é¢˜**ï¼šMarkdown è¯­æ³•é”™è¯¯ **è§£å†³**ï¼šæ£€æŸ¥ `.md` æ–‡ä»¶çš„è¯­æ³•ï¼Œç‰¹åˆ«æ˜¯ä»£ç å—å’Œè¡¨æ ¼ **é—®é¢˜**ï¼šé…ç½®æ–‡ä»¶é”™è¯¯ **è§£å†³**ï¼šæ£€æŸ¥ `config.json` å’Œ `sidebar.yaml` çš„ JSON/YAML è¯­æ³• ## æ›´å¤šåŠŸèƒ½ **æœç´¢åŠŸèƒ½**ï¼šæ”¯æŒå…¨æ–‡æœç´¢ **ä¸»é¢˜åˆ‡æ¢**ï¼šæ”¯æŒæš—è‰²/äº®è‰²ä¸»é¢˜ **å¤šè¯­è¨€**ï¼šæ”¯æŒä¸­è‹±æ–‡åˆ‡æ¢ **å“åº”å¼è®¾è®¡**ï¼šé€‚é…ç§»åŠ¨è®¾å¤‡ ## å‚è€ƒèµ„æº [TeeDoc å®˜æ–¹æ–‡æ¡£](https://teedoc.github.io/) [Markdown è¯­æ³•å‚è€ƒ](https://www.markdownguide.org/) [OpenEarable é¡¹ç›®ä¸»é¡µ](https://github.com/OpenEarable)"},"/lhfdoc.github.io/embedded_dev/openearable/battery-module.html":{"title":"ç”µæºç®¡ç†æ¨¡å—è¯¦ç»†åˆ†æ","content":"# ç”µæºç®¡ç†æ¨¡å—è¯¦ç»†åˆ†æ ## æ¨¡å—æ¦‚è¿° ç”µæºç®¡ç†æ¨¡å—æ˜¯OpenEarable 2.0çš„æ ¸å¿ƒç»„ä»¶ä¹‹ä¸€ï¼Œè´Ÿè´£æ•´ä¸ªç³»ç»Ÿçš„ç”µæºçŠ¶æ€ç®¡ç†ã€ç”µæ± ç›‘æ§ã€å……ç”µæ§åˆ¶ç­‰åŠŸèƒ½ã€‚è¯¥æ¨¡å—é‡‡ç”¨äº†åŒèŠ¯ç‰‡æ¶æ„ï¼Œé€šè¿‡BQ27220ç‡ƒæ–™è®¡é‡èŠ¯ç‰‡å’ŒBQ25120aå……ç”µç®¡ç†èŠ¯ç‰‡å®ç°å®Œæ•´çš„ç”µæºè§£å†³æ–¹æ¡ˆã€‚ ## æ–‡ä»¶ç»“æ„ ``` src/Battery/ â”œâ”€â”€ PowerManager.h/.cpp # ç”µæºç®¡ç†å™¨ä¸»ç±» â”œâ”€â”€ BQ27220.h/.cpp # ç‡ƒæ–™è®¡é‡èŠ¯ç‰‡é©±åŠ¨ â”œâ”€â”€ BQ25120a.h/.cpp # å……ç”µç®¡ç†èŠ¯ç‰‡é©±åŠ¨ â”œâ”€â”€ BootState.h/.c # å¯åŠ¨çŠ¶æ€ç®¡ç† â”œâ”€â”€ CMakeLists.txt # æ„å»ºé…ç½® â””â”€â”€ Kconfig # é…ç½®é€‰é¡¹ ``` ## æ ¸å¿ƒç±»åˆ†æ ### 1. PowerManager ç±» PowerManageræ˜¯ç”µæºç®¡ç†çš„æ ¸å¿ƒç±»ï¼Œè´Ÿè´£åè°ƒå„ä¸ªç”µæºç»„ä»¶çš„å·¥ä½œã€‚ #### ä¸»è¦åŠŸèƒ½ **ç³»ç»Ÿç”µæºæ§åˆ¶**: å¼€å…³æœºã€é‡å¯ç­‰ **å……ç”µçŠ¶æ€ç›‘æ§**: å®æ—¶ç›‘æ§å……ç”µçŠ¶æ€å˜åŒ– **ç”µæ± çŠ¶æ€ç®¡ç†**: ç”µé‡ã€å¥åº·çŠ¶æ€ã€æ¸©åº¦ç­‰ **ç”µæºå¼‚å¸¸å¤„ç†**: ä½ç”µé‡ä¿æŠ¤ã€å……ç”µæ•…éšœå¤„ç† **LEDçŠ¶æ€æŒ‡ç¤º**: é€šè¿‡LEDæ˜¾ç¤ºç”µæºçŠ¶æ€ #### å…³é”®æ–¹æ³• ```cpp class PowerManager { public: int begin(); // åˆå§‹åŒ–ç”µæºç®¡ç†å™¨ int power_down(bool fault); // ç³»ç»Ÿå…³æœº void reboot(); // ç³»ç»Ÿé‡å¯ // çŠ¶æ€æŸ¥è¯¢æ¥å£ void get_battery_status(battery_level_status &status); void get_energy_status(battery_energy_status &status); void get_health_status(battery_health_status &status); void set_error_led(int val); // é”™è¯¯LEDæ§åˆ¶ }; ``` #### å·¥ä½œé˜Ÿåˆ—æ¶æ„ PowerManagerä½¿ç”¨Zephyrçš„å·¥ä½œé˜Ÿåˆ—ç³»ç»Ÿå®ç°å¼‚æ­¥ä»»åŠ¡å¤„ç†ï¼š ```cpp // å»¶è¿Ÿå·¥ä½œé˜Ÿåˆ—å®šä¹‰ K_WORK_DELAYABLE_DEFINE(PowerManager::charge_ctrl_delayable, charge_ctrl_work_handler); K_WORK_DELAYABLE_DEFINE(PowerManager::power_down_work, power_down_work_handler); // å³æ—¶å·¥ä½œé˜Ÿåˆ—å®šä¹‰ K_WORK_DEFINE(PowerManager::fuel_gauge_work, fuel_gauge_work_handler); K_WORK_DEFINE(PowerManager::battery_controller_work, battery_controller_work_handler); ``` #### ä¸­æ–­å¤„ç†æœºåˆ¶ ```cpp // ç‡ƒæ–™è®¡é‡èŠ¯ç‰‡ä¸­æ–­å¤„ç† void fuel_gauge_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins); // å……ç”µæ§åˆ¶èŠ¯ç‰‡ä¸­æ–­å¤„ç† void battery_controller_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins); // ç”µæºè¿æ¥çŠ¶æ€ä¸­æ–­å¤„ç† void power_good_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins); ``` ### 2. BQ27220 ç‡ƒæ–™è®¡é‡èŠ¯ç‰‡é©±åŠ¨ BQ27220æ˜¯å¾·å·ä»ªå™¨(TI)çš„å•èŠ‚é”‚ç¦»å­ç”µæ± ç‡ƒæ–™è®¡é‡èŠ¯ç‰‡ï¼Œæä¾›ç²¾ç¡®çš„ç”µæ± çŠ¶æ€ä¿¡æ¯ã€‚ #### ä¸»è¦åŠŸèƒ½ **ç”µæ± çŠ¶æ€ç›‘æ§**: ç”µå‹ã€ç”µæµã€æ¸©åº¦ã€ç”µé‡ç™¾åˆ†æ¯” **ç”µæ± å¥åº·è¯„ä¼°**: å¾ªç¯æ¬¡æ•°ã€å¥åº·çŠ¶æ€ã€å‰©ä½™å®¹é‡ **å®‰å…¨ä¿æŠ¤**: è¿‡å‹ã€æ¬ å‹ã€è¿‡æ¸©ä¿æŠ¤ **æ ¡å‡†åŠŸèƒ½**: æ”¯æŒç”µæ± å®¹é‡æ ¡å‡† #### å¯„å­˜å™¨å®šä¹‰ ```cpp enum registers : uint8_t { CTRL 0x00, // æ§åˆ¶å¯„å­˜å™¨ TEMP 0x06, // æ¸©åº¦å¯„å­˜å™¨ VOLT 0x08, // ç”µå‹å¯„å­˜å™¨ AI 0x14, // å¹³å‡ç”µæµå¯„å­˜å™¨ FLAGS 0x0A, // çŠ¶æ€æ ‡å¿—å¯„å­˜å™¨ NAC 0x0C, // æ ‡ç§°å¯ç”¨å®¹é‡ FCC 0x12, // æ»¡å……å®¹é‡ SOC 0x2C, // ç”µé‡ç™¾åˆ†æ¯” SOH 0x2E, // å¥åº·çŠ¶æ€ }; ``` #### ç”µæ± çŠ¶æ€ç»“æ„ ```cpp struct bat_status { bool DSG; // æ”¾ç”µçŠ¶æ€ bool SYSDWN; // ç³»ç»Ÿå…³æœºç”µå‹ bool TDA; // æ¸©åº¦æ•°æ®å¯ç”¨ bool BATTPRES; // ç”µæ± å­˜åœ¨ bool AUTH_GD; // è®¤è¯è‰¯å¥½ bool OCVGD; // å¼€è·¯ç”µå‹è‰¯å¥½ bool TCA; // æ¸©åº¦è¡¥å¿å¯ç”¨ bool CHGINH; // å……ç”µç¦æ­¢ bool FC; // å……ç”µå®Œæˆ bool OTD; // æ”¾ç”µè¿‡æ¸© bool OTC; // å……ç”µè¿‡æ¸© bool SLEEP; // ç¡çœ æ¨¡å¼ bool OCVFAIL; // å¼€è·¯ç”µå‹å¤±è´¥ bool OCVCOMP; // å¼€è·¯ç”µå‹è¡¥å¿ bool FD; // å®Œå…¨æ”¾ç”µ }; ``` #### å…³é”®æ–¹æ³• ```cpp class BQ27220 { public: int begin(); // åˆå§‹åŒ–èŠ¯ç‰‡ float voltage(); // è¯»å–ç”µå‹ float current(); // è¯»å–ç”µæµ float temperature(); // è¯»å–æ¸©åº¦ float state_of_charge(); // è¯»å–ç”µé‡ç™¾åˆ†æ¯” float state_of_health(); // è¯»å–å¥åº·çŠ¶æ€ bat_status battery_status(); // è¯»å–ç”µæ± çŠ¶æ€ gauge_status gauging_state(); // è¯»å–è®¡é‡çŠ¶æ€ int calibration_enter(); // è¿›å…¥æ ¡å‡†æ¨¡å¼ int calibration_exit(); // é€€å‡ºæ ¡å‡†æ¨¡å¼ int config_update_enter(); // è¿›å…¥é…ç½®æ›´æ–°æ¨¡å¼ int config_update_exit(); // é€€å‡ºé…ç½®æ›´æ–°æ¨¡å¼ }; ``` ### 3. BQ25120a å……ç”µç®¡ç†èŠ¯ç‰‡é©±åŠ¨ BQ25120aæ˜¯TIçš„ä½åŠŸè€—çº¿æ€§å……ç”µç®¡ç†èŠ¯ç‰‡ï¼Œä¸“ä¸ºä¾¿æºå¼è®¾å¤‡è®¾è®¡ã€‚ #### ä¸»è¦åŠŸèƒ½ **å……ç”µæ§åˆ¶**: æ’æµ/æ’å‹å……ç”µï¼Œå……ç”µç”µæµå¯è°ƒ **ç”µæºè·¯å¾„ç®¡ç†**: æ”¯æŒè¾¹å……è¾¹ç”¨ **æŒ‰é”®æ£€æµ‹**: é›†æˆæŒ‰é”®æ£€æµ‹åŠŸèƒ½ **è´Ÿè½½å¼€å…³**: é›†æˆLDOå’Œè´Ÿè½½å¼€å…³ **å®‰å…¨ä¿æŠ¤**: è¿‡å‹ã€è¿‡æµã€è¿‡æ¸©ä¿æŠ¤ #### å¯„å­˜å™¨å®šä¹‰ ```cpp enum registers : uint8_t { CTRL 0x00, // æ§åˆ¶å¯„å­˜å™¨ FAULT 0x01, // æ•…éšœçŠ¶æ€å¯„å­˜å™¨ TS_FAULT 0x02, // æ¸©åº¦ä¼ æ„Ÿå™¨æ•…éšœå¯„å­˜å™¨ CHARGE_CTRL 0x03, // å……ç”µæ§åˆ¶å¯„å­˜å™¨ TERM_CTRL 0x04, // ç»ˆæ­¢æ§åˆ¶å¯„å­˜å™¨ BAT_VOL_CTRL 0x05, // ç”µæ± ç”µå‹æ§åˆ¶å¯„å­˜å™¨ LS_LDO_CTRL 0x07, // è´Ÿè½½å¼€å…³/LDOæ§åˆ¶å¯„å­˜å™¨ BTN_CTRL 0x08, // æŒ‰é”®æ§åˆ¶å¯„å­˜å™¨ ILIM_UVLO 0x09 // è¾“å…¥é™æµ/æ¬ å‹é”å®šå¯„å­˜å™¨ }; ``` #### å……ç”µçŠ¶æ€ç»“æ„ ```cpp struct chrg_state { float mAh; // å……ç”µç”µæµ(mA) bool enabled; // å……ç”µä½¿èƒ½ bool high_impedance; // é«˜é˜»æŠ—æ¨¡å¼ }; struct button_state { bool wake_1; // å”¤é†’æŒ‰é”®1çŠ¶æ€ bool wake_2; // å”¤é†’æŒ‰é”®2çŠ¶æ€ }; ``` #### å…³é”®æ–¹æ³• ```cpp class BQ25120a { public: int begin(); // åˆå§‹åŒ–èŠ¯ç‰‡ // ç”µæºæ§åˆ¶ bool power_connected(); // æ£€æµ‹ç”µæºè¿æ¥ void enter_high_impedance(); // è¿›å…¥é«˜é˜»æŠ—æ¨¡å¼ void exit_high_impedance(); // é€€å‡ºé«˜é˜»æŠ—æ¨¡å¼ // å……ç”µæ§åˆ¶ void disable_charge(); // ç¦ç”¨å……ç”µ void enable_charge(); // ä½¿èƒ½å……ç”µ uint8_t read_charging_state(); // è¯»å–å……ç”µçŠ¶æ€ // æ•…éšœæ£€æµ‹ uint8_t read_fault(); // è¯»å–æ•…éšœçŠ¶æ€ uint8_t read_ts_fault(); // è¯»å–æ¸©åº¦ä¼ æ„Ÿå™¨æ•…éšœ // æŒ‰é”®æ£€æµ‹ button_state read_button_state(); // è¯»å–æŒ‰é”®çŠ¶æ€ // å›è°ƒè®¾ç½® int set_power_connect_callback(gpio_callback_handler_t handler); int set_int_callback(gpio_callback_handler_t handler); }; ``` ## ç”µæºç®¡ç†çŠ¶æ€æœº ### å……ç”µçŠ¶æ€å®šä¹‰ ```cpp enum charging_state { DISCHARGING, // æ”¾ç”µçŠ¶æ€ POWER_CONNECTED, // ç”µæºå·²è¿æ¥ PRECHARGING, // é¢„å……ç”µçŠ¶æ€ CHARGING, // æ­£åœ¨å……ç”µ TRICKLE_CHARGING, // æ¶“æµå……ç”µ FULLY_CHARGED, // å……ç”µå®Œæˆ BATTERY_LOW, // ç”µæ± ä½ç”µé‡ BATTERY_CRITICAL, // ç”µæ± ä¸¥é‡ä½ç”µé‡ FAULT // æ•…éšœçŠ¶æ€ }; ``` ### çŠ¶æ€è½¬æ¢é€»è¾‘ ```cpp void PowerManager::charge_task() { // è¯»å–å……ç”µçŠ¶æ€ uint16_t charging_state battery_controller.read_charging_state() >> 6; switch (charging_state) { case 0: // æ”¾ç”µçŠ¶æ€ msg.charging_state DISCHARGING; // æ£€æŸ¥ä½ç”µé‡çŠ¶æ€ gauge_status gs fuel_gauge.gauging_state(); if (gs.edv2) msg.charging_state BATTERY_LOW; if (gs.edv1) msg.charging_state BATTERY_CRITICAL; break; case 1: // å……ç”µçŠ¶æ€ // æ£€æŸ¥ç³»ç»Ÿå…³æœºç”µå‹ if (bat.SYSDWN) { msg.charging_state PRECHARGING; break; } // åˆ†æå……ç”µå‚æ•° float current fuel_gauge.current(); float target_current fuel_gauge.charge_current(); float voltage fuel_gauge.voltage(); // åˆ¤æ–­å…·ä½“å……ç”µé˜¶æ®µ if (current > 0.8 * target_current 2 * i_term) { msg.charging_state CHARGING; } else if (voltage > u_term 0.02) { msg.charging_state TRICKLE_CHARGING; } break; case 2: // å……ç”µå®Œæˆ msg.charging_state FULLY_CHARGED; break; case 3: // æ•…éšœçŠ¶æ€ msg.charging_state FAULT; break; } } ``` ## LEDçŠ¶æ€æŒ‡ç¤º ### å……ç”µçŠ¶æ€LED LEDçŠ¶æ€ æè¿° ğŸŸ¥ çº¢è‰²å¸¸äº® ç”µæ± æ•…éšœæˆ–æ·±åº¦æ”¾ç”µ ğŸ”´ çº¢è‰²è„‰å†² é¢„å……ç”µé˜¶æ®µ ğŸŸ§ æ©™è‰²å¸¸äº® ç”µæºè¿æ¥ï¼Œå……ç”µç”µæµæœªè¾¾åˆ°ç›®æ ‡ ğŸŸ  æ©™è‰²è„‰å†² å……ç”µç”µæµè¾¾åˆ°ç›®æ ‡çš„80% ğŸŸ¢ ç»¿è‰²è„‰å†² æ¶“æµå……ç”µ ğŸŸ© ç»¿è‰²å¸¸äº® å……ç”µå®Œæˆ ### æ”¾ç”µçŠ¶æ€LED LEDçŠ¶æ€ æè¿° ğŸŸ  æ©™è‰²é—ªçƒ ç”µæ± ä½ç”µé‡(7%å‰©ä½™) ğŸ”´ çº¢è‰²é—ªçƒ ç”µæ± ä¸¥é‡ä½ç”µé‡(3%å‰©ä½™) ## é…ç½®å‚æ•° ### ç”µæ± å‚æ•°é…ç½® ```cpp struct battery_settings { uint16_t capacity_mAh; // ç”µæ± å®¹é‡(mAh) uint16_t nominal_voltage_mV; // æ ‡ç§°ç”µå‹(mV) uint16_t max_voltage_mV; // æœ€å¤§ç”µå‹(mV) uint16_t charge_current_mA; // å……ç”µç”µæµ(mA) uint16_t taper_current_mA; // æ¶“æµå……ç”µç”µæµ(mA) float u_term; // ç»ˆæ­¢ç”µå‹(V) float i_term; // ç»ˆæ­¢ç”µæµ(mA) }; ``` ### Kconfigé…ç½®é€‰é¡¹ ```kconfig CONFIG_BATTERY_CHARGE_CONTROLLER_NORMAL_INTERVAL_SECONDS 5 CONFIG_BATTERY_ENABLE_LOW_STATE y CONFIG_BATTERY_ENABLE_TRICKLE_CHARGE y ``` ## æ¶ˆæ¯æ€»çº¿é›†æˆ ç”µæºç®¡ç†æ¨¡å—ä½¿ç”¨Zephyrçš„ZBusæ¶ˆæ¯æ€»çº¿ä¸å…¶ä»–æ¨¡å—é€šä¿¡ï¼š ```cpp // å®šä¹‰ç”µæ± æ•°æ®é€šé“ ZBUS_CHAN_DEFINE(battery_chan, struct battery_data, NULL, NULL, ZBUS_OBSERVERS_EMPTY, ZBUS_MSG_INIT(0)); // ç”µæ± æ•°æ®ç»“æ„ struct battery_data { float battery_level; // ç”µé‡ç™¾åˆ†æ¯” enum charging_state charging_state; // å……ç”µçŠ¶æ€ }; ``` ## é”™è¯¯å¤„ç†æœºåˆ¶ ### æ•…éšœæ£€æµ‹ ```cpp void PowerManager::handle_fault(uint8_t fault_code) { // è®¾ç½®é”™è¯¯LED set_error_led(1); // è®°å½•æ•…éšœä¿¡æ¯ LOG_ERR(\"Battery fault detected: 0x%02X\", fault_code); // æ ¹æ®æ•…éšœç±»å‹é‡‡å–æªæ–½ switch (fault_code) { case OVER_TEMP_FAULT: disable_charging(); break; case OVER_VOLTAGE_FAULT: emergency_shutdown(); break; // ... å…¶ä»–æ•…éšœå¤„ç† } } ``` ### ä½ç”µé‡ä¿æŠ¤ ```cpp void PowerManager::check_low_battery() { if (power_on && battery_status.SYSDWN) { LOG_WRN(\"Battery reached system down voltage.\"); k_work_reschedule(&power_down_work, K_NO_WAIT); } } ``` ## æ€§èƒ½ä¼˜åŒ– ### åŠŸè€—ä¼˜åŒ– ä½¿ç”¨é«˜é˜»æŠ—æ¨¡å¼å‡å°‘å¾…æœºåŠŸè€— åŠ¨æ€è°ƒæ•´ç›‘æ§é—´éš” æ™ºèƒ½ç”µæºè·¯å¾„ç®¡ç† ### ç²¾åº¦ä¼˜åŒ– ç”µæ± å‚æ•°æ ¡å‡† æ¸©åº¦è¡¥å¿ è€åŒ–è¡¥å¿ç®—æ³• ## æ€»ç»“ ç”µæºç®¡ç†æ¨¡å—é€šè¿‡åŒèŠ¯ç‰‡æ¶æ„å®ç°äº†å®Œæ•´çš„ç”µæºè§£å†³æ–¹æ¡ˆï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š 1. **å®Œæ•´çš„ç”µæºçŠ¶æ€ç›‘æ§**: ç”µé‡ã€ç”µå‹ã€ç”µæµã€æ¸©åº¦ç­‰å‚æ•°å®æ—¶ç›‘æ§ 2. **æ™ºèƒ½å……ç”µç®¡ç†**: æ”¯æŒå¤šé˜¶æ®µå……ç”µå’Œå„ç§ä¿æŠ¤åŠŸèƒ½ 3. **ç”¨æˆ·å‹å¥½çš„çŠ¶æ€æŒ‡ç¤º**: é€šè¿‡LEDç›´è§‚æ˜¾ç¤ºç”µæºçŠ¶æ€ 4. **ç³»ç»Ÿé›†æˆå‹å¥½**: é€šè¿‡æ¶ˆæ¯æ€»çº¿ä¸å…¶ä»–æ¨¡å—é€šä¿¡ 5. **å®‰å…¨å¯é **: å¤šé‡ä¿æŠ¤æœºåˆ¶ç¡®ä¿ç³»ç»Ÿå®‰å…¨ è¯¥æ¨¡å—ä¸ºOpenEarable 2.0æä¾›äº†ç¨³å®šå¯é çš„ç”µæºåŸºç¡€ï¼Œæ”¯æŒé•¿æ—¶é—´è¿è¡Œå’Œå®‰å…¨çš„å……ç”µä½“éªŒã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/wire-module.html":{"title":"OpenEarable 2.0 - I2Cé€šä¿¡æ¨¡å— (Wire Module)","content":"# OpenEarable 2.0 I2Cé€šä¿¡æ¨¡å— (Wire Module) ## æ¦‚è¿° I2Cé€šä¿¡æ¨¡å—ä¸ºOpenEarableè®¾å¤‡æä¾›äº†Arduinoé£æ ¼çš„I2Cé€šä¿¡æ¥å£ï¼ŒåŸºäºZephyr RTOSçš„I2Cé©±åŠ¨å®ç°ã€‚è¯¥æ¨¡å—å°è£…äº†åº•å±‚çš„I2Cç¡¬ä»¶æ“ä½œï¼Œä¸ºä¸Šå±‚é©±åŠ¨å’Œåº”ç”¨æä¾›äº†ç®€æ´æ˜“ç”¨çš„é€šä¿¡æ¥å£ã€‚ ## æ ¸å¿ƒç»„ä»¶ ### 1. Arduinoé£æ ¼I2Cæ¥å£ (`Wire.h/cpp`) æä¾›ä¸Arduino Wireåº“å…¼å®¹çš„I2Cæ¥å£ï¼š #### æ ¸å¿ƒç±»å®šä¹‰ ```cpp class MbedI2C { public: MbedI2C(const struct device * master); // åŸºæœ¬æ“ä½œ virtual void begin(uint32_t speed I2C_SPEED_FAST); virtual void end(); virtual void setClock(uint32_t freq); // ä¼ è¾“æ“ä½œ virtual void beginTransmission(uint8_t address); virtual uint8_t endTransmission(bool stopBit true); virtual size_t requestFrom(uint8_t address, size_t len, bool stopBit true); // æ•°æ®æ“ä½œ virtual size_t write(uint8_t data); virtual size_t write(const uint8_t* data, int len); virtual int read(); virtual int peek(); virtual void flush(); virtual int available(); // å›è°ƒè®¾ç½® virtual void onReceive(void(*)(int)); virtual void onRequest(void(*)(void)); // èµ„æºç®¡ç† void aquire(); void release(); private: const struct device * master; struct k_mutex mutex; // ç¼“å†²åŒº char buf[BUFFER_RX_SIZE]; RingBufferN<BUFFER_RX_SIZE> rxBuffer; uint8_t txBuffer[BUFFER_TX_SIZE]; uint32_t usedTxBuffer; // åº•å±‚æ“ä½œ int master_read(int address, const char * buf, const uint32_t len, bool no_stop); int master_write(int address, const char * buf, const uint32_t len, bool no_stop); int i2c_message(uint8_t read_write, int address, const char * buf, const uint32_t len, bool no_stop); }; ``` #### é…ç½®å‚æ•° ```cpp #define BUFFER_TX_SIZE 256 // å‘é€ç¼“å†²åŒºå¤§å° #define BUFFER_RX_SIZE 512 // æ¥æ”¶ç¼“å†²åŒºå¤§å° ``` ### 2. åŸºç¡€I2Cç®¡ç† (`TWIM.h/cpp`) æä¾›æ›´åº•å±‚çš„I2Cç®¡ç†æ¥å£ï¼š ```cpp class TWIM { public: TWIM(const struct device * master); virtual void begin(); virtual void end(); virtual void setClock(uint32_t speed I2C_SPEED_FAST); void aquire(); void release(); const struct device * master; private: struct k_mutex mutex; }; ``` ### 3. ç¯å½¢ç¼“å†²åŒº (`RingBuffer.h`) ç”¨äºI2Cæ•°æ®ç¼“å†²çš„ç¯å½¢ç¼“å†²åŒºå®ç°ï¼š ```cpp template<int N> class RingBufferN { private: uint8_t _buffer[N]; volatile int _head; volatile int _tail; public: void store_char(uint8_t c); int read_char(); int available(); int peek(); void clear(); bool isFull(); }; ``` ## å·¥ä½œæœºåˆ¶ ### 1. åˆå§‹åŒ–æµç¨‹ ```cpp void MbedI2C::begin(uint32_t speed) { // 1. æ£€æŸ¥è®¾å¤‡å°±ç»ªçŠ¶æ€ if (!device_is_ready(master)) { LOG_ERR(\"I2C device not ready\"); return; } // 2. é…ç½®I2Cæ—¶é’Ÿé€Ÿåº¦ setClock(speed); // 3. åˆå§‹åŒ–ç¼“å†²åŒº rxBuffer.clear(); usedTxBuffer 0; // 4. åˆå§‹åŒ–äº’æ–¥é” k_mutex_init(&mutex); } ``` ### 2. æ•°æ®ä¼ è¾“æµç¨‹ #### ä¸»æœºå†™æ“ä½œ ```cpp void beginTransmission(uint8_t address) { _address address; usedTxBuffer 0; // æ¸…ç©ºå‘é€ç¼“å†²åŒº } size_t write(uint8_t data) { if (usedTxBuffer < BUFFER_TX_SIZE) { txBuffer[usedTxBuffer++] data; return 1; } return 0; } uint8_t endTransmission(bool stopBit) { int ret master_write(_address, (const char*)txBuffer, usedTxBuffer, !stopBit); usedTxBuffer 0; return (ret 0) ? 0 : 4; // 0 æˆåŠŸ, 4 å…¶ä»–é”™è¯¯ } ``` #### ä¸»æœºè¯»æ“ä½œ ```cpp size_t requestFrom(uint8_t address, size_t len, bool stopBit) { char buffer[len]; int ret master_read(address, buffer, len, !stopBit); if (ret 0) { // å°†æ•°æ®å­˜å…¥ç¯å½¢ç¼“å†²åŒº for (size_t i 0; i < len; i++) { rxBuffer.store_char(buffer[i]); } return len; } return 0; } int read() { return rxBuffer.read_char(); } ``` ### 3. åº•å±‚I2Cæ“ä½œ ```cpp int i2c_message(uint8_t read_write, int address, const char * buf, const uint32_t len, bool no_stop) { struct i2c_msg msg; msg.buf (uint8_t*)buf; msg.len len; msg.flags read_write; if (no_stop) { msg.flags I2C_MSG_STOP; } return i2c_transfer(master, &msg, 1, address); } ``` ## çº¿ç¨‹å®‰å…¨ ### äº’æ–¥é”ä¿æŠ¤ ```cpp void aquire() { k_mutex_lock(&mutex, K_FOREVER); } void release() { k_mutex_unlock(&mutex); } ``` ### å…¸å‹ä½¿ç”¨æ¨¡å¼ ```cpp wire.aquire(); wire.beginTransmission(device_address); wire.write(register_address); wire.write(data); wire.endTransmission(); wire.release(); ``` ## ç¼“å†²åŒºç®¡ç† ### å‘é€ç¼“å†²åŒº å›ºå®šå¤§å°256å­—èŠ‚ åœ¨ `beginTransmission` æ—¶æ¸…ç©º åœ¨ `endTransmission` æ—¶å‘é€ ### æ¥æ”¶ç¼“å†²åŒº ä½¿ç”¨ç¯å½¢ç¼“å†²åŒºï¼Œå¤§å°512å­—èŠ‚ æ”¯æŒæµå¼æ•°æ®æ¥æ”¶ æä¾› `available()` æŸ¥è¯¢å¯è¯»æ•°æ®é‡ ### ç¯å½¢ç¼“å†²åŒºæ“ä½œ ```cpp template<int N> void RingBufferN<N>::store_char(uint8_t c) { int next_head (_head + 1) % N; if (next_head ! _tail) { _buffer[_head] c; _head next_head; } } template<int N> int RingBufferN<N>::read_char() { if (_head _tail) { return 1; // ç¼“å†²åŒºç©º } uint8_t c _buffer[_tail]; _tail (_tail + 1) % N; return c; } ``` ## é”™è¯¯å¤„ç† ### è®¾å¤‡çŠ¶æ€æ£€æŸ¥ ```cpp if (!device_is_ready(master)) { LOG_ERR(\"I2C master device %s not ready\", master >name); return ENODEV; } ``` ### ä¼ è¾“é”™è¯¯å¤„ç† ```cpp int ret i2c_transfer(master, msgs, num_msgs, addr); if (ret ! 0) { LOG_ERR(\"I2C transfer failed: %d\", ret); return ret; } ``` ### ç¼“å†²åŒºæº¢å‡ºä¿æŠ¤ ```cpp size_t write(const uint8_t* data, int len) { size_t written 0; for (int i 0; i < len && usedTxBuffer < BUFFER_TX_SIZE; i++) { txBuffer[usedTxBuffer++] data[i]; written++; } return written; } ``` ## è®¾å¤‡é›†æˆ ### è®¾å¤‡æ ‘é…ç½® ```dts &i2c0 { status \"okay\"; clock frequency <I2C_BITRATE_FAST>; sensor@48 { compatible \"example,sensor\"; reg <0x48>; }; }; ``` ### é©±åŠ¨å®ä¾‹åŒ– ```cpp // è·å–I2Cè®¾å¤‡ const struct device *i2c_dev DEVICE_DT_GET(DT_NODELABEL(i2c0)); // åˆ›å»ºWireå®ä¾‹ MbedI2C wire(i2c_dev); // åˆå§‹åŒ– wire.begin(I2C_SPEED_FAST); ``` ## å…¸å‹åº”ç”¨åœºæ™¯ ### 1. ä¼ æ„Ÿå™¨æ•°æ®è¯»å– ```cpp // è¯»å–ä¼ æ„Ÿå™¨å¯„å­˜å™¨ uint8_t readSensorRegister(uint8_t addr, uint8_t reg) { wire.aquire(); wire.beginTransmission(addr); wire.write(reg); wire.endTransmission(false); // é‡å¤å¯åŠ¨ wire.requestFrom(addr, 1); uint8_t data wire.read(); wire.release(); return data; } ``` ### 2. ä¼ æ„Ÿå™¨é…ç½®å†™å…¥ ```cpp // å†™å…¥ä¼ æ„Ÿå™¨å¯„å­˜å™¨ void writeSensorRegister(uint8_t addr, uint8_t reg, uint8_t value) { wire.aquire(); wire.beginTransmission(addr); wire.write(reg); wire.write(value); wire.endTransmission(); wire.release(); } ``` ### 3. æ‰¹é‡æ•°æ®ä¼ è¾“ ```cpp // è¯»å–å¤šä¸ªè¿ç»­å¯„å­˜å™¨ void readMultipleRegisters(uint8_t addr, uint8_t startReg, uint8_t* buffer, size_t len) { wire.aquire(); wire.beginTransmission(addr); wire.write(startReg); wire.endTransmission(false); wire.requestFrom(addr, len); for (size_t i 0; i < len; i++) { buffer[i] wire.read(); } wire.release(); } ``` ## æ€§èƒ½ä¼˜åŒ– ### æ—¶é’Ÿé…ç½® ```cpp void setClock(uint32_t freq) { struct i2c_config config; config.frequency freq; config.flags I2C_MODE_MASTER; i2c_configure(master, &config); } ``` ### æ”¯æŒçš„æ—¶é’Ÿé€Ÿåº¦ **I2C_SPEED_STANDARD**: 100 kHz **I2C_SPEED_FAST**: 400 kHz **I2C_SPEED_FAST_PLUS**: 1 MHz ### ç¼“å†²åŒºä¼˜åŒ– åˆç†çš„ç¼“å†²åŒºå¤§å°é…ç½® é¿å…é¢‘ç¹çš„å°æ•°æ®ä¼ è¾“ æ‰¹é‡æ“ä½œæé«˜æ•ˆç‡ ## è°ƒè¯•æ”¯æŒ ### æ—¥å¿—è®°å½• ```cpp #include <zephyr/logging/log.h> LOG_MODULE_REGISTER(wire, CONFIG_WIRE_LOG_LEVEL); LOG_DBG(\"I2C write to 0x%02x: %d bytes\", address, len); LOG_ERR(\"I2C transfer failed: %d\", ret); ``` ### çŠ¶æ€ç›‘æ§ ä¼ è¾“æˆåŠŸ/å¤±è´¥ç»Ÿè®¡ ç¼“å†²åŒºä½¿ç”¨æƒ…å†µç›‘æ§ è®¾å¤‡å“åº”æ—¶é—´æµ‹é‡ ## æ€»ç»“ I2Cé€šä¿¡æ¨¡å—æä¾›äº†å®Œæ•´çš„I2Cé€šä¿¡æ”¯æŒï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š 1. **å…¼å®¹æ€§**: Arduino Wireåº“å…¼å®¹æ¥å£ 2. **å¯é æ€§**: å®Œæ•´çš„é”™è¯¯å¤„ç†å’ŒçŠ¶æ€æ£€æŸ¥ 3. **é«˜æ•ˆæ€§**: ä¼˜åŒ–çš„ç¼“å†²åŒºç®¡ç†å’Œæ‰¹é‡ä¼ è¾“ 4. **çº¿ç¨‹å®‰å…¨**: äº’æ–¥é”ä¿æŠ¤çš„å¹¶å‘è®¿é—® 5. **çµæ´»æ€§**: æ”¯æŒå¤šç§æ—¶é’Ÿé€Ÿåº¦å’Œä¼ è¾“æ¨¡å¼ è¯¥æ¨¡å—ä¸ºOpenEarableè®¾å¤‡çš„ä¼ æ„Ÿå™¨å’Œå¤–è®¾é€šä¿¡æä¾›äº†ç¨³å®šå¯é çš„I2Cé€šä¿¡åŸºç¡€è®¾æ–½ã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/project-overview.html":{"title":"OpenEarable 2.0 é¡¹ç›®æ€»ç»“","content":"# OpenEarable 2.0 é¡¹ç›®æ€»ç»“ ## é¡¹ç›®æ¦‚è¿° OpenEarable 2.0 æ˜¯ä¸–ç•Œä¸Šç¬¬ä¸€ä¸ªå®Œå…¨å¼€æºçš„äººå·¥æ™ºèƒ½è€³æˆ´å¼ä¼ æ„Ÿåº”ç”¨å¹³å°ï¼Œå…·å¤‡çœŸæ­£çš„æ— çº¿éŸ³é¢‘åŠŸèƒ½ã€‚è¯¥é¡¹ç›®åŸºäº nRF5340 ç³»ç»Ÿçº§èŠ¯ç‰‡æ„å»ºï¼Œé›†æˆäº†å²æ— å‰ä¾‹çš„é«˜ç²¾åº¦ä¼ æ„Ÿå™¨é˜µåˆ—ï¼Œä¸ºå¯ç©¿æˆ´æŠ€æœ¯é‡æ–°å®šä¹‰äº†å¯èƒ½æ€§ã€‚OpenEarable ä¸“ä¸ºå¼€å‘å’Œç ”ç©¶åº”ç”¨è€Œè®¾è®¡ï¼Œå…·æœ‰æ¨¡å—åŒ–ã€å¯é‡æ„çš„ç‰¹ç‚¹ï¼Œé¢å‘æœªæ¥ã€‚ ### å¼€å‘æ¶æ„è¯´æ˜ !!! note \"é‡è¦ç†è§£\" OpenEarable é¡¹ç›®é‡‡ç”¨äº†åŸºäº Nordic nRF5340 Audio DK çš„å¼€å‘æ¨¡å¼ï¼š **åŸºç¡€å¹³å°**: å¤ç”¨äº† nRF5340 Audio DK çš„éŸ³é¢‘å¤„ç†å›ºä»¶å’Œåè®®æ ˆ **ç¡¬ä»¶å®šåˆ¶**: åœ¨è‡ªå®šä¹‰çš„ OpenEarable v2 PCB ä¸Šå®ç° **åŠŸèƒ½æ‰©å±•**: åœ¨æˆç†ŸéŸ³é¢‘åŠŸèƒ½åŸºç¡€ä¸Šï¼Œæ·»åŠ äº†ä¸°å¯Œçš„ä¼ æ„Ÿå™¨é›†æˆå’ŒAIå¤„ç†èƒ½åŠ› è¿™ç§å¼€å‘æ¨¡å¼çš„ä¼˜åŠ¿æ˜¯èƒ½å¤Ÿå¿«é€Ÿè·å¾—ç¨³å®šçš„éŸ³é¢‘å¤„ç†èƒ½åŠ›ï¼ŒåŒæ—¶ä¸“æ³¨äºä¼ æ„Ÿå™¨æ•°æ®å¤„ç†å’Œåº”ç”¨å±‚åˆ›æ–°ã€‚ ## ç¡¬ä»¶æ¶æ„ ### æ ¸å¿ƒç¡¬ä»¶ **ä¸»æ§èŠ¯ç‰‡**: nRF5340 åŒæ ¸å¤„ç†å™¨ åº”ç”¨æ ¸å¿ƒï¼šè¿è¡Œ Bluetooth LE ä¸»æœºå’Œåº”ç”¨å±‚ ç½‘ç»œæ ¸å¿ƒï¼šè¿è¡Œ SoftDevice æ§åˆ¶å™¨ **å‚è€ƒå¼€å‘æ¿**: nRF5340 Audio DK (PCA10121) ç”¨äºå›ºä»¶å¼€å‘å’ŒéªŒè¯ **ç›®æ ‡ç¡¬ä»¶**: OpenEarable v2 è‡ªå®šä¹‰PCB æœ€ç»ˆäº§å“ç¡¬ä»¶ **éŸ³é¢‘ç¼–è§£ç å™¨**: ADAU1860 ç¡¬ä»¶ç¼–è§£ç å™¨ **ä¼ æ„Ÿå™¨**: é›†æˆå¤šç§é«˜ç²¾åº¦ä¼ æ„Ÿå™¨ï¼ˆè¿™æ˜¯ç›¸å¯¹äºæ ‡å‡†Audio DKçš„ä¸»è¦æ‰©å±•ï¼‰ ### ç¡¬ä»¶å¼€å‘ç­–ç•¥ é¡¹ç›®é‡‡ç”¨\"å‚è€ƒè®¾è®¡ â†’ è‡ªå®šä¹‰ç¡¬ä»¶\"çš„å¼€å‘æ¨¡å¼ï¼š 1. **ç¬¬ä¸€é˜¶æ®µ**: åœ¨ nRF5340 Audio DK ä¸Šå¼€å‘å’ŒéªŒè¯éŸ³é¢‘åŠŸèƒ½ 2. **ç¬¬äºŒé˜¶æ®µ**: è®¾è®¡ OpenEarable v2 è‡ªå®šä¹‰PCBï¼Œå¢åŠ ä¼ æ„Ÿå™¨é˜µåˆ— 3. **ç¬¬ä¸‰é˜¶æ®µ**: å°†åœ¨DKä¸ŠéªŒè¯çš„å›ºä»¶é€‚é…åˆ°è‡ªå®šä¹‰ç¡¬ä»¶ !!! info \"å…³é”®åŒºåˆ«\" **nRF5340 Audio DK**: æ ‡å‡†éŸ³é¢‘å¼€å‘æ¿ï¼Œä¸»è¦ç”¨äºéŸ³é¢‘åº”ç”¨å¼€å‘ **OpenEarable v2**: è‡ªå®šä¹‰ç¡¬ä»¶ï¼Œåœ¨éŸ³é¢‘åŠŸèƒ½åŸºç¡€ä¸Šé›†æˆäº†ä¸°å¯Œçš„ä¼ æ„Ÿå™¨ ### æ”¯æŒçš„éŸ³é¢‘æ¨¡å¼ 1. **Connected Isochronous Stream (CIS)** å•æ’­æ¨¡å¼ åŒå‘é€šä¿¡åè®® æ”¯æŒç«‹ä½“å£°åŒæ­¥æ’­æ”¾ ç½‘å…³åˆ°è€³æœºçš„è¿æ¥éŸ³é¢‘æµ 2. **Broadcast Isochronous Stream (BIS)** å¹¿æ’­æ¨¡å¼ å•å‘é€šä¿¡åè®® æ”¯æŒ Auracastâ„¢ å¹¿æ’­ æ— é™åˆ¶æ¥æ”¶å™¨æ•°é‡ ## è½¯ä»¶æ¶æ„ ### å›ºä»¶æ¶æ„ åŸºäº Zephyr RTOS çš„æ¨¡å—åŒ–æ¶æ„ï¼š ``` â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ åº”ç”¨å±‚ (Application Layer) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ å•æ’­æœåŠ¡å™¨ â”‚ å¹¿æ’­æ¥æ”¶å™¨ â”‚ ä¼ æ„Ÿå™¨ç®¡ç† â”‚ AIæ¨ç† â”‚ â”‚ (Unicast) â”‚ (Broadcast) â”‚ (Sensors) â”‚ (EdgeML) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ ä¸­é—´ä»¶å±‚ (Middleware) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ éŸ³é¢‘å¤„ç† â”‚ è“ç‰™åè®®æ ˆ â”‚ ä¼ æ„Ÿå™¨èåˆ â”‚ æ•°æ®å­˜å‚¨ â”‚ â”‚ (Audio) â”‚ (Bluetooth) â”‚ (Fusion) â”‚ (Storage) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ é©±åŠ¨å±‚ (Driver Layer) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ ADAU1860 â”‚ IMUä¼ æ„Ÿå™¨ â”‚ I2C/SPI â”‚ GPIOæ§åˆ¶ â”‚ â”‚ (Codec) â”‚ (Sensors) â”‚ (Comm) â”‚ (Control) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ ç¡¬ä»¶æŠ½è±¡å±‚ (HAL) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Zephyr RTOS â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ``` ### å…³é”®è½¯ä»¶ç»„ä»¶ #### éŸ³é¢‘å¤„ç†ç³»ç»Ÿ **LE Audio åè®®æ ˆ**: å®Œæ•´çš„ Bluetooth LE Audio å®ç° **æµæ§åˆ¶**: éŸ³é¢‘æµçš„å¯åŠ¨ã€åœæ­¢ã€åŒæ­¥æ§åˆ¶ **ç¼–è§£ç å¤„ç†**: ç¡¬ä»¶åŠ é€Ÿçš„éŸ³é¢‘ç¼–è§£ç  **è´¨é‡æ§åˆ¶**: è‡ªé€‚åº”éŸ³é¢‘è´¨é‡å’Œé”™è¯¯æ¢å¤ #### ä¼ æ„Ÿå™¨ç®¡ç†ç³»ç»Ÿ **å¤šä¼ æ„Ÿå™¨èåˆ**: IMUã€ç¯å¢ƒä¼ æ„Ÿå™¨ã€ç”Ÿç‰©ä¼ æ„Ÿå™¨ **å®æ—¶å¤„ç†**: é«˜é¢‘æ•°æ®é‡‡é›†å’Œå¤„ç† **AIæ¨ç†**: è¾¹ç¼˜æœºå™¨å­¦ä¹ æ¨¡å‹æ¨ç† **æ•°æ®å­˜å‚¨**: é«˜æ•ˆçš„æ•°æ®è®°å½•å’Œç®¡ç† #### é€šä¿¡ç³»ç»Ÿ **GATTæœåŠ¡**: æ ‡å‡†åŒ–çš„è®¾å¤‡ä¿¡æ¯å’Œä¼ æ„Ÿå™¨æ•°æ®æœåŠ¡ **æ•°æ®åŒæ­¥**: å®æ—¶æ•°æ®ä¼ è¾“å’ŒåŒæ­¥ **è¿æ¥ç®¡ç†**: å¤šè®¾å¤‡è¿æ¥å’ŒçŠ¶æ€ç®¡ç† ## ä¸»è¦åŠŸèƒ½ç‰¹æ€§ ### ğŸµ éŸ³é¢‘åŠŸèƒ½ **LE Audio æ”¯æŒ**: å®Œæ•´çš„ Bluetooth LE Audio åè®®æ ˆ **ç«‹ä½“å£°æ’­æ”¾**: å·¦å³å£°é“åŒæ­¥æ’­æ”¾ **åŒå‘é€šä¿¡**: æ”¯æŒè¯­éŸ³é€šè¯å’ŒéŸ³é¢‘ä¼ è¾“ **ä½å»¶è¿Ÿ**: ä¼˜åŒ–çš„éŸ³é¢‘å»¶è¿Ÿæ§åˆ¶ **é«˜éŸ³è´¨**: ç¡¬ä»¶åŠ é€Ÿçš„éŸ³é¢‘å¤„ç† ### ğŸ“¡ ä¼ æ„Ÿå™¨åŠŸèƒ½ **å¤šä¼ æ„Ÿå™¨èåˆ**: é›†æˆå¤šç§é«˜ç²¾åº¦ä¼ æ„Ÿå™¨ **å®æ—¶æ•°æ®å¤„ç†**: é«˜é¢‘ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›† **AIè¾¹ç¼˜æ¨ç†**: æœ¬åœ°æœºå™¨å­¦ä¹ æ¨¡å‹æ¨ç† **æ•°æ®å­˜å‚¨**: æ”¯æŒ SD å¡æ•°æ®è®°å½• **ä½åŠŸè€—è®¾è®¡**: ä¼˜åŒ–çš„ä¼ æ„Ÿå™¨åŠŸè€—ç®¡ç† ### ğŸ”— è¿æ¥åŠŸèƒ½ **è“ç‰™ 5.3**: æœ€æ–°çš„è“ç‰™æ ‡å‡†æ”¯æŒ **å¤šè®¾å¤‡è¿æ¥**: æ”¯æŒåŒæ—¶è¿æ¥å¤šä¸ªè®¾å¤‡ **è‡ªåŠ¨é‡è¿**: æ™ºèƒ½çš„è¿æ¥æ¢å¤æœºåˆ¶ **æ•°æ®åŒæ­¥**: å®æ—¶ä¼ æ„Ÿå™¨æ•°æ®ä¼ è¾“ ### âš¡ ç”µæºç®¡ç† **ç”µæ± ç›‘æ§**: å®æ—¶ç”µæ± çŠ¶æ€ç›‘æµ‹ **å……ç”µç®¡ç†**: æ™ºèƒ½å……ç”µæ§åˆ¶ **åŠŸè€—ä¼˜åŒ–**: å¤šçº§åŠŸè€—ç®¡ç†ç­–ç•¥ **ä½ç”µé‡ä¿æŠ¤**: è‡ªåŠ¨ä½åŠŸè€—æ¨¡å¼ ## å¼€å‘ç¯å¢ƒ ### å¿…éœ€å·¥å…· **nRF Connect SDK**: Nordic å®˜æ–¹å¼€å‘å¥—ä»¶ **Zephyr RTOS**: å®æ—¶æ“ä½œç³»ç»Ÿ **Westå·¥å…·**: é¡¹ç›®ç®¡ç†å’Œæ„å»ºå·¥å…· **Python 3.7+**: æ„å»ºè„šæœ¬å’Œå·¥å…·é“¾ **CMake**: æ„å»ºç³»ç»Ÿ **Git**: ç‰ˆæœ¬æ§åˆ¶ ### æ”¯æŒçš„å¼€å‘ç¯å¢ƒ **VS Code**: æ¨èçš„é›†æˆå¼€å‘ç¯å¢ƒ **JLinkè°ƒè¯•å™¨**: ç¡¬ä»¶è°ƒè¯•æ”¯æŒ **ä¸²å£ç»ˆç«¯**: æ—¥å¿—è¾“å‡ºå’Œè°ƒè¯• **nRF Connect**: è“ç‰™æµ‹è¯•å’Œè°ƒè¯•å·¥å…· ### æ„å»ºé…ç½® é¡¹ç›®æ”¯æŒå¤šç§æ„å»ºé…ç½®ï¼š ```bash # å•æ’­æœåŠ¡å™¨æ¨¡å¼ï¼ˆé»˜è®¤ï¼‰ west build b nrf5340_audio_dk_nrf5340_cpuapp # å¹¿æ’­æ¥æ”¶å™¨æ¨¡å¼ west build b nrf5340_audio_dk_nrf5340_cpuapp DCONFIG_AUDIO_SINK y # è°ƒè¯•ç‰ˆæœ¬ west build b nrf5340_audio_dk_nrf5340_cpuapp DCONFIG_DEBUG y # å‘å¸ƒç‰ˆæœ¬ west build b nrf5340_audio_dk_nrf5340_cpuapp DCONFIG_RELEASE y ``` ## åº”ç”¨é…ç½® ### éŸ³é¢‘é…ç½® é¡¹ç›®æ”¯æŒå¤šç§éŸ³é¢‘é…ç½®æ¨¡å¼ï¼š ```c // åœ¨ prj.conf ä¸­é…ç½® CONFIG_AUDIO_SAMPLE_RATE_48000_HZ y CONFIG_AUDIO_BIT_DEPTH_16 y CONFIG_AUDIO_CHANNELS_STEREO y ``` ### ä¼ æ„Ÿå™¨é…ç½® ```c // ä¼ æ„Ÿå™¨é‡‡æ ·é…ç½® CONFIG_SENSOR_IMU_SAMPLE_RATE 100 CONFIG_SENSOR_PPG_SAMPLE_RATE 25 CONFIG_SENSOR_TEMPERATURE_SAMPLE_RATE 1 ``` ### è“ç‰™é…ç½® ```c // è“ç‰™ LE Audio é…ç½® CONFIG_BT_AUDIO y CONFIG_BT_BAP_UNICAST_SERVER y CONFIG_BT_BAP_BROADCAST_SINK y ``` ## ç”¨æˆ·ç•Œé¢ ### LEDçŠ¶æ€æŒ‡ç¤º è®¾å¤‡é€šè¿‡ RGB LED æä¾›ä¸°å¯Œçš„çŠ¶æ€åé¦ˆï¼š çŠ¶æ€ LED é¢œè‰² è¯´æ˜ å¯åŠ¨ä¸­ ç™½è‰²é—ªçƒ ç³»ç»Ÿæ­£åœ¨å¯åŠ¨ ç­‰å¾…é…å¯¹ è“è‰²é—ªçƒ ç­‰å¾…è“ç‰™é…å¯¹ å·²è¿æ¥ é’è‰²å¸¸äº® è“ç‰™å·²è¿æ¥ éŸ³é¢‘æ’­æ”¾ ç»¿è‰²å‘¼å¸ æ­£åœ¨æ’­æ”¾éŸ³é¢‘ å……ç”µä¸­ çº¢è‰²å¸¸äº® ç”µæ± æ­£åœ¨å……ç”µ å……ç”µå®Œæˆ ç»¿è‰²å¸¸äº® ç”µæ± å……ç”µå®Œæˆ ä½ç”µé‡ çº¢è‰²é—ªçƒ ç”µæ± ç”µé‡ä¸è¶³ é”™è¯¯çŠ¶æ€ çº¢è‰²å¿«é—ª ç³»ç»Ÿé”™è¯¯ ### æŒ‰é”®æ§åˆ¶ **å•å‡»**: æ’­æ”¾/æš‚åœéŸ³é¢‘ **åŒå‡»**: æ¥å¬/æŒ‚æ–­ç”µè¯ **é•¿æŒ‰**: è¿›å…¥é…å¯¹æ¨¡å¼ **è¶…é•¿æŒ‰**: è®¾å¤‡é‡å¯ ### ç§»åŠ¨åº”ç”¨æ”¯æŒ OpenEarable é…å¥—ç§»åŠ¨åº”ç”¨åŠŸèƒ½ï¼š **éŸ³é¢‘æ§åˆ¶**: éŸ³é‡ã€å‡è¡¡å™¨ã€éŸ³æ•ˆè®¾ç½® **ä¼ æ„Ÿå™¨ç›‘æ§**: å®æ—¶ä¼ æ„Ÿå™¨æ•°æ®æ˜¾ç¤º **å¥åº·åˆ†æ**: åŸºäºä¼ æ„Ÿå™¨æ•°æ®çš„å¥åº·æŒ‡æ ‡ **è®¾å¤‡ç®¡ç†**: å›ºä»¶æ›´æ–°ã€è®¾ç½®åŒæ­¥ **æ•°æ®å¯¼å‡º**: ä¼ æ„Ÿå™¨æ•°æ®å¯¼å‡ºå’Œåˆ†æ ## æ„å»ºå’Œçƒ§å½• ### ç¯å¢ƒå‡†å¤‡ ```bash # 1. å®‰è£… nRF Connect SDK # 2. è®¾ç½®ç¯å¢ƒå˜é‡ export ZEPHYR_BASE path/to/zephyr export ZEPHYR_SDK_INSTALL_DIR path/to/zephyr sdk # 3. å®‰è£… Python ä¾èµ– pip install r requirements.txt ``` ### æ„å»ºæµç¨‹ ```bash # 1. åˆå§‹åŒ–é¡¹ç›® west init m https://github.com/OpenEarable/open earable 2.git west update # 2. æ„å»ºå›ºä»¶ cd open earable 2 west build b nrf5340_audio_dk_nrf5340_cpuapp # 3. çƒ§å½•å›ºä»¶ west flash # 4. æŸ¥çœ‹æ—¥å¿— west attach ``` ### è°ƒè¯•æ”¯æŒ ```bash # GDB è°ƒè¯• west debug # RTT æ—¥å¿—è¾“å‡º west attach # æ€§èƒ½åˆ†æ west build DCONFIG_PROFILING y ``` ## é¡¹ç›®æ–‡æ¡£ç»“æ„ æœ¬é¡¹ç›®çš„å®Œæ•´æŠ€æœ¯æ–‡æ¡£åŒ…æ‹¬ï¼š ### ğŸ“– æ ¸å¿ƒæ–‡æ¡£ **[é¡¹ç›®æ€»ç»“](index.html)**: é¡¹ç›®æ¦‚è§ˆå’Œå¿«é€Ÿå…¥é—¨ **[æ¶æ„åˆ†æ](architecture.html)**: è¯¦ç»†çš„ç³»ç»Ÿæ¶æ„åˆ†æ **[éƒ¨ç½²æŒ‡å—](deployment.html)**: æ„å»ºã€çƒ§å½•å’Œéƒ¨ç½²æŒ‡å— ### ğŸ”§ æ¨¡å—æ–‡æ¡£ **[ç”µæºç®¡ç†æ¨¡å—](/modules/battery module.md)**: ç”µæ± å’Œå……ç”µç®¡ç† **[éŸ³é¢‘å¤„ç†æ¨¡å—](/modules/audio module.md)**: éŸ³é¢‘é‡‡é›†å’Œå¤„ç† **[ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—](/modules/sensor module.md)**: å¤šä¼ æ„Ÿå™¨èåˆ **[è“ç‰™é€šä¿¡æ¨¡å—](/modules/bluetooth module.md)**: è“ç‰™åè®®å’ŒæœåŠ¡ **[æ•°æ®å­˜å‚¨æ¨¡å—](/modules/storage module.md)**: æ•°æ®è®°å½•å’Œç®¡ç† **[ç¡¬ä»¶é©±åŠ¨æ¨¡å—](/modules/drivers module.md)**: åº•å±‚ç¡¬ä»¶é©±åŠ¨ ### ğŸ› ï¸ å¼€å‘æ–‡æ¡£ **API å‚è€ƒ**: è¯¦ç»†çš„ API æ–‡æ¡£ **ç¤ºä¾‹ä»£ç **: å¸¸ç”¨åŠŸèƒ½çš„ç¤ºä¾‹å®ç° **æ•…éšœæ’é™¤**: å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ **è´¡çŒ®æŒ‡å—**: å¼€æºè´¡çŒ®æµç¨‹ ## å¼€æºç¤¾åŒº ### é¡¹ç›®é“¾æ¥ **GitHub ä»“åº“**: https://github.com/OpenEarable/open earable 2 **å®˜æ–¹ç½‘ç«™**: https://open earable.teco.edu/ **æ–‡æ¡£ç½‘ç«™**: https://docs.open earable.teco.edu/ **ç¤¾åŒºè®ºå›**: https://community.open earable.teco.edu/ ### è®¸å¯è¯ é¡¹ç›®é‡‡ç”¨ MIT è®¸å¯è¯ï¼Œå…è®¸è‡ªç”±ä½¿ç”¨ã€ä¿®æ”¹å’Œåˆ†å‘ã€‚ ### è´¡çŒ®æ–¹å¼ æ¬¢è¿ç¤¾åŒºè´¡çŒ®ï¼š **Bug æŠ¥å‘Š**: åœ¨ GitHub Issues ä¸­æŠ¥å‘Šé—®é¢˜ **åŠŸèƒ½è¯·æ±‚**: æå‡ºæ–°åŠŸèƒ½å»ºè®® **ä»£ç è´¡çŒ®**: æäº¤ Pull Request **æ–‡æ¡£æ”¹è¿›**: å®Œå–„é¡¹ç›®æ–‡æ¡£ **æµ‹è¯•åé¦ˆ**: æä¾›æµ‹è¯•ç»“æœå’Œåé¦ˆ OpenEarable 2.0 ä»£è¡¨äº†å¯ç©¿æˆ´æŠ€æœ¯çš„æœªæ¥ï¼Œç»“åˆäº†å…ˆè¿›çš„éŸ³é¢‘å¤„ç†ã€ä¸°å¯Œçš„ä¼ æ„Ÿå™¨é›†æˆå’Œå¼ºå¤§çš„AIèƒ½åŠ›ã€‚é€šè¿‡å¼€æºçš„æ–¹å¼ï¼Œæˆ‘ä»¬è‡´åŠ›äºæ¨åŠ¨æ•´ä¸ªè¡Œä¸šçš„åˆ›æ–°å’Œå‘å±•ã€‚"},"/lhfdoc.github.io/embedded_dev/openearable/sensor-module.html":{"title":"ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—è¯¦ç»†åˆ†æ","content":"# ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—è¯¦ç»†åˆ†æ ## æ¨¡å—æ¦‚è¿° ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—æ˜¯OpenEarable 2.0çš„æ ¸å¿ƒåˆ›æ–°ç»„ä»¶ï¼Œè´Ÿè´£ç®¡ç†é›†æˆçš„å¤šç§é«˜ç²¾åº¦ä¼ æ„Ÿå™¨ï¼ŒåŒ…æ‹¬IMUã€PPGã€æ¸©åº¦ã€æ°”å‹ã€éº¦å…‹é£ç­‰ä¼ æ„Ÿå™¨ã€‚è¯¥æ¨¡å—æä¾›ç»Ÿä¸€çš„ä¼ æ„Ÿå™¨æ¥å£ã€æ•°æ®é‡‡é›†ã€å¤„ç†å’Œä¼ è¾“åŠŸèƒ½ï¼Œæ˜¯OpenEarableåŒºåˆ«äºæ™®é€šéŸ³é¢‘è®¾å¤‡çš„å…³é”®ç‰¹æ€§ã€‚ ## æ–‡ä»¶ç»“æ„ ``` src/SensorManager/ â”œâ”€â”€ SensorManager.h/.cpp # ä¼ æ„Ÿå™¨ç®¡ç†å™¨æ ¸å¿ƒ â”œâ”€â”€ EdgeMLSensor.h/.cpp # ä¼ æ„Ÿå™¨åŸºç±»å®šä¹‰ â”œâ”€â”€ IMU.h/.cpp # æƒ¯æ€§æµ‹é‡å•å…ƒä¼ æ„Ÿå™¨ â”œâ”€â”€ PPG.h/.cpp # å…‰ç”µå®¹ç§¯è„‰ææ³¢ä¼ æ„Ÿå™¨ â”œâ”€â”€ Baro.h/.cpp # æ°”å‹ä¼ æ„Ÿå™¨ â”œâ”€â”€ Temp.h/.cpp # æ¸©åº¦ä¼ æ„Ÿå™¨ â”œâ”€â”€ BoneConduction.h/.cpp # éª¨ä¼ å¯¼ä¼ æ„Ÿå™¨ â”œâ”€â”€ Microphone.h/.cpp # éº¦å…‹é£ä¼ æ„Ÿå™¨ â”œâ”€â”€ BMX160/ # BMX160 IMUé©±åŠ¨ â”œâ”€â”€ MAXM86161/ # MAXM86161 PPGé©±åŠ¨ â”œâ”€â”€ BMP388/ # BMP388 æ°”å‹è®¡é©±åŠ¨ â”œâ”€â”€ MLX90632/ # MLX90632 çº¢å¤–æ¸©åº¦è®¡é©±åŠ¨ â”œâ”€â”€ BMA580/ # BMA580 åŠ é€Ÿåº¦è®¡é©±åŠ¨ â”œâ”€â”€ CMakeLists.txt # æ„å»ºé…ç½® â””â”€â”€ Kconfig # é…ç½®é€‰é¡¹ ``` ## æ ¸å¿ƒæ¶æ„ ### 1. SensorManager ä¼ æ„Ÿå™¨ç®¡ç†å™¨ SensorManageræ˜¯æ•´ä¸ªä¼ æ„Ÿå™¨ç³»ç»Ÿçš„æ ¸å¿ƒæ§åˆ¶ç»„ä»¶ï¼Œè´Ÿè´£ä¼ æ„Ÿå™¨çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€æ•°æ®æµæ§åˆ¶å’Œç³»ç»Ÿåè°ƒã€‚ #### ä¸»è¦åŠŸèƒ½ **ä¼ æ„Ÿå™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†**: åˆå§‹åŒ–ã€å¯åŠ¨ã€åœæ­¢ä¼ æ„Ÿå™¨ **æ•°æ®æµç®¡ç†**: ä¼ æ„Ÿå™¨æ•°æ®çš„é‡‡é›†ã€ç¼“å†²å’Œåˆ†å‘ **é…ç½®ç®¡ç†**: åŠ¨æ€é…ç½®ä¼ æ„Ÿå™¨å‚æ•° **æ¶ˆæ¯æ€»çº¿é›†æˆ**: é€šè¿‡ZBusä¸å…¶ä»–æ¨¡å—é€šä¿¡ **å­˜å‚¨ç®¡ç†**: æ§åˆ¶æ•°æ®çš„æœ¬åœ°å­˜å‚¨å’Œè“ç‰™ä¼ è¾“ #### æ ¸å¿ƒæ¥å£ ```cpp // ä¼ æ„Ÿå™¨ç®¡ç†å™¨çŠ¶æ€ enum sensor_manager_state { INIT, // åˆå§‹åŒ–çŠ¶æ€ RUNNING, // è¿è¡ŒçŠ¶æ€ SUSPENDED, // æŒ‚èµ·çŠ¶æ€ }; // ä¸»è¦æ§åˆ¶æ¥å£ void init_sensor_manager(); // åˆå§‹åŒ–ä¼ æ„Ÿå™¨ç®¡ç†å™¨ void start_sensor_manager(); // å¯åŠ¨ä¼ æ„Ÿå™¨ç®¡ç†å™¨ void stop_sensor_manager(); // åœæ­¢ä¼ æ„Ÿå™¨ç®¡ç†å™¨ void config_sensor(struct sensor_config *config); // é…ç½®ä¼ æ„Ÿå™¨ enum sensor_manager_state get_state(); // è·å–ç®¡ç†å™¨çŠ¶æ€ ``` #### å·¥ä½œé˜Ÿåˆ—æ¶æ„ ```cpp // ä¼ æ„Ÿå™¨ä¸“ç”¨å·¥ä½œé˜Ÿåˆ— extern struct k_work_q sensor_work_q; // æ¶ˆæ¯é˜Ÿåˆ—å®šä¹‰ K_MSGQ_DEFINE(sensor_queue, sizeof(struct sensor_msg), 256, 4); K_MSGQ_DEFINE(config_queue, sizeof(struct sensor_config), 16, 4); // ZBusé€šé“å®šä¹‰ ZBUS_CHAN_DEFINE(sensor_chan, struct sensor_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY, ZBUS_MSG_INIT(0)); ``` ### 2. EdgeMLSensor ä¼ æ„Ÿå™¨åŸºç±» EdgeMLSensoræ˜¯æ‰€æœ‰ä¼ æ„Ÿå™¨ç±»çš„æŠ½è±¡åŸºç±»ï¼Œå®šä¹‰äº†ç»Ÿä¸€çš„ä¼ æ„Ÿå™¨æ¥å£å’Œè¡Œä¸ºæ¨¡å¼ã€‚ #### è®¾è®¡ç‰¹ç‚¹ **çº¯è™šå‡½æ•°æ¥å£**: å¼ºåˆ¶å­ç±»å®ç°æ ¸å¿ƒåŠŸèƒ½ **ç»Ÿä¸€çš„ç”Ÿå‘½å‘¨æœŸ**: æ ‡å‡†åŒ–çš„åˆå§‹åŒ–ã€å¯åŠ¨ã€åœæ­¢æµç¨‹ **é…ç½®åŒ–é‡‡æ ·ç‡**: æ”¯æŒå¤šæ¡£ä½é‡‡æ ·ç‡é…ç½® **åŒé‡æ•°æ®æµ**: æ”¯æŒSDå¡å­˜å‚¨å’Œè“ç‰™ä¼ è¾“ #### æ ¸å¿ƒæ¥å£ ```cpp template <size_t N> struct SampleRateSetting { uint8_t reg_vals[N]; // å¯„å­˜å™¨é…ç½®å€¼ float sample_rates[N]; // æ ‡ç§°é‡‡æ ·ç‡ float true_sample_rates[N]; // å®é™…é‡‡æ ·ç‡ }; class EdgeMlSensor { public: // çº¯è™šå‡½æ•°æ¥å£ virtual bool init(struct k_msgq *queue) 0; // åˆå§‹åŒ–ä¼ æ„Ÿå™¨ virtual void start(int sample_rate_idx) 0; // å¯åŠ¨ä¼ æ„Ÿå™¨ virtual void stop() 0; // åœæ­¢ä¼ æ„Ÿå™¨ // çŠ¶æ€æŸ¥è¯¢å’Œæ§åˆ¶ bool is_running(); // æ£€æŸ¥è¿è¡ŒçŠ¶æ€ void sd_logging(bool enable); // æ§åˆ¶SDå¡è®°å½• void ble_stream(bool enable); // æ§åˆ¶è“ç‰™æµä¼ è¾“ protected: k_work sensor_work; // ä¼ æ„Ÿå™¨å·¥ä½œé¡¹ k_timer sensor_timer; // ä¼ æ„Ÿå™¨å®šæ—¶å™¨ static k_msgq *sensor_queue; // ä¼ æ„Ÿå™¨æ¶ˆæ¯é˜Ÿåˆ— bool _sd_logging false; // SDå¡è®°å½•æ ‡å¿— bool _ble_stream true; // è“ç‰™ä¼ è¾“æ ‡å¿— bool _running false; // è¿è¡ŒçŠ¶æ€æ ‡å¿— }; ``` ## ä¼ æ„Ÿå™¨å®ç°è¯¦è§£ ### 1. IMU ä¼ æ„Ÿå™¨ (BMX160) IMUä¼ æ„Ÿå™¨åŸºäºBosch BMX160ä¹è½´ä¼ æ„Ÿå™¨ï¼Œæä¾›åŠ é€Ÿåº¦è®¡ã€é™€èºä»ªå’Œç£åŠ›è®¡æ•°æ®ã€‚ #### æŠ€æœ¯è§„æ ¼ **åŠ é€Ÿåº¦è®¡**: Â±2g/Â±4g/Â±8g/Â±16gé‡ç¨‹ï¼Œ14ä½åˆ†è¾¨ç‡ **é™€èºä»ª**: Â±125Â°/såˆ°Â±2000Â°/sé‡ç¨‹ï¼Œ16ä½åˆ†è¾¨ç‡ **ç£åŠ›è®¡**: Â±1300Î¼Té‡ç¨‹ï¼Œé«˜ç²¾åº¦ç£åœºæµ‹é‡ #### é‡‡æ ·ç‡é…ç½® ```cpp class IMU : public EdgeMlSensor { public: const static SampleRateSetting<6> sample_rates; private: static DFRobot_BMX160 imu; // BMX160é©±åŠ¨å®ä¾‹ }; // æ”¯æŒçš„é‡‡æ ·ç‡è®¾ç½® const SampleRateSetting<6> IMU::sample_rates { .reg_vals {0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C}, .sample_rates {25.0, 50.0, 100.0, 200.0, 400.0, 800.0}, .true_sample_rates {25.32, 50.64, 101.28, 202.56, 405.12, 810.24} }; ``` #### æ•°æ®ç»“æ„ ```cpp struct imu_data { float accel_x, accel_y, accel_z; // åŠ é€Ÿåº¦ (m/sÂ²) float gyro_x, gyro_y, gyro_z; // è§’é€Ÿåº¦ (rad/s) float mag_x, mag_y, mag_z; // ç£åœºå¼ºåº¦ (Î¼T) uint64_t timestamp; // æ—¶é—´æˆ³ (Î¼s) } __attribute__((packed)); ``` ### 2. PPG ä¼ æ„Ÿå™¨ (MAXM86161) PPGä¼ æ„Ÿå™¨åŸºäºMaxim MAXM86161å…‰å­¦ä¼ æ„Ÿå™¨ï¼Œç”¨äºå¿ƒç‡ç›‘æµ‹ã€è¡€æ°§æµ‹é‡å’Œç”Ÿç†ä¿¡å·åˆ†æã€‚ #### æŠ€æœ¯è§„æ ¼ **å…‰æº**: çº¢å…‰ã€çº¢å¤–å…‰ã€ç»¿å…‰LED **å…‰ç”µäºŒæç®¡**: é«˜çµæ•åº¦å…‰ç”µæ£€æµ‹å™¨ **é‡‡æ ·ç‡**: æœ€é«˜3200Hz **åˆ†è¾¨ç‡**: 19ä½ADC #### LEDé…ç½® ```cpp enum led_order { red, // çº¢å…‰LED (660nm) green, // ç»¿å…‰LED (537nm) ir, // çº¢å¤–LED (880nm) ambient // ç¯å¢ƒå…‰æ£€æµ‹ }; class PPG : public EdgeMlSensor { public: const static SampleRateSetting<16> sample_rates; private: static MAXM86161 ppg; // MAXM86161é©±åŠ¨å®ä¾‹ ppg_sample data_buffer[64]; // æ•°æ®ç¼“å†²åŒº }; ``` #### æ•°æ®ç»“æ„ ```cpp struct ppg_sample { uint32_t red; // çº¢å…‰é€šé“æ•°æ® uint32_t ir; // çº¢å¤–é€šé“æ•°æ® uint32_t green; // ç»¿å…‰é€šé“æ•°æ® uint32_t ambient; // ç¯å¢ƒå…‰æ•°æ® uint64_t timestamp; // æ—¶é—´æˆ³ } __attribute__((packed)); ``` ### 3. æ¸©åº¦ä¼ æ„Ÿå™¨ (MLX90632) æ¸©åº¦ä¼ æ„Ÿå™¨åŸºäºMelexis MLX90632éæ¥è§¦å¼çº¢å¤–æ¸©åº¦è®¡ï¼Œå¯æµ‹é‡ç‰©ä½“æ¸©åº¦å’Œç¯å¢ƒæ¸©åº¦ã€‚ #### æŠ€æœ¯è§„æ ¼ **æµ‹é‡èŒƒå›´**: 20Â°Cåˆ°85Â°C (ç¯å¢ƒ), 20Â°Cåˆ°200Â°C (ç‰©ä½“) **ç²¾åº¦**: Â±0.2Â°C (å…¸å‹å€¼) **å“åº”æ—¶é—´**: <1ç§’ **æ¥å£**: I2C #### æ•°æ®ç»“æ„ ```cpp struct temp_data { float ambient_temp; // ç¯å¢ƒæ¸©åº¦ (Â°C) float object_temp; // ç‰©ä½“æ¸©åº¦ (Â°C) uint64_t timestamp; // æ—¶é—´æˆ³ } __attribute__((packed)); ``` ### 4. æ°”å‹ä¼ æ„Ÿå™¨ (BMP388) æ°”å‹ä¼ æ„Ÿå™¨åŸºäºBosch BMP388é«˜ç²¾åº¦æ°”å‹è®¡ï¼Œç”¨äºé«˜åº¦æµ‹é‡å’Œç¯å¢ƒç›‘æµ‹ã€‚ #### æŠ€æœ¯è§„æ ¼ **å‹åŠ›èŒƒå›´**: 300 1250 hPa **ç²¾åº¦**: Â±0.08 hPa (å…¸å‹å€¼) **é«˜åº¦åˆ†è¾¨ç‡**: Â±8 cm **æ¸©åº¦è¡¥å¿**: é›†æˆæ¸©åº¦ä¼ æ„Ÿå™¨ #### æ•°æ®ç»“æ„ ```cpp struct baro_data { float pressure; // å¤§æ°”å‹åŠ› (hPa) float temperature; // æ¸©åº¦ (Â°C) float altitude; // æµ·æ‹”é«˜åº¦ (m) uint64_t timestamp; // æ—¶é—´æˆ³ } __attribute__((packed)); ``` ### 5. éª¨ä¼ å¯¼ä¼ æ„Ÿå™¨ éª¨ä¼ å¯¼ä¼ æ„Ÿå™¨é€šè¿‡æ£€æµ‹é¢…éª¨æŒ¯åŠ¨æ¥æ„ŸçŸ¥è¯­éŸ³å’Œå’€åš¼ç­‰ç”Ÿç†æ´»åŠ¨ã€‚ #### å®ç°åŸç† **æŒ¯åŠ¨æ£€æµ‹**: é«˜çµæ•åº¦åŠ é€Ÿåº¦è®¡æ£€æµ‹éª¨ä¼ å¯¼æŒ¯åŠ¨ **ä¿¡å·å¤„ç†**: æ•°å­—æ»¤æ³¢å’Œç‰¹å¾æå– **æ¨¡å¼è¯†åˆ«**: è¯­éŸ³æ´»åŠ¨æ£€æµ‹(VAD) #### æ•°æ®ç»“æ„ ```cpp struct bone_conduction_data { float vibration_x, vibration_y, vibration_z; // ä¸‰è½´æŒ¯åŠ¨æ•°æ® float rms_amplitude; // RMSæŒ¯å¹… bool voice_activity; // è¯­éŸ³æ´»åŠ¨æ ‡å¿— uint64_t timestamp; // æ—¶é—´æˆ³ } __attribute__((packed)); ``` ## æ•°æ®æµæ¶æ„ ### ä¼ æ„Ÿå™¨æ•°æ®æµ ``` [ä¼ æ„Ÿå™¨ç¡¬ä»¶] â†’ [é©±åŠ¨å±‚] â†’ [EdgeMLSensor] â†’ [SensorManager] â†’ [æ•°æ®åˆ†å‘] â†“ [SDå¡å­˜å‚¨] â†“ [è“ç‰™ä¼ è¾“] ``` ### æ¶ˆæ¯é˜Ÿåˆ—ç³»ç»Ÿ ```cpp // ä¼ æ„Ÿå™¨æ¶ˆæ¯ç»“æ„ struct sensor_msg { bool sd; // SDå¡å­˜å‚¨æ ‡å¿— bool stream; // è“ç‰™ä¼ è¾“æ ‡å¿— struct sensor_data data; // ä¼ æ„Ÿå™¨æ•°æ® }; // ä¼ æ„Ÿå™¨æ•°æ®ç»“æ„ struct sensor_data { uint8_t id; // ä¼ æ„Ÿå™¨ID uint8_t size; // æ•°æ®å¤§å° uint64_t time; // æ—¶é—´æˆ³ uint8_t data[36]; // æ•°æ®è½½è· } __attribute__((packed)); ``` ### é…ç½®ç³»ç»Ÿ ```cpp // ä¼ æ„Ÿå™¨é…ç½®ç»“æ„ struct sensor_config { uint8_t sensorId; // ä¼ æ„Ÿå™¨ID uint8_t sampleRateIndex; // é‡‡æ ·ç‡ç´¢å¼• uint8_t storageOptions; // å­˜å‚¨é€‰é¡¹ } __attribute__((packed)); // ä¼ æ„Ÿå™¨IDæšä¸¾ enum sensor_id { ID_IMU 0, // æƒ¯æ€§æµ‹é‡å•å…ƒ ID_TEMP_BARO 1, // æ¸©åº¦æ°”å‹ä¼ æ„Ÿå™¨ ID_MICRO 2, // éº¦å…‹é£ ID_PPG 4, // å…‰ç”µå®¹ç§¯è„‰ææ³¢ ID_PULSOX 5, // è„‰æè¡€æ°§ ID_OPTTEMP 6, // å…‰å­¦æ¸©åº¦è®¡ ID_BONE_CONDUCTION 7, // éª¨ä¼ å¯¼ä¼ æ„Ÿå™¨ }; ``` ## å®šæ—¶å™¨å’Œä¸­æ–­ç³»ç»Ÿ ### å®šæ—¶å™¨é©±åŠ¨çš„æ•°æ®é‡‡é›† ```cpp class IMU : public EdgeMlSensor { private: // å®šæ—¶å™¨ä¸­æ–­å¤„ç†å‡½æ•° static void sensor_timer_handler(struct k_timer *dummy) { k_work_submit_to_queue(&sensor_work_q, &sensor.sensor_work); } // ä¼ æ„Ÿå™¨æ•°æ®æ›´æ–°å·¥ä½œé¡¹ static void update_sensor(struct k_work *work) { // 1. è¯»å–ä¼ æ„Ÿå™¨æ•°æ® bmx160_data_t raw_data; imu.read_sensor_data(&raw_data); // 2. æ•°æ®æ ¼å¼è½¬æ¢ struct sensor_data sensor_data; format_imu_data(&raw_data, &sensor_data); // 3. å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ— struct sensor_msg msg { .sd sensor._sd_logging, .stream sensor._ble_stream, .data sensor_data }; k_msgq_put(&sensor_queue, &msg, K_NO_WAIT); } }; ``` ### ä¸­æ–­é©±åŠ¨çš„äº‹ä»¶æ£€æµ‹ ```cpp // PPGä¼ æ„Ÿå™¨çš„FIFOä¸­æ–­å¤„ç† void ppg_fifo_interrupt_handler() { // 1. è¯»å–FIFOæ•°æ® uint8_t fifo_samples ppg.get_fifo_samples(); for (int i 0; i < fifo_samples; i++) { // 2. å¤„ç†æ¯ä¸ªæ ·æœ¬ ppg_sample sample; ppg.read_fifo_sample(&sample); // 3. è´¨é‡æ£€æŸ¥å’Œå¤„ç† if (is_valid_ppg_sample(&sample)) { process_ppg_data(&sample); } } } ``` ## åŠŸè€—ç®¡ç† ### åŠ¨æ€åŠŸè€—æ§åˆ¶ ```cpp void sensor_power_management() { // æ ¹æ®æ´»è·ƒä¼ æ„Ÿå™¨æ•°é‡è°ƒæ•´åŠŸè€— if (active_sensors 0) { // æ— æ´»è·ƒä¼ æ„Ÿå™¨ï¼Œè¿›å…¥ä½åŠŸè€—æ¨¡å¼ set_sensor_power_mode(POWER_MODE_SLEEP); } else if (active_sensors < 2) { // å°‘é‡ä¼ æ„Ÿå™¨ï¼Œä¸­ç­‰åŠŸè€—æ¨¡å¼ set_sensor_power_mode(POWER_MODE_NORMAL); } else { // å¤šä¼ æ„Ÿå™¨ï¼Œé«˜æ€§èƒ½æ¨¡å¼ set_sensor_power_mode(POWER_MODE_HIGH_PERFORMANCE); } } ``` ### é‡‡æ ·ç‡è‡ªé€‚åº” ```cpp void adaptive_sampling_rate() { // æ ¹æ®ç”µæ± ç”µé‡å’Œæ•°æ®éœ€æ±‚è°ƒæ•´é‡‡æ ·ç‡ uint8_t battery_level get_battery_level(); if (battery_level < 20) { // ä½ç”µé‡æ—¶é™ä½é‡‡æ ·ç‡ reduce_sensor_sampling_rates(); } else if (battery_level > 80) { // ç”µé‡å……è¶³æ—¶æ¢å¤æ­£å¸¸é‡‡æ ·ç‡ restore_sensor_sampling_rates(); } } ``` ## æ•°æ®å¤„ç†å’Œåˆ†æ ### å®æ—¶ä¿¡å·å¤„ç† ```cpp // IMUæ•°æ®çš„è¿åŠ¨æ£€æµ‹ bool detect_motion(imu_data *data) { // è®¡ç®—åŠ é€Ÿåº¦å‘é‡çš„å¹…å€¼ float accel_magnitude sqrt(data >accel_x * data >accel_x + data >accel_y * data >accel_y + data >accel_z * data >accel_z); // åˆ¤æ–­æ˜¯å¦æœ‰æ˜¾è‘—è¿åŠ¨ return (accel_magnitude > MOTION_THRESHOLD); } // PPGæ•°æ®çš„å¿ƒç‡æ£€æµ‹ float calculate_heart_rate(ppg_sample *samples, int count) { // 1. ä¿¡å·é¢„å¤„ç† filter_ppg_signal(samples, count); // 2. å³°å€¼æ£€æµ‹ int peak_count detect_peaks(samples, count); // 3. å¿ƒç‡è®¡ç®— float sampling_period 1.0f / PPG_SAMPLE_RATE; float heart_rate (peak_count * 60.0f) / (count * sampling_period); return heart_rate; } ``` ### ä¼ æ„Ÿå™¨èåˆ ```cpp // å¤šä¼ æ„Ÿå™¨èåˆçš„å§¿æ€ä¼°è®¡ void sensor_fusion_update(imu_data *imu, mag_data *mag) { // 1. åŠ é€Ÿåº¦è®¡å§¿æ€ä¼°è®¡ float accel_roll atan2(imu >accel_y, imu >accel_z); float accel_pitch atan2( imu >accel_x, sqrt(imu >accel_y * imu >accel_y + imu >accel_z * imu >accel_z)); // 2. é™€èºä»ªå§¿æ€ç§¯åˆ† integrate_gyroscope_data(imu); // 3. ç£åŠ›è®¡åèˆªè§’è®¡ç®— float mag_yaw atan2(mag >mag_y, mag >mag_x); // 4. äº’è¡¥æ»¤æ³¢å™¨èåˆ complementary_filter_update(accel_roll, accel_pitch, mag_yaw); } ``` ## æ ¡å‡†å’Œè¡¥å¿ ### ä¼ æ„Ÿå™¨æ ¡å‡† ```cpp // IMUé›¶åæ ¡å‡† void calibrate_imu_bias() { const int calibration_samples 1000; float accel_bias[3] {0, 0, 0}; float gyro_bias[3] {0, 0, 0}; // æ”¶é›†æ ¡å‡†æ•°æ® for (int i 0; i < calibration_samples; i++) { imu_data data; read_imu_data(&data); accel_bias[0] + data.accel_x; accel_bias[1] + data.accel_y; accel_bias[2] + data.accel_z 9.81f; // é‡åŠ›è¡¥å¿ gyro_bias[0] + data.gyro_x; gyro_bias[1] + data.gyro_y; gyro_bias[2] + data.gyro_z; k_sleep(K_MSEC(1)); } // è®¡ç®—å¹³å‡åå·® for (int i 0; i < 3; i++) { accel_bias[i] / calibration_samples; gyro_bias[i] / calibration_samples; } // å­˜å‚¨æ ¡å‡†å‚æ•° store_calibration_data(accel_bias, gyro_bias); } ``` ### æ¸©åº¦è¡¥å¿ ```cpp // PPGæ¸©åº¦è¡¥å¿ void temperature_compensation_ppg(ppg_sample *sample, float temperature) { // åŸºäºæ¸©åº¦çš„å¢ç›Šè¡¥å¿ float temp_coeff 1.0f + (temperature 25.0f) * 0.001f; sample >red (uint32_t)(sample >red * temp_coeff); sample >ir (uint32_t)(sample >ir * temp_coeff); sample >green (uint32_t)(sample >green * temp_coeff); } ``` ## é…ç½®é€‰é¡¹ ### Kconfigé…ç½® ```kconfig # ä¼ æ„Ÿå™¨ç®¡ç†å™¨é…ç½® CONFIG_SENSOR_WORK_QUEUE_STACK_SIZE 2048 CONFIG_SENSOR_WORK_QUEUE_PRIO 5 CONFIG_SENSOR_PUB_STACK_SIZE 1024 CONFIG_SENSOR_PUB_THREAD_PRIO 6 # ä¼ æ„Ÿå™¨ä½¿èƒ½ CONFIG_SENSOR_IMU y CONFIG_SENSOR_PPG y CONFIG_SENSOR_TEMPERATURE y CONFIG_SENSOR_BAROMETER y CONFIG_SENSOR_BONE_CONDUCTION y # é‡‡æ ·ç‡é…ç½® CONFIG_IMU_DEFAULT_SAMPLE_RATE 100 CONFIG_PPG_DEFAULT_SAMPLE_RATE 400 CONFIG_TEMP_DEFAULT_SAMPLE_RATE 10 # æ•°æ®ç¼“å†²é…ç½® CONFIG_SENSOR_QUEUE_SIZE 256 CONFIG_SENSOR_BUFFER_SIZE 64 ``` ## é”™è¯¯å¤„ç†å’Œè¯Šæ–­ ### ä¼ æ„Ÿå™¨å¥åº·ç›‘æ§ ```cpp void sensor_health_check() { // æ£€æŸ¥å„ä¼ æ„Ÿå™¨çŠ¶æ€ for (int id 0; id < NUM_SENSORS; id++) { EdgeMlSensor *sensor get_sensor((sensor_id)id); if (sensor && sensor >is_running()) { // æ£€æŸ¥æ•°æ®æ›´æ–°é¢‘ç‡ if (sensor_data_rate[id] < expected_rate[id] * 0.8f) { LOG_WRN(\"Sensor %d data rate low: %.1f Hz\", id, sensor_data_rate[id]); // å°è¯•é‡å¯ä¼ æ„Ÿå™¨ sensor >stop(); k_sleep(K_MSEC(100)); sensor >start(sensor_config[id].sample_rate_idx); } } } } ``` ### æ•°æ®è´¨é‡æ£€æŸ¥ ```cpp bool validate_sensor_data(struct sensor_data *data) { switch (data >id) { case ID_IMU: return validate_imu_data((imu_data*)data >data); case ID_PPG: return validate_ppg_data((ppg_sample*)data >data); case ID_TEMP_BARO: return validate_temp_baro_data((temp_baro_data*)data >data); default: return true; } } ``` ## æ€»ç»“ ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—æ˜¯OpenEarable 2.0çš„æ ¸å¿ƒåˆ›æ–°ç‰¹æ€§ï¼Œå…·æœ‰ä»¥ä¸‹å…³é”®ä¼˜åŠ¿ï¼š 1. **å¤šä¼ æ„Ÿå™¨é›†æˆ**: æ”¯æŒIMUã€PPGã€æ¸©åº¦ã€æ°”å‹ç­‰å¤šç§ä¼ æ„Ÿå™¨ 2. **ç»Ÿä¸€ç®¡ç†æ¥å£**: é€šè¿‡EdgeMLSensoråŸºç±»æä¾›ç»Ÿä¸€çš„ä¼ æ„Ÿå™¨æ¥å£ 3. **é«˜æ•ˆæ•°æ®æµ**: åŸºäºæ¶ˆæ¯é˜Ÿåˆ—å’ŒZBusçš„é«˜æ•ˆæ•°æ®ä¼ è¾“ 4. **çµæ´»é…ç½®**: æ”¯æŒåŠ¨æ€é…ç½®é‡‡æ ·ç‡å’Œå­˜å‚¨é€‰é¡¹ 5. **å®æ—¶å¤„ç†**: ä½å»¶è¿Ÿçš„æ•°æ®é‡‡é›†å’Œå¤„ç†èƒ½åŠ› 6. **åŠŸè€—ä¼˜åŒ–**: æ™ºèƒ½çš„åŠŸè€—ç®¡ç†å’Œè‡ªé€‚åº”é‡‡æ · 7. **æ•°æ®è´¨é‡**: å®Œå–„çš„æ ¡å‡†ã€è¡¥å¿å’Œè´¨é‡æ£€æŸ¥æœºåˆ¶ 8. **æ¨¡å—åŒ–è®¾è®¡**: æ˜“äºæ‰©å±•æ–°çš„ä¼ æ„Ÿå™¨ç±»å‹ è¯¥æ¨¡å—ä¸ºOpenEarable 2.0æä¾›äº†å¼ºå¤§çš„ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†å’Œå¤„ç†èƒ½åŠ›ï¼Œæ”¯æŒå„ç§ç”Ÿç†ç›‘æµ‹ã€è¿åŠ¨è¿½è¸ªå’Œç¯å¢ƒæ„ŸçŸ¥åº”ç”¨ï¼Œæ˜¯å®ç°æ™ºèƒ½è€³æˆ´å¼è®¾å¤‡åŠŸèƒ½çš„æ ¸å¿ƒåŸºç¡€ã€‚"}}