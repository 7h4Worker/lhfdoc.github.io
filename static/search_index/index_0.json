{"/lhfdoc.github.io/embedded_dev/index.html":{"title":"嵌入式开发","content":" title: 嵌入式开发 keywords: 嵌入式, 开发, 单片机, RTOS, 硬件 desc: 嵌入式系统开发相关技术文档和项目分析 # 🔧 嵌入式开发 记录嵌入式系统开发中的技术研究、项目分析和实践经验。 ## 📚 内容分类 ### 🚀 开源项目分析 深入分析优秀的开源嵌入式项目，学习先进的架构设计和编程技巧。 #### Nordic nRF5340 系列 **[OpenEarable 2.0](./opensource_projects/nordic_nrf5340/)** 开源智能耳戴设备完整分析 音频处理和传感器融合技术 Bluetooth LE Audio 协议栈实现 ### 💻 硬件平台 **Nordic nRF系列** 低功耗蓝牙和Thread网络 **ESP32系列** WiFi和蓝牙双模芯片 **STM32系列** ARM Cortex M微控制器 ### ⚙️ 实时操作系统 **Zephyr RTOS** 可扩展的实时操作系统 **FreeRTOS** 市场领先的RTOS内核 **RT Thread** 国产物联网操作系统 ### 🔗 通信协议 **蓝牙协议** 经典蓝牙和低功耗蓝牙 **WiFi协议** 802.11系列无线通信 **LoRa/LoRaWAN** 长距离低功耗通信 ### 🛠️ 开发工具 **IDE环境** VS Code, Keil, IAR等 **调试工具** J Link, ST Link等 **仿真平台** QEMU, Renode等 <div style \"background: linear gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border radius: 10px; margin top: 30px;\"> <h3 style \"color: white; margin top: 0;\">💡 学习路径建议</h3> <p>1. <strong>基础理论</strong> 掌握嵌入式系统基本概念和硬件原理</p> <p>2. <strong>开发环境</strong> 熟悉主流开发工具和调试方法</p> <p>3. <strong>实时系统</strong> 学习RTOS的使用和任务调度机制</p> <p>4. <strong>项目实践</strong> 通过实际项目加深理解和应用</p> <p>5. <strong>优化进阶</strong> 学习性能优化和低功耗设计技巧</p> </div>"},"/lhfdoc.github.io/embedded_dev/openearable/utils-module.html":{"title":"OpenEarable 2.0 - 系统工具模块 (Utils Module)","content":"# OpenEarable 2.0 系统工具模块 (Utils Module) ## 概述 系统工具模块提供了OpenEarable设备的各种辅助功能和系统级工具，包括状态指示、板级支持、版本管理、错误处理等核心系统功能。该模块为整个系统提供了基础的支撑服务。 ## 核心组件 ### 1. 状态指示器 (`StateIndicator.h/cpp`) 负责通过LED显示设备的各种状态： #### 核心类定义 ```cpp class StateIndicator { public: void init(struct earable_state state); void set_state(struct earable_state state); void set_charging_state(enum charging_state state); void set_pairing_state(enum pairing_state state); void set_indication_mode(enum led_mode state); void set_custom_color(const RGBColor &color); private: earable_state _state; RGBColor color; }; extern StateIndicator state_indicator; ``` #### 预定义颜色 ```cpp static const RGBColor LED_OFF {0, 0, 0}; static const RGBColor LED_RED {32, 0, 0}; static const RGBColor LED_GREEN {0, 32, 0}; static const RGBColor LED_BLUE {0, 0, 32}; static const RGBColor LED_YELLOW {16, 16, 0}; static const RGBColor LED_ORANGE {24, 8, 0}; static const RGBColor LED_CYAN {0, 16, 16}; static const RGBColor LED_MAGENTA {16, 0, 16}; ``` #### 状态映射 **充电状态**: 红色（充电中）、绿色（充电完成） **配对状态**: 蓝色（配对模式）、青色（已连接） **系统状态**: 不同颜色组合表示各种工作模式 **自定义模式**: 支持用户定义颜色 ### 2. 板级支持 #### nRF5340开发板支持 (`nrf5340_audio_dk.h/c`) ```cpp // 板级初始化 int board_init(void); // 硬件配置 void configure_board_peripherals(void); // 电源管理 void board_power_management_init(void); ``` #### OpenEarable板级支持 (`openearable.h/c`) ```cpp // OpenEarable特定初始化 int openearable_board_init(void); // 硬件抽象层 void openearable_configure_peripherals(void); // 板级电源控制 void openearable_power_control(void); ``` ### 3. 版本管理 (`board_version.h/c`) 提供硬件版本检测和管理： ```cpp // 版本检测 enum board_version { BOARD_VERSION_UNKNOWN, BOARD_VERSION_1_0, BOARD_VERSION_2_0, BOARD_VERSION_2_1 }; // 核心接口 enum board_version get_board_version(void); const char* get_board_version_string(void); bool is_board_version_supported(enum board_version version); ``` #### 版本检测机制 通过GPIO引脚状态检测硬件版本 支持多种版本的兼容性处理 版本信息用于功能适配 ### 4. 通道分配 (`channel_assignment.h/c`) 管理音频通道和数据流的分配： ```cpp // 通道分配结构 struct channel_assignment { uint8_t left_channel; uint8_t right_channel; uint8_t stream_id; }; // 核心接口 int channel_assignment_init(void); int assign_audio_channel(uint8_t stream_id, uint8_t* left, uint8_t* right); int release_audio_channel(uint8_t stream_id); ``` ### 5. 固件信息 (`fw_info_app.h`) 提供固件版本和构建信息： ```cpp // 固件信息结构 struct fw_info { uint32_t version_major; uint32_t version_minor; uint32_t version_patch; char build_date[16]; char build_time[16]; char git_commit[8]; }; // 接口函数 const struct fw_info* get_fw_info(void); void print_fw_info(void); ``` ### 6. 错误处理 (`error_handler.c`) 系统错误处理和恢复机制： ```cpp // 错误类型定义 enum error_type { ERROR_HARDWARE, ERROR_MEMORY, ERROR_COMMUNICATION, ERROR_CONFIGURATION, ERROR_TIMEOUT }; // 错误处理函数 void handle_error(enum error_type type, int error_code); void register_error_callback(void (*callback)(enum error_type, int)); void system_recovery(void); ``` ### 7. UICR管理 (`uicr.h/c`) 用户信息配置寄存器(UICR)管理： ```cpp // UICR配置 struct uicr_config { uint32_t device_id; uint32_t hw_version; uint32_t production_date; uint8_t calibration_data[32]; }; // 接口函数 int uicr_init(void); int uicr_read_config(struct uicr_config* config); int uicr_write_config(const struct uicr_config* config); bool uicr_is_programmed(void); ``` ## 宏定义工具 (`macros/`) ### 通用宏定义 ```cpp // 位操作宏 #define BIT_SET(val, bit) ((val) (1U << (bit))) #define BIT_CLEAR(val, bit) ((val) & ~(1U << (bit))) #define BIT_CHECK(val, bit) (((val) >> (bit)) & 1U) // 数组操作宏 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0])) // 数学宏 #define MIN(a, b) (((a) < (b)) ? (a) : (b)) #define MAX(a, b) (((a) > (b)) ? (a) : (b)) #define CLAMP(val, min, max) MIN(MAX(val, min), max) ``` ### 调试宏 ```cpp #ifdef CONFIG_DEBUG #define DEBUG_PRINT(fmt, ...) printk(fmt, ##__VA_ARGS__) #define ASSERT(expr) do { \\ if (!(expr)) { \\ printk(\"ASSERT failed: %s:%d\\n\", __FILE__, __LINE__); \\ k_panic(); \\ } \\ } while(0) #else #define DEBUG_PRINT(fmt, ...) #define ASSERT(expr) #endif ``` ## 状态指示逻辑 ### 1. 启动状态指示 ```cpp void indicate_boot_status(void) { // 白色闪烁 系统启动 state_indicator.set_custom_color({16, 16, 16}); k_sleep(K_MSEC(500)); state_indicator.set_custom_color(LED_OFF); } ``` ### 2. 电池状态指示 ```cpp void indicate_battery_status(uint8_t level) { if (level > 80) { state_indicator.set_custom_color(LED_GREEN); // 电量充足 } else if (level > 30) { state_indicator.set_custom_color(LED_YELLOW); // 电量中等 } else if (level > 10) { state_indicator.set_custom_color(LED_ORANGE); // 电量较低 } else { state_indicator.set_custom_color(LED_RED); // 电量极低 } } ``` ### 3. 连接状态指示 ```cpp void indicate_connection_status(bool connected) { if (connected) { state_indicator.set_custom_color(LED_CYAN); // 已连接 } else { state_indicator.set_custom_color(LED_BLUE); // 等待连接 } } ``` ## 系统初始化流程 ### 1. 板级初始化 ```cpp int system_init(void) { int ret; // 1. 基础板级初始化 ret board_init(); if (ret) return ret; // 2. 版本检测 enum board_version version get_board_version(); LOG_INF(\"Board version: %s\", get_board_version_string()); // 3. UICR初始化 ret uicr_init(); if (ret) return ret; // 4. 通道分配初始化 ret channel_assignment_init(); if (ret) return ret; // 5. 状态指示器初始化 struct earable_state initial_state {0}; state_indicator.init(initial_state); return 0; } ``` ### 2. 外设配置 ```cpp void configure_peripherals(void) { // GPIO配置 configure_gpio_pins(); // I2C配置 configure_i2c_interfaces(); // SPI配置 configure_spi_interfaces(); // 电源域配置 configure_power_domains(); } ``` ## 错误处理策略 ### 1. 错误分类处理 ```cpp void handle_error(enum error_type type, int error_code) { switch (type) { case ERROR_HARDWARE: // 硬件错误 记录并尝试重启硬件 LOG_ERR(\"Hardware error: %d\", error_code); reset_hardware_peripherals(); break; case ERROR_MEMORY: // 内存错误 清理内存并重启 LOG_ERR(\"Memory error: %d\", error_code); cleanup_memory(); system_restart(); break; case ERROR_COMMUNICATION: // 通信错误 重置通信接口 LOG_ERR(\"Communication error: %d\", error_code); reset_communication_interfaces(); break; default: LOG_ERR(\"Unknown error type: %d, code: %d\", type, error_code); break; } } ``` ### 2. 系统恢复机制 ```cpp void system_recovery(void) { // 1. 保存关键状态 save_critical_state(); // 2. 重置外设 reset_all_peripherals(); // 3. 重新初始化 system_init(); // 4. 恢复关键状态 restore_critical_state(); // 5. 状态指示 indicate_recovery_complete(); } ``` ## 配置管理 ### Kconfig 选项 ```kconfig # 调试选项 config UTILS_DEBUG bool \"Enable utils module debug\" default n # 状态指示选项 config STATE_INDICATOR_BRIGHTNESS int \"LED brightness level (0 255)\" range 0 255 default 32 # 版本检测选项 config BOARD_VERSION_DETECTION bool \"Enable board version detection\" default y # 错误恢复选项 config ERROR_RECOVERY_ENABLED bool \"Enable automatic error recovery\" default y ``` ### 设备树配置 ```dts / { board_config { compatible \"openearable,board config\"; version gpio <&gpio0 28 GPIO_ACTIVE_HIGH>; status led <&led_rgb>; }; }; ``` ## 性能监控 ### 系统资源监控 ```cpp struct system_stats { uint32_t cpu_usage; uint32_t memory_usage; uint32_t stack_usage; uint32_t heap_free; }; void get_system_stats(struct system_stats* stats) { // CPU使用率 stats >cpu_usage get_cpu_usage_percent(); // 内存使用情况 stats >memory_usage get_memory_usage_bytes(); stats >heap_free get_heap_free_bytes(); // 栈使用情况 stats >stack_usage get_stack_usage_bytes(); } ``` ### 运行时统计 ```cpp void print_runtime_stats(void) { struct system_stats stats; get_system_stats(&stats); LOG_INF(\"System Stats:\"); LOG_INF(\" CPU Usage: %u%%\", stats.cpu_usage); LOG_INF(\" Memory Usage: %u bytes\", stats.memory_usage); LOG_INF(\" Heap Free: %u bytes\", stats.heap_free); LOG_INF(\" Stack Usage: %u bytes\", stats.stack_usage); } ``` ## 调试和诊断 ### 诊断信息收集 ```cpp void collect_diagnostic_info(void) { // 固件信息 const struct fw_info* fw get_fw_info(); LOG_INF(\"Firmware: v%u.%u.%u\", fw >version_major, fw >version_minor, fw >version_patch); // 硬件信息 LOG_INF(\"Board: %s\", get_board_version_string()); // 系统状态 print_runtime_stats(); // UICR信息 struct uicr_config uicr; if (uicr_read_config(&uicr) 0) { LOG_INF(\"Device ID: 0x%08x\", uicr.device_id); LOG_INF(\"HW Version: 0x%08x\", uicr.hw_version); } } ``` ## 总结 系统工具模块提供了完整的系统支撑功能，具有以下特点： 1. **全面性**: 涵盖状态指示、版本管理、错误处理等各个方面 2. **可靠性**: 完善的错误处理和系统恢复机制 3. **可维护性**: 清晰的版本管理和诊断信息 4. **可配置性**: 丰富的配置选项和板级适配 5. **可观测性**: 完整的状态指示和运行时监控 该模块为OpenEarable设备提供了稳定可靠的系统基础设施，确保设备的正常运行和可维护性。"},"/lhfdoc.github.io/embedded_dev/openearable/architecture.html":{"title":"OpenEarable 2.0 源码架构分析","content":"# OpenEarable 2.0 源码架构分析 ## 项目结构概览 ``` openearable v2/ ├── CMakeLists.txt # 主构建配置文件 ├── prj.conf # 项目配置文件 ├── prj_release.conf # 发布版本配置 ├── prj_fota.conf # FOTA版本配置 ├── boards/ # 板级支持包 │ └── teco/openearable_v2/ # OpenEarable v2硬件配置 ├── src/ # 源代码目录 │ ├── audio/ # 音频处理模块 │ ├── Battery/ # 电源管理模块 │ ├── bluetooth/ # 蓝牙通信模块 │ ├── buttons/ # 按键处理模块 │ ├── drivers/ # 硬件驱动模块 │ ├── modules/ # 通用功能模块 │ ├── SensorManager/ # 传感器管理模块 │ ├── SD_Card/ # SD卡管理模块 │ ├── ParseInfo/ # 数据解析模块 │ ├── Wire/ # I2C通信模块 │ └── utils/ # 工具函数模块 ├── unicast_server/ # 单播服务器应用 │ └── main.cpp # 主入口文件 ├── broadcast_sink/ # 广播接收器应用 ├── include/ # 公共头文件 └── tools/ # 构建和烧录工具 ``` ## 应用架构分析 ### 主应用入口 (unicast_server/main.cpp) 项目主要以单播服务器模式运行，主要初始化流程： 1. **系统初始化** 电源管理器初始化 USB设备栈使能 音频流控制启动 2. **状态管理** SIRK (Set Identity Resolving Key) 检查 配对状态设置 LED状态指示器初始化 3. **服务初始化** 传感器管理器初始化 蓝牙服务初始化（LED、电池、按键、传感器等） 数据解析服务初始化 ### 核心模块架构 #### 1. 电源管理模块 (src/Battery/) **PowerManager**: 电源状态管理 **BQ27220**: 电池监测芯片驱动 **BQ25120a**: 电池充电管理芯片驱动 **BootState**: 启动状态管理 #### 2. 音频处理模块 (src/audio/) **audio_datapath**: 音频数据路径处理 **audio_system**: 音频子系统管理 **Equalizer**: 音频均衡器 **streamctrl**: 音频流控制 **pdm_mic**: PDM麦克风驱动 #### 3. 蓝牙通信模块 (src/bluetooth/) **bt_management**: 蓝牙连接管理 **bt_stream**: 蓝牙音频流处理 **gatt_services**: GATT服务实现 device_info: 设备信息服务 battery_service: 电池服务 sensor_service: 传感器服务 led_service: LED控制服务 button_service: 按键服务 #### 4. 传感器管理模块 (src/SensorManager/) **SensorManager**: 传感器统一管理接口 **DefaultSensors**: 默认传感器配置 **SensorScheme**: 传感器方案定义 #### 5. 硬件驱动模块 (src/drivers/) **ADAU1860**: 音频编解码器驱动 **LED_Controller**: LED控制驱动 #### 6. 数据存储模块 (src/SD_Card/) **SDLogger**: SD卡数据记录 **SD_Card_Manager**: SD卡管理 **Benchmark**: 性能测试 #### 7. 通信模块 (src/Wire/) I2C通信协议实现 传感器通信接口 #### 8. 工具模块 (src/utils/) **StateIndicator**: 状态指示器 **macros**: 通用宏定义 **fw_info**: 固件信息管理 ## 关键特性 ### 多应用架构支持 **单播服务器** (unicast_server): 主要应用模式，作为音频接收端 **广播接收器** (broadcast_sink): 广播音频接收模式 ### 模块化设计 每个功能模块都有独立的CMakeLists.txt 模块间通过定义良好的接口通信 支持模块的独立开发和测试 ### 硬件抽象 通过设备树(DTS)文件进行硬件配置 驱动层与应用层分离 支持多种硬件平台 ### 电源管理 完整的电池状态监控 充电状态管理 低功耗优化 ### 传感器集成 统一的传感器管理接口 支持多种传感器类型 可配置的采样率和数据格式 ## 构建系统 ### CMake配置 使用Zephyr RTOS构建系统 支持条件编译配置 模块化的子目录构建 ### 配置文件 **prj.conf**: 基础配置 **prj_release.conf**: 发布版本优化配置 **prj_fota.conf**: 支持固件升级的配置 ### 编译标志 `HEADSET 1`: 耳机模式 `GATEWAY 2`: 网关模式 支持不同的音频配置和功能 ## 模块间通信机制 ### ZBus 消息总线 基于Zephyr ZBus的发布 订阅模式 模块间解耦的异步通信 支持多订阅者的事件分发 ### 关键消息类型 **button_msg**: 按键事件消息 **sensor_msg**: 传感器数据消息 **battery_msg**: 电池状态消息 **audio_msg**: 音频状态消息 ### 工作队列和线程 各模块使用独立的工作队列 优先级配置的多线程架构 中断安全的消息传递 ## 数据流分析 ### 音频数据流 ``` PDM麦克风 → 音频数据路径 → 均衡器处理 → 蓝牙LE Audio → 远程设备 ``` ### 传感器数据流 ``` 物理传感器 → 传感器管理器 → 数据融合 → 蓝牙GATT → 客户端应用 ↓ SD卡存储 ``` ### 控制流 ``` 物理按键 → 按键管理器 → ZBus消息 → 各功能模块 → 状态更新 → LED指示 ``` ## 功耗优化策略 ### 动态频率调节 根据工作负载调整CPU频率 传感器按需采样 音频流自适应比特率 ### 外设管理 未使用外设的自动关闭 I2C/SPI接口的低功耗模式 GPIO引脚的合理配置 ### 睡眠机制 系统空闲时进入低功耗模式 中断唤醒机制 电池电量监控和保护 ## 完整模块文档 以下是各核心模块的详细分析文档： ### 核心功能模块 1. **[电源管理模块](../modules/battery module.html)** 电池监控、充电管理、功耗优化 2. **[音频处理模块](../modules/audio module.html)** 音频采集、处理、流控制 3. **[传感器管理模块](../modules/sensor module.html)** 多传感器融合、数据处理 4. **[蓝牙通信模块](../modules/bluetooth module.html)** LE Audio、GATT服务、连接管理 5. **[数据存储模块](../modules/storage module.html)** SD卡管理、数据记录 6. **[硬件驱动模块](../modules/drivers module.html)** 音频编解码器、LED控制器 ### 辅助功能模块 7. **[按键处理模块](../modules/buttons module.html)** 物理按键、防抖处理、事件分发 8. **[数据解析模块](../modules/parseinfo module.html)** 传感器数据格式、蓝牙配置信息 9. **[I2C通信模块](../modules/wire module.html)** Arduino兼容I2C接口、设备通信 10. **[系统工具模块](../modules/utils module.html)** 状态指示、版本管理、错误处理 ## 开发指南 ### 添加新传感器 1. 在 `src/drivers/` 下创建驱动文件 2. 在 `src/SensorManager/` 中注册传感器 3. 在 `src/ParseInfo/` 中定义数据格式 4. 在 `src/bluetooth/gatt_services/` 中添加GATT特性 ### 添加新功能模块 1. 创建模块目录和CMakeLists.txt 2. 定义模块接口和数据结构 3. 实现ZBus消息处理 4. 在主应用中集成模块 ### 调试和测试 使用Zephyr日志系统 通过UART或RTT输出调试信息 单元测试和集成测试框架 ## 总结 OpenEarable 2.0采用了现代化的嵌入式系统架构设计，具有以下特点： 1. **模块化设计**: 功能模块高度解耦，便于开发和维护 2. **消息驱动**: 基于ZBus的异步消息通信机制 3. **多应用支持**: 支持不同的应用场景和配置 4. **硬件抽象**: 良好的硬件抽象层，支持多平台移植 5. **功耗优化**: 全面的功耗管理和优化策略 6. **可扩展性**: 易于添加新功能和传感器 7. **可调试性**: 完善的日志和调试机制 该架构为智能可穿戴设备的开发提供了完整的解决方案，是一个值得学习和借鉴的优秀开源项目。 *本文档基于OpenEarable 2.0源码深度分析生成，各模块的详细技术文档请参考相关链接。*"},"/lhfdoc.github.io/embedded_dev/openearable/drivers-module.html":{"title":"硬件驱动模块详细分析","content":"# 硬件驱动模块详细分析 ## 模块概述 硬件驱动模块提供OpenEarable 2.0硬件组件的底层驱动支持，主要包括音频编解码器、LED控制器等关键硬件的驱动程序。 ## 文件结构 ``` src/drivers/ ├── ADAU1860.h/.cpp # ADAU1860音频编解码器驱动 ├── LED_Controller/ # LED控制器驱动 │ └── KTD2026.h/.cpp # KTD2026 RGB LED驱动 ├── Lark eq.c # Lark均衡器算法 ├── Lark fdsp.c # Lark数字信号处理 ├── CMakeLists.txt # 构建配置 └── Kconfig # 配置选项 ``` ## 核心驱动 ### 1. ADAU1860 音频编解码器驱动 ADAU1860是高性能低功耗音频编解码器，支持高质量音频输入输出。 #### 主要特性 **高质量DAC/ADC**: 24位分辨率，SNR >100dB **低功耗设计**: 优化的功耗管理 **灵活路由**: 可配置的音频信号路由 **数字音效**: 内置EQ、压缩器等音效处理 ### 2. KTD2026 RGB LED驱动 KTD2026是三通道LED驱动器，用于状态指示和用户界面。 #### 主要特性 **三通道控制**: 独立的RGB通道控制 **PWM调光**: 高精度PWM亮度控制 **低功耗**: 待机电流<1μA **I2C控制**: 简单的I2C接口 ## 总结 硬件驱动模块为OpenEarable 2.0的关键硬件组件提供了稳定可靠的驱动支持，确保了音频质量和用户界面体验。主要特点包括： 1. **高质量音频支持**: ADAU1860提供专业级音频处理能力 2. **丰富视觉反馈**: RGB LED支持多样化的状态指示 3. **优化功耗管理**: 所有驱动都考虑了低功耗设计 4. **标准化接口**: 基于I2C等标准接口，易于集成和维护 该模块为OpenEarable 2.0的硬件功能提供了坚实的软件基础。"},"/lhfdoc.github.io/embedded_dev/openearable/audio-module.html":{"title":"音频处理模块详细分析","content":"# 音频处理模块详细分析 ## 模块概述 音频处理模块是OpenEarable 2.0的核心功能组件，负责完整的音频信号链处理，包括音频捕获、编解码、流控制、信号处理等功能。该模块基于nRF5340 Audio DK的成熟音频架构，支持LE Audio协议和高质量音频处理。 ## 文件结构 ``` src/audio/ ├── streamctrl.h/.c # 音频流控制核心 ├── audio_datapath.h/.c # 音频数据路径处理 ├── audio_system.h/.c # 音频子系统管理 ├── le_audio_rx.h/.c # LE Audio接收处理 ├── pdm_mic.h/.c # PDM麦克风驱动 ├── sw_codec_select.h/.c # 软件编解码器选择 ├── Equalizer.h/.cpp # 音频均衡器 ├── sdlogger_wrapper.h/.cpp # SD卡日志包装器 ├── CMakeLists.txt # 构建配置 ├── Kconfig # 配置选项 └── Kconfig.defaults # 默认配置 ``` ## 核心组件分析 ### 1. StreamCtrl 音频流控制器 StreamCtrl是音频流处理的核心控制组件，负责管理音频流的状态和数据传输。 #### 主要功能 **流状态管理**: 控制播放/暂停状态 **数据传输**: 处理音频数据的发送 **同步控制**: 确保音频数据的同步传输 #### 接口定义 ```cpp // 流状态枚举 enum stream_state { STATE_STREAMING, // 正在流传输 STATE_PAUSED, // 暂停状态 }; // 核心接口函数 uint8_t stream_state_get(void); // 获取当前流状态 void streamctrl_send(const void *data, size_t size, uint8_t num_ch); // 发送音频数据 int streamctrl_start(); // 启动流控制 ``` #### 实现特点 **状态机管理**: 使用状态机控制流传输状态 **多声道支持**: 支持单声道和立体声音频 **缓冲管理**: 智能的音频缓冲区管理 ### 2. Audio Datapath 音频数据路径 音频数据路径模块负责音频数据的完整处理流程，从输入到输出的所有处理环节。 #### 主要功能 **音频同步**: 基于时间戳的音频同步 **格式转换**: 音频格式和采样率转换 **信号处理**: 音频增强和降噪处理 **测试音生成**: 系统测试音频信号生成 #### 核心接口 ```cpp // 主要处理接口 void audio_datapath_stream_out(const uint8_t *buf, size_t size, uint32_t sdu_ref_us, bool bad_frame, uint32_t recv_frame_ts_us); // 系统控制接口 int audio_datapath_start(struct data_fifo *fifo_rx); // 启动数据路径 int audio_datapath_stop(void); // 停止数据路径 int audio_datapath_init(void); // 初始化数据路径 // 音频增强功能 int audio_datapath_tone_play(uint16_t freq, uint16_t dur_ms, float amplitude); void audio_datapath_tone_stop(void); // 停止测试音 // 延迟控制 int audio_datapath_pres_delay_us_set(uint32_t delay_us); void audio_datapath_pres_delay_us_get(uint32_t *delay_us); ``` #### 数据流架构 ``` [LE Audio RX] → [Decoder] → [Equalizer] → [I2S Output] ↓ [SD Logger] (可选) ↓ [Sensor Data] (可选) ``` #### 同步机制 ```cpp // 时间戳同步处理 void audio_datapath_stream_out(const uint8_t *buf, size_t size, uint32_t sdu_ref_us, bool bad_frame, uint32_t recv_frame_ts_us) { // 1. 解码音频数据 // 2. 计算播放时间戳 // 3. 应用呈现延迟 // 4. 同步到I2S输出 // 5. 记录到SD卡(可选) } ``` ### 3. Audio System 音频子系统 音频子系统提供高层次的音频管理接口，集成编解码器、音频处理和系统控制。 #### 主要功能 **编解码管理**: LC3编解码器控制 **系统配置**: 音频参数配置管理 **测试功能**: 内置测试音生成 **性能优化**: 音频处理性能优化 #### 核心接口 ```cpp // 系统控制 void audio_system_start(void); // 启动音频系统 void audio_system_stop(void); // 停止音频系统 // 编码器控制 void audio_system_encoder_start(void); // 启动编码器 void audio_system_encoder_stop(void); // 停止编码器 // 配置管理 int audio_system_config_set(uint32_t encoder_sample_rate_hz, uint32_t encoder_bitrate, uint32_t decoder_sample_rate_hz); // 解码处理 int audio_system_decode(const void *encoded_data, size_t encoded_data_size, bool bad_frame); // 测试功能 int audio_system_encode_test_tone_set(uint32_t freq); int audio_system_encode_test_tone_step(void); // 缓冲管理 int audio_system_fifo_rx_block_drop(void); ``` #### 配置参数 ```cpp struct audio_config { uint32_t sample_rate_hz; // 采样率 uint32_t bitrate_bps; // 比特率 uint8_t channels; // 声道数 uint16_t frame_size_us; // 帧长度(微秒) }; ``` ### 4. PDM Microphone PDM麦克风驱动 PDM麦克风模块负责板载麦克风的音频捕获功能。 #### 主要功能 **PDM信号采集**: 脉冲密度调制信号采集 **数字滤波**: PDM到PCM转换和滤波 **缓冲管理**: 音频数据缓冲和队列管理 #### 接口定义 ```cpp // 麦克风控制 void pdm_mic_start(void); // 启动麦克风 void pdm_mic_stop(void); // 停止麦克风 int pdm_mic_init(void); // 初始化麦克风 // 数据路径 int pdm_datapath_start(struct data_fifo *fifo_rx); // 启动PDM数据路径 ``` #### PDM配置 ```cpp // PDM配置参数 struct pdm_config { uint32_t sample_rate; // 采样率 (通常16kHz) uint8_t gain_l; // 左声道增益 uint8_t gain_r; // 右声道增益 uint8_t clock_freq; // PDM时钟频率 }; ``` ### 5. Equalizer 音频均衡器 音频均衡器提供实时音频增强和频率响应调整功能。 #### 主要功能 **频率响应调整**: 多频段均衡处理 **实时处理**: 低延迟音频处理 **参数可调**: 支持动态参数调整 #### 接口定义 ```cpp #define EQ_ORDER 9 // 均衡器阶数 // 均衡器控制 void reset_eq(); // 重置均衡器 void equalize(int16_t *data, int length); // 音频均衡处理 ``` #### 均衡器结构 ```cpp // 9阶数字滤波器实现 struct eq_filter { float coeffs[EQ_ORDER]; // 滤波器系数 float delays[EQ_ORDER]; // 延迟缓冲 float gain; // 增益参数 }; ``` ### 6. LE Audio RX LE Audio接收处理 LE Audio接收模块负责蓝牙LE Audio协议的音频数据接收和处理。 #### 主要功能 **ISO数据接收**: 接收ISO音频数据包 **错误处理**: 丢包检测和错误恢复 **同步维护**: 音频流同步维护 **质量监控**: 音频质量监控和统计 #### 数据包处理 ```cpp // LE Audio数据包结构 struct le_audio_packet { uint32_t timestamp; // 时间戳 uint16_t seq_num; // 序列号 uint8_t *payload; // 音频负载 size_t payload_len; // 负载长度 bool crc_ok; // CRC校验状态 }; ``` ### 7. Software Codec Select 软件编解码器选择 软件编解码器选择模块提供LC3等音频编解码器的集成接口。 #### 支持的编解码器 **LC3**: LE Audio标准编解码器 **SBC**: 经典蓝牙编解码器(兼容性) **Raw PCM**: 未压缩音频格式 #### 编解码器接口 ```cpp // 编解码器操作接口 struct codec_interface { int (*init)(void); int (*encode)(const int16_t *input, uint8_t *output, size_t *output_size); int (*decode)(const uint8_t *input, size_t input_size, int16_t *output); void (*deinit)(void); }; ``` ## 音频处理流程 ### 播放流程 ``` [LE Audio RX] → [LC3 Decode] → [Equalizer] → [I2S DAC] → [扬声器] ↓ [SD Logger] (可选录制) ``` ### 录音流程 ``` [PDM Mic] → [Filter] → [LC3 Encode] → [LE Audio TX] → [蓝牙传输] ↓ [SD Logger] (可选录制) ``` ### 双向通信流程 ``` 接收: [LE Audio RX] → [Decode] → [Mix] → [I2S Output] ↑ 发送: [PDM Mic] → [Encode] → [LE Audio TX] ``` ## 同步和时序 ### 音频同步机制 ```cpp // 时间戳同步处理 void audio_sync_process(uint32_t sdu_ref_us, uint32_t recv_ts_us) { // 1. 计算传输延迟 uint32_t transport_delay recv_ts_us sdu_ref_us; // 2. 应用呈现延迟 uint32_t presentation_delay get_presentation_delay(); // 3. 计算播放时间 uint32_t play_time sdu_ref_us + presentation_delay; // 4. 同步到I2S播放 schedule_i2s_playback(play_time); } ``` ### 缓冲管理 ```cpp // 自适应缓冲管理 void adaptive_buffer_management() { // 监控缓冲区水位 size_t buffer_level get_buffer_level(); if (buffer_level < LOW_THRESHOLD) { // 缓冲区过低，增加延迟 increase_buffer_size(); } else if (buffer_level > HIGH_THRESHOLD) { // 缓冲区过高，减少延迟 decrease_buffer_size(); } } ``` ## 音频质量优化 ### 1. 降噪处理 ```cpp // 数字降噪算法 void noise_reduction(int16_t *audio_data, size_t length) { // 实现自适应滤波降噪 for (size_t i 0; i < length; i++) { audio_data[i] apply_noise_filter(audio_data[i]); } } ``` ### 2. 动态范围控制 ```cpp // 自动增益控制 void agc_process(int16_t *audio_data, size_t length) { // 计算音频能量 float energy calculate_energy(audio_data, length); // 调整增益 float gain calculate_optimal_gain(energy); apply_gain(audio_data, length, gain); } ``` ### 3. 回声消除 ```cpp // 声学回声消除(AEC) void echo_cancellation(int16_t *mic_data, int16_t *speaker_data, int16_t *output, size_t length) { // 实现自适应回声消除算法 adaptive_filter_process(mic_data, speaker_data, output, length); } ``` ## 配置参数 ### 音频配置选项 ```kconfig # 采样率配置 CONFIG_AUDIO_SAMPLE_RATE_48000 y CONFIG_AUDIO_SAMPLE_RATE_16000 n # 编解码器配置 CONFIG_AUDIO_CODEC_LC3 y CONFIG_AUDIO_CODEC_SBC n # 音频增强 CONFIG_AUDIO_EQUALIZER y CONFIG_AUDIO_NOISE_REDUCTION y CONFIG_AUDIO_AGC y # 缓冲配置 CONFIG_AUDIO_BUFFER_SIZE 4096 CONFIG_AUDIO_BUFFER_COUNT 4 ``` ### 性能参数 ```cpp // 音频性能参数 #define AUDIO_FRAME_SIZE_US 10000 // 10ms帧长 #define AUDIO_SAMPLE_RATE_HZ 48000 // 48kHz采样率 #define AUDIO_CHANNELS 2 // 立体声 #define AUDIO_BITS_PER_SAMPLE 16 // 16位采样深度 // 延迟参数 #define PRESENTATION_DELAY_US 40000 // 40ms呈现延迟 #define PROCESSING_DELAY_US 5000 // 5ms处理延迟 ``` ## 错误处理和恢复 ### 音频中断处理 ```cpp void audio_error_handler(audio_error_t error) { switch (error) { case AUDIO_UNDERRUN: // 缓冲区下溢处理 refill_audio_buffer(); break; case AUDIO_OVERRUN: // 缓冲区上溢处理 drop_old_audio_frames(); break; case AUDIO_SYNC_LOST: // 同步丢失处理 reinitialize_sync(); break; default: // 通用错误处理 restart_audio_system(); break; } } ``` ### 质量监控 ```cpp // 音频质量统计 struct audio_quality_stats { uint32_t packets_received; // 接收包数 uint32_t packets_lost; // 丢包数 uint32_t late_packets; // 延迟包数 float average_latency_ms; // 平均延迟 float jitter_ms; // 抖动 }; ``` ## 功耗优化 ### 动态功耗管理 ```cpp void audio_power_management() { if (audio_stream_active()) { // 流传输活跃时，保持高性能模式 set_cpu_frequency(HIGH_FREQ); enable_audio_pll(); } else { // 流传输空闲时，降低功耗 set_cpu_frequency(LOW_FREQ); disable_audio_pll(); } } ``` ## 总结 音频处理模块是OpenEarable 2.0的核心功能组件，具有以下特点： 1. **完整的音频链**: 从音频捕获到播放的完整处理链 2. **LE Audio支持**: 完整支持蓝牙LE Audio协议栈 3. **高质量处理**: 集成均衡器、降噪等音频增强功能 4. **低延迟设计**: 优化的缓冲和同步机制 5. **模块化架构**: 各功能模块独立，易于维护和扩展 6. **实时性能**: 满足实时音频处理要求 7. **功耗优化**: 智能的功耗管理策略 该模块为OpenEarable 2.0提供了专业级的音频处理能力，支持高质量的音乐播放、通话和音频采集功能。"},"/lhfdoc.github.io/embedded_dev/openearable/storage-module.html":{"title":"数据存储模块详细分析","content":"# 数据存储模块详细分析 ## 模块概述 数据存储模块负责OpenEarable 2.0的本地数据存储功能，主要通过SD卡实现传感器数据和音频数据的本地记录。该模块提供高效的数据缓冲、文件管理和存储优化功能。 ## 文件结构 ``` src/SD_Card/ ├── SDLogger/ # SD卡数据记录器 │ ├── SDLogger.h/.cpp # 主要日志记录类 │ └── CMakeLists.txt # 构建配置 ├── SD_Card_Manager/ # SD卡管理器 │ ├── SD_Card_Manager.h/.cpp # SD卡管理接口 │ └── CMakeLists.txt # 构建配置 ├── Benchmark/ # 性能测试 │ ├── Benchmark.h/.cpp # 存储性能测试 │ └── CMakeLists.txt # 构建配置 └── CMakeLists.txt # 模块构建配置 ``` ## 核心组件 ### 1. SDLogger SD卡日志记录器 SDLogger是数据存储的核心组件，提供高效的传感器数据记录功能。 #### 主要特性 **缓冲写入**: 使用环形缓冲区优化写入性能 **块对齐**: 4KB块对齐确保最佳存储性能 **文件格式**: 自定义二进制格式(.oe)优化存储效率 **版本管理**: 文件头包含版本和时间戳信息 #### 缓冲架构 ```cpp class SDLogger { private: static constexpr size_t SD_BLOCK_SIZE 4096; // SD卡块大小 static constexpr size_t BUFFER_BLOCK_COUNT 8; // 缓冲区块数 static constexpr size_t BUFFER_SIZE SD_BLOCK_SIZE * BUFFER_BLOCK_COUNT; // 32KB缓冲区 // 文件头结构 struct __attribute__((packed)) FileHeader { uint16_t version; // 文件格式版本 uint64_t timestamp; // 创建时间戳 }; }; ``` ### 2. SD_Card_Manager SD卡管理器 SD卡管理器提供SD卡的底层操作接口，包括挂载、卸载、文件系统管理等。 #### 主要功能 **SD卡检测**: 自动检测SD卡插入和移除 **文件系统管理**: FAT32文件系统支持 **错误处理**: SD卡错误检测和恢复 **性能监控**: 读写性能统计 ### 3. 数据格式 #### 传感器数据格式 ```cpp // 传感器数据记录格式 struct sensor_log_entry { uint64_t timestamp; // 时间戳 (微秒) uint8_t sensor_id; // 传感器ID uint8_t data_size; // 数据大小 uint8_t data[]; // 传感器数据 } __attribute__((packed)); ``` #### 文件格式结构 ``` .oe文件格式: + + 文件头 (10字节) 版本 (2字节) 时间戳 (8字节) + + 传感器数据记录1 + + 传感器数据记录2 + + ... + + ``` ## 性能优化 ### 缓冲写入策略 ```cpp void SDLogger::write_sensor_data(const sensor_data* data) { // 1. 数据写入环形缓冲区 ring_buffer_put(&sd_buffer, (uint8_t*)data, sizeof(sensor_data)); // 2. 检查是否达到写入阈值 if (ring_buffer_size_get(&sd_buffer) > WRITE_THRESHOLD) { // 触发批量写入 schedule_bulk_write(); } } ``` ### 块对齐优化 ```cpp // 确保写入数据块对齐 static_assert(BUFFER_SIZE % SD_BLOCK_SIZE 0, \"BUFFER_SIZE must be a multiple of SD_BLOCK_SIZE\"); ``` ## 总结 数据存储模块为OpenEarable 2.0提供了高效可靠的本地数据存储功能，支持: 1. **高性能写入**: 缓冲和块对齐优化 2. **可靠存储**: 错误检测和恢复机制 3. **标准格式**: 自定义二进制格式优化存储效率 4. **易于解析**: Python工具支持数据解析和分析 该模块确保了传感器数据的可靠本地存储，为离线数据分析和研究提供了重要支持。"},"/lhfdoc.github.io/embedded_dev/openearable/index.html":{"title":"OpenEarable 2.0 项目分析","content":"# OpenEarable 2.0 项目分析 ## 项目概述 OpenEarable是一个基于Nordic nRF5340的开源智能耳戴设备项目，旨在提供一个完整的可穿戴设备开发平台。 ## 项目特点 双核处理器: 基于Nordic nRF5340双核SoC 多传感器支持: 集成多种传感器用于生理数据监测 低功耗设计: 优化的电源管理系统 无线连接: 支持蓝牙BLE通信 开源架构: 完全开源的硬件和软件设计 ## 系统架构 OpenEarable 2.0采用模块化架构设计，主要包含以下核心模块： ### 核心功能模块 电源管理模块: 负责设备的电源控制和电池管理 音频处理模块: 处理音频输入输出和信号处理 传感器管理模块: 管理各类传感器的数据采集 蓝牙通信模块: 处理与外部设备的无线通信 数据存储模块: 负责数据的本地存储和管理 硬件驱动模块: 底层硬件设备的驱动程序 ### 辅助功能模块 按键处理模块: 处理用户输入和交互 数据解析模块: 解析和处理传感器数据 I2C通信模块: 处理I2C总线通信 系统工具模块: 提供系统级的工具函数 ## 快速开始 1. 硬件准备: 获取OpenEarable 2.0开发板 2. 开发环境: 设置Nordic nRF5340开发环境 3. 代码下载: 从GitHub获取最新代码 4. 编译烧录: 编译固件并烧录到设备 ## 文档导航 使用左侧导航栏浏览各个模块的详细文档，每个模块都包含： 功能介绍和设计原理 API接口说明 使用示例和最佳实践 故障排除和调试指南 本文档基于OpenEarable 2.0项目进行分析整理，旨在帮助开发者更好地理解和使用该平台。"},"/lhfdoc.github.io/embedded_dev/openearable/parseinfo-module.html":{"title":"OpenEarable 2.0 - 数据解析模块 (ParseInfo Module)","content":"# OpenEarable 2.0 数据解析模块 (ParseInfo Module) ## 概述 数据解析模块负责定义和管理传感器数据的解析方案，为蓝牙通信提供传感器配置信息和数据格式描述。该模块通过标准化的数据结构定义，使客户端能够正确解析和处理来自OpenEarable设备的传感器数据。 ## 核心组件 ### 1. 传感器方案 (`SensorScheme.h/cpp`) 定义传感器的完整配置和解析方案： #### 核心数据结构 ```cpp struct SensorScheme { const char* name; // 传感器名称 uint8_t id; // 传感器ID uint8_t groupCount; // 组件组数量 struct SensorComponentGroup* groups; // 组件组数组 struct SensorConfigOptions configOptions; // 配置选项 }; struct ParseInfoScheme { uint8_t sensorCount; // 传感器数量 uint8_t* sensorIds; // 传感器ID数组 }; ``` #### 配置选项 ```cpp enum SensorConfigOptionsMasks { DATA_STREAMING 0x01, // 支持数据流传输 DATA_STORAGE 0x02, // 支持数据存储 FREQUENCIES_DEFINED 0x10, // 定义了频率选项 }; struct FrequencyOptions { uint8_t frequencyCount; // 频率选项数量 uint8_t defaultFrequencyIndex; // 默认频率索引 uint8_t maxBleFrequencyIndex; // 最大蓝牙频率索引 const float* frequencies; // 频率数组 }; struct SensorConfigOptions { uint8_t availableOptions; // 可用选项掩码 struct FrequencyOptions frequencyOptions; // 频率选项 }; ``` #### 核心接口 ```cpp int initParseInfoService(struct ParseInfoScheme* scheme, struct SensorScheme* sensorSchemes); struct SensorScheme* getSensorSchemeForId(uint8_t id); struct ParseInfoScheme* getParseInfoScheme(); float getSampleRateForSensorId(uint8_t id, uint8_t frequencyIndex); float getSampleRateForSensor(struct SensorScheme* sensorScheme, uint8_t frequencyIndex); ``` ### 2. 传感器组件 (`SensorComponent.h/cpp`) 定义传感器数据的组件结构： #### 基本组件 ```cpp struct SensorComponent { const char* name; // 组件名称 (如 \"x\", \"y\", \"z\") const char* unit; // 单位 (如 \"m/s²\", \"°/s\") enum ParseType parseType; // 数据类型 }; ``` #### 组件组 ```cpp struct SensorComponentGroup { const char* name; // 组名称 (如 \"Accelerometer\") size_t componentCount; // 组件数量 struct SensorComponent* components; // 组件数组 }; ``` #### 序列化接口 ```cpp size_t getSensorComponentGroupSize(struct SensorComponentGroup* group); ssize_t serializeSensorComponentGroup(struct SensorComponentGroup* group, char* buffer, size_t bufferSize); ``` ### 3. 数据类型定义 (`ParseType.h`) 定义支持的数据解析类型： ```cpp enum ParseType { PARSE_TYPE_INT8, // 8位有符号整数 PARSE_TYPE_UINT8, // 8位无符号整数 PARSE_TYPE_INT16, // 16位有符号整数 PARSE_TYPE_UINT16, // 16位无符号整数 PARSE_TYPE_INT32, // 32位有符号整数 PARSE_TYPE_UINT32, // 32位无符号整数 PARSE_TYPE_FLOAT, // 32位浮点数 PARSE_TYPE_DOUBLE, // 64位双精度浮点数 }; const int parseTypeSizes[] { 1, // INT8/UINT8 1, 2, // INT16/UINT16 2, 4, // INT32/UINT32 4, 4, // FLOAT 8, // DOUBLE }; ``` ### 4. 默认传感器定义 (`DefaultSensors.h`) 预定义常用传感器的配置方案（具体实现可能在相应的.cpp文件中）。 ## 蓝牙服务集成 ### GATT 服务定义 ```cpp #define BT_UUID_PARSE_INFO_SERVICE_VAL \\ BT_UUID_128_ENCODE(0xcaa25cb7, 0x7e1b, 0x44f2, 0xadc9, 0xe8c06c9ced43) #define BT_UUID_PARSE_INFO_CHARAC_VAL \\ BT_UUID_128_ENCODE(0xcaa25cb9, 0x7e1b, 0x44f2, 0xadc9, 0xe8c06c9ced43) #define BT_UUID_PARSE_INFO_REQUEST_CHARAC_VAL \\ BT_UUID_128_ENCODE(0xcaa25cba, 0x7e1b, 0x44f2, 0xadc9, 0xe8c06c9ced43) #define BT_UUID_PARSE_INFO_RESPONSE_CHARAC_VAL \\ BT_UUID_128_ENCODE(0xcaa25cbb, 0x7e1b, 0x44f2, 0xadc9, 0xe8c06c9ced43) ``` ### 特性功能 **Parse Info Service**: 主服务 **Parse Info Characteristic**: 基本解析信息 **Request Characteristic**: 客户端请求特定传感器信息 **Response Characteristic**: 服务器响应传感器配置 ## 典型传感器配置示例 ### IMU 传感器方案 ```cpp // 加速度计组件 struct SensorComponent accel_components[] { {\"x\", \"m/s²\", PARSE_TYPE_FLOAT}, {\"y\", \"m/s²\", PARSE_TYPE_FLOAT}, {\"z\", \"m/s²\", PARSE_TYPE_FLOAT} }; struct SensorComponentGroup accel_group { \"Accelerometer\", 3, accel_components }; // 陀螺仪组件 struct SensorComponent gyro_components[] { {\"x\", \"°/s\", PARSE_TYPE_FLOAT}, {\"y\", \"°/s\", PARSE_TYPE_FLOAT}, {\"z\", \"°/s\", PARSE_TYPE_FLOAT} }; struct SensorComponentGroup gyro_group { \"Gyroscope\", 3, gyro_components }; // 频率选项 const float imu_frequencies[] {1.0f, 10.0f, 25.0f, 50.0f, 100.0f}; struct FrequencyOptions imu_freq_options { 5, // 5个频率选项 2, // 默认25Hz (索引2) 3, // 蓝牙最大50Hz (索引3) imu_frequencies }; // IMU传感器方案 struct SensorComponentGroup imu_groups[] {accel_group, gyro_group}; struct SensorScheme imu_scheme { \"IMU\", SENSOR_ID_IMU, 2, // 2个组件组 imu_groups, { DATA_STREAMING DATA_STORAGE FREQUENCIES_DEFINED, imu_freq_options } }; ``` ### PPG 传感器方案 ```cpp struct SensorComponent ppg_components[] { {\"raw\", \"counts\", PARSE_TYPE_UINT32}, {\"heart_rate\", \"bpm\", PARSE_TYPE_FLOAT} }; struct SensorComponentGroup ppg_group { \"PPG\", 2, ppg_components }; const float ppg_frequencies[] {25.0f, 50.0f, 100.0f}; struct FrequencyOptions ppg_freq_options { 3, 1, 2, // 3个选项，默认50Hz，蓝牙最大100Hz ppg_frequencies }; struct SensorScheme ppg_scheme { \"PPG\", SENSOR_ID_PPG, 1, &ppg_group, { DATA_STREAMING DATA_STORAGE FREQUENCIES_DEFINED, ppg_freq_options } }; ``` ## 数据序列化 ### 组件组大小计算 ```cpp size_t getSensorComponentGroupSize(struct SensorComponentGroup* group) { size_t size 0; // 组名长度 + 组件数量 size + strlen(group >name) + 1 + sizeof(group >componentCount); // 每个组件的信息 for (size_t i 0; i < group >componentCount; i++) { size + strlen(group >components[i].name) + 1; size + strlen(group >components[i].unit) + 1; size + sizeof(group >components[i].parseType); } return size; } ``` ### 序列化格式 ``` [Group Name][Component Count] [Component 1 Name][Component 1 Unit][Component 1 Type] [Component 2 Name][Component 2 Unit][Component 2 Type] ... ``` ## 初始化流程 ### 1. 服务初始化 ```cpp int initParseInfoService(struct ParseInfoScheme* scheme, struct SensorScheme* sensorSchemes) { // 1. 存储传感器方案引用 // 2. 初始化蓝牙GATT服务 // 3. 注册特性回调函数 // 4. 准备默认响应数据 return 0; } ``` ### 2. 方案查询 ```cpp struct SensorScheme* getSensorSchemeForId(uint8_t id) { // 遍历已注册的传感器方案 // 根据ID匹配并返回对应方案 return matching_scheme; } ``` ## 客户端交互协议 ### 1. 获取传感器列表 ``` Client Request: [REQUEST_SENSOR_LIST] Server Response: [SENSOR_COUNT][SENSOR_ID_1][SENSOR_ID_2]... ``` ### 2. 获取传感器配置 ``` Client Request: [REQUEST_SENSOR_CONFIG][SENSOR_ID] Server Response: [SENSOR_NAME][GROUP_COUNT][GROUP_DATA...] ``` ### 3. 获取频率选项 ``` Client Request: [REQUEST_FREQUENCIES][SENSOR_ID] Server Response: [FREQ_COUNT][DEFAULT_INDEX][MAX_BLE_INDEX][FREQ_1][FREQ_2]... ``` ## 内存管理 ### 静态配置 传感器方案使用静态分配 组件定义存储在常量区域 避免运行时内存分配 ### 缓冲区管理 序列化使用预分配缓冲区 防止缓冲区溢出检查 适当的错误处理 ## 扩展性设计 ### 新传感器添加 1. 定义传感器组件结构 2. 创建传感器方案 3. 在默认方案中注册 4. 更新传感器ID枚举 ### 新数据类型支持 1. 扩展 `ParseType` 枚举 2. 更新 `parseTypeSizes` 数组 3. 修改序列化/反序列化逻辑 ## 调试和验证 ### 配置验证 检查组件数量一致性 验证频率选项有效性 确认数据类型支持 ### 序列化测试 缓冲区大小验证 数据完整性检查 跨平台兼容性测试 ## 总结 数据解析模块提供了完整的传感器数据格式定义和管理框架，具有以下特点： 1. **标准化**: 统一的数据格式定义和解析方案 2. **灵活性**: 支持多种数据类型和传感器配置 3. **可扩展**: 易于添加新传感器和数据类型 4. **高效性**: 静态配置和优化的序列化机制 5. **兼容性**: 蓝牙GATT服务集成和跨平台支持 该模块为OpenEarable设备的数据通信提供了可靠的格式化基础设施，确保客户端能够正确解析和处理传感器数据。"},"/lhfdoc.github.io/embedded_dev/openearable/bluetooth-module.html":{"title":"蓝牙通信模块详细分析","content":"# 蓝牙通信模块详细分析 ## 模块概述 蓝牙通信模块是OpenEarable 2.0与外部设备通信的核心组件，基于Bluetooth LE Audio协议栈构建，提供音频流传输、GATT服务、设备管理等功能。该模块不仅支持高质量音频传输，还提供了丰富的传感器数据传输和设备控制接口。 ## 文件结构 ``` src/bluetooth/ ├── bt_management/ # 蓝牙连接管理 ├── bt_stream/ # 蓝牙音频流处理 ├── bt_content_control/ # 内容控制 ├── bt_rendering_and_capture/ # 音频渲染和捕获 ├── gatt_services/ # GATT服务实现 │ ├── device_info.h/.c # 设备信息服务 │ ├── battery_service.h/.cpp # 电池服务 │ ├── sensor_service.h/.c # 传感器服务 │ ├── led_service.h/.cpp # LED控制服务 │ ├── button_service.h/.c # 按键服务 │ └── audio_config_service.h/.c # 音频配置服务 ├── CMakeLists.txt # 构建配置 ├── Kconfig # 配置选项 └── Kconfig.defaults # 默认配置 ``` ## 核心架构 ### 1. GATT服务架构 OpenEarable 2.0实现了多个自定义GATT服务，为客户端提供完整的设备控制和数据访问接口。 #### 服务概览 服务名称 功能描述 主要特征 Device Info 设备信息查询 制造商、型号、固件版本等 Battery Service 电池状态监控 电量、充电状态、健康状态 Sensor Service 传感器数据传输 配置、数据流、录制控制 LED Service LED状态控制 颜色、模式、亮度控制 Button Service 按键事件通知 按键状态、事件通知 Audio Config 音频参数配置 采样率、编解码器设置 ### 2. 传感器服务详解 传感器服务是OpenEarable的核心创新服务，提供完整的传感器数据访问和控制接口。 #### UUID定义 ```cpp // 传感器服务UUID #define BT_UUID_SENSOR_VAL \\ BT_UUID_128_ENCODE(0x34c2e3bb, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) // 传感器配置特征UUID #define BT_UUID_SENSOR_CONFIG_VAL \\ BT_UUID_128_ENCODE(0x34c2e3be, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) // 传感器数据特征UUID #define BT_UUID_SENSOR_DATA_VAL \\ BT_UUID_128_ENCODE(0x34c2e3bc, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) // 配置状态特征UUID #define BT_UUID_SENSOR_CONFIG_STATUS_VAL \\ BT_UUID_128_ENCODE(0x34c2e3bf, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) // 录制名称特征UUID #define BT_UUID_SENSOR_RECORDING_NAME_VAL \\ BT_UUID_128_ENCODE(0x34c2e3c0, 0x34aa, 0x11eb, 0xadc1, 0x0242ac120002) ``` #### 服务接口 ```cpp // 传感器服务初始化 int init_sensor_service(); // 传感器配置状态设置 int set_sensor_config_status(struct sensor_config config); // 获取录制名称 const char *get_sensor_recording_name(); ``` #### 传感器配置协议 ```cpp // 传感器配置结构 struct sensor_config { uint8_t sensorId; // 传感器ID uint8_t sampleRateIndex; // 采样率索引 uint8_t storageOptions; // 存储选项位图 } __attribute__((packed)); // 存储选项位图定义 #define STORAGE_SD_CARD (1 << 0) // SD卡存储 #define STORAGE_BLE_STREAM (1 << 1) // 蓝牙流传输 #define STORAGE_FLASH (1 << 2) // 内部Flash存储 ``` ### 3. 电池服务详解 电池服务提供完整的电源状态信息，支持标准GATT电池服务扩展。 #### 电池状态结构 ```cpp // 电池电量状态 struct battery_level_status { uint8_t flags; // 状态标志 uint16_t power_state; // 电源状态 } __attribute__((packed)); // 电池能量状态 struct battery_energy_status { uint8_t flags; // 状态标志 struct sfloat voltage; // 电压(V) struct sfloat available_capacity; // 可用容量(mAh) struct sfloat charge_rate; // 充电速率(mA) } __attribute__((packed)); // 电池健康状态 struct battery_health_status { uint8_t flags; // 状态标志 uint8_t battery_health_summary; // 健康状态摘要 uint16_t cycle_count; // 循环次数 int8_t current_temperature; // 当前温度(°C) } __attribute__((packed)); ``` #### 服务接口 ```cpp // 电池服务初始化 int init_battery_service(); // 发送电池电量数据 int bt_send_battery_level(struct battery_data *data); ``` ### 4. LED服务详解 LED服务提供LED状态的完整控制接口，支持颜色、亮度、模式控制。 #### LED控制结构 ```cpp // RGB颜色定义 typedef uint8_t RGBColor[3]; // LED模式枚举 enum led_mode { STATE_INDICATION, // 状态指示模式 CUSTOM, // 自定义模式 }; // LED配置结构 struct led_config { enum led_mode mode; // LED模式 RGBColor color; // RGB颜色 uint8_t brightness; // 亮度(0 255) uint16_t pattern; // 闪烁模式 } __attribute__((packed)); ``` ### 5. 按键服务详解 按键服务提供按键事件的实时通知功能。 #### 按键事件结构 ```cpp // 按键状态结构 struct button_event { uint8_t button_id; // 按键ID uint8_t event_type; // 事件类型 uint32_t timestamp; // 时间戳 } __attribute__((packed)); // 事件类型定义 enum button_event_type { BUTTON_PRESS, // 按键按下 BUTTON_RELEASE, // 按键释放 BUTTON_LONG_PRESS, // 长按 BUTTON_DOUBLE_CLICK, // 双击 }; ``` ## LE Audio 音频流处理 ### 音频流架构 OpenEarable基于Nordic的nRF5340 Audio应用，支持完整的LE Audio协议栈。 #### 音频流类型 ```cpp // 音频流类型 enum audio_stream_type { STREAM_TYPE_CIS, // Connected Isochronous Stream (单播) STREAM_TYPE_BIS, // Broadcast Isochronous Stream (广播) }; // 音频配置参数 struct audio_config { uint32_t sample_rate_hz; // 采样率 uint8_t channels; // 声道数 uint16_t frame_duration_us; // 帧长度 uint8_t codec_type; // 编解码器类型 uint32_t bitrate_bps; // 比特率 }; ``` #### 编解码器支持 ```cpp // 支持的编解码器 enum audio_codec { CODEC_LC3, // LC3 (LE Audio标准) CODEC_SBC, // SBC (经典蓝牙) CODEC_PCM, // 未压缩PCM }; // LC3编解码器配置 struct lc3_config { uint32_t sample_rate; // 采样率 (8000, 16000, 24000, 32000, 48000) uint16_t frame_duration; // 帧长度 (7.5ms, 10ms) uint8_t channels; // 声道数 (1, 2) uint32_t bitrate; // 比特率 (16000 320000 bps) }; ``` ## 连接管理 ### 配对和绑定 ```cpp // 配对状态管理 enum pairing_state { SET_PAIRING, // 设置配对模式 BONDING, // 正在绑定 PAIRED, // 已配对 CONNECTED, // 已连接 }; // 连接参数 struct connection_params { uint16_t interval_min; // 最小连接间隔 uint16_t interval_max; // 最大连接间隔 uint16_t latency; // 从设备延迟 uint16_t timeout; // 超时时间 }; ``` ### 安全管理 ```cpp // 安全参数 struct security_params { uint8_t auth_req; // 认证要求 uint8_t oob_flag; // OOB数据标志 uint8_t min_key_size; // 最小密钥长度 uint8_t max_key_size; // 最大密钥长度 uint8_t init_key_dist; // 初始密钥分发 uint8_t resp_key_dist; // 响应密钥分发 }; // SIRK (Set Identity Resolving Key) 管理 uint32_t uicr_sirk_get(void); // 获取SIRK int uicr_sirk_set(uint32_t sirk); // 设置SIRK ``` ## 数据传输优化 ### 数据分包传输 ```cpp // 大数据包分包传输 struct data_packet { uint8_t packet_id; // 包ID uint8_t total_packets; // 总包数 uint8_t sequence; // 序列号 uint16_t data_size; // 数据大小 uint8_t data[]; // 数据载荷 } __attribute__((packed)); // 分包传输控制 int send_large_data(const uint8_t *data, size_t size, uint16_t mtu_size); ``` ### 流量控制 ```cpp // 流量控制参数 struct flow_control { uint16_t window_size; // 窗口大小 uint16_t credit_count; // 信用计数 bool flow_enabled; // 流控使能 }; // 自适应流控 void adaptive_flow_control(uint16_t buffer_level) { if (buffer_level > HIGH_THRESHOLD) { // 缓冲区满，减少发送速率 reduce_transmission_rate(); } else if (buffer_level < LOW_THRESHOLD) { // 缓冲区空，增加发送速率 increase_transmission_rate(); } } ``` ## 功耗优化 ### 连接间隔优化 ```cpp // 动态连接间隔调整 void optimize_connection_interval() { if (high_data_rate_required()) { // 高数据传输需求，使用短连接间隔 set_connection_interval(7.5); // 7.5ms } else { // 低功耗需求，使用长连接间隔 set_connection_interval(100); // 100ms } } ``` ### 广告功耗管理 ```cpp // 广告参数优化 struct adv_params { uint16_t interval_min; // 最小广告间隔 uint16_t interval_max; // 最大广告间隔 uint8_t type; // 广告类型 uint8_t tx_power; // 发射功率 }; // 自适应广告 void adaptive_advertising() { if (battery_low()) { // 低电量时减少广告频率 set_adv_interval(1000); // 1秒 set_tx_power( 20); // 降低发射功率 } else { // 正常电量时正常广告 set_adv_interval(100); // 100ms set_tx_power(0); // 标准发射功率 } } ``` ## 错误处理和恢复 ### 连接错误处理 ```cpp // 连接错误类型 enum connection_error { CONN_ERR_TIMEOUT, // 连接超时 CONN_ERR_AUTH_FAILED, // 认证失败 CONN_ERR_PARAM_INVALID, // 参数无效 CONN_ERR_RESOURCES, // 资源不足 }; // 错误恢复策略 void handle_connection_error(enum connection_error error) { switch (error) { case CONN_ERR_TIMEOUT: // 超时错误，重新尝试连接 restart_connection(); break; case CONN_ERR_AUTH_FAILED: // 认证失败，清除配对信息 clear_bonding_info(); start_pairing_mode(); break; case CONN_ERR_PARAM_INVALID: // 参数错误，使用默认参数 reset_to_default_params(); break; default: // 通用错误，重启蓝牙栈 restart_bluetooth_stack(); break; } } ``` ### 音频流错误处理 ```cpp // 音频流错误处理 void handle_audio_stream_error(int error_code) { if (error_code AUDIO_UNDERRUN) { // 音频缓冲区下溢 increase_buffer_size(); adjust_presentation_delay(); } else if (error_code AUDIO_SYNC_LOST) { // 音频同步丢失 reinitialize_audio_sync(); } } ``` ## 配置选项 ### Kconfig配置 ```kconfig # 蓝牙基础配置 CONFIG_BT y CONFIG_BT_PERIPHERAL y CONFIG_BT_CENTRAL y CONFIG_BT_GATT_CLIENT y # LE Audio配置 CONFIG_BT_AUDIO y CONFIG_BT_BAP_UNICAST_SERVER y CONFIG_BT_BAP_BROADCAST_SINK y CONFIG_LC3_CODEC y # GATT服务配置 CONFIG_BT_GATT_DYNAMIC_DB y CONFIG_BT_GATT_SERVICE_CHANGED y # 安全配置 CONFIG_BT_SMP y CONFIG_BT_PRIVACY y CONFIG_BT_RPA y # 音频配置 CONFIG_AUDIO_SAMPLE_RATE_48000 y CONFIG_AUDIO_FRAME_DURATION_10MS y CONFIG_LC3_BITRATE_96000 y ``` ### 服务配置 ```cpp // GATT服务配置 #define MAX_SENSOR_DATA_SIZE 256 #define MAX_RECORDING_NAME_LEN 32 #define BATTERY_UPDATE_INTERVAL K_SECONDS(30) #define SENSOR_DATA_INTERVAL K_MSEC(100) // 连接配置 #define MIN_CONN_INTERVAL 6 // 7.5ms #define MAX_CONN_INTERVAL 80 // 100ms #define SLAVE_LATENCY 0 #define CONN_SUP_TIMEOUT 400 // 4s ``` ## 性能监控 ### 连接质量监控 ```cpp // 连接质量统计 struct connection_stats { uint32_t packets_sent; // 发送包数 uint32_t packets_received; // 接收包数 uint32_t packets_lost; // 丢包数 float rssi_average; // 平均RSSI uint16_t connection_interval; // 连接间隔 uint16_t slave_latency; // 从设备延迟 }; // 质量监控 void monitor_connection_quality() { struct connection_stats stats; get_connection_stats(&stats); // 计算丢包率 float packet_loss_rate (float)stats.packets_lost / (stats.packets_sent + stats.packets_lost); // 信号质量评估 if (stats.rssi_average < 80 packet_loss_rate > 0.05) { LOG_WRN(\"Poor connection quality detected\"); optimize_connection_params(); } } ``` ## 总结 蓝牙通信模块是OpenEarable 2.0的重要组成部分，具有以下特点： 1. **完整的LE Audio支持**: 基于最新的LE Audio标准，支持高质量音频传输 2. **丰富的GATT服务**: 提供传感器、电池、LED、按键等完整的设备控制接口 3. **高效数据传输**: 优化的数据分包和流量控制机制 4. **智能功耗管理**: 自适应的连接参数和广告策略 5. **可靠的错误处理**: 完善的错误检测和恢复机制 6. **安全通信**: 支持配对、绑定和加密通信 7. **性能监控**: 实时的连接质量监控和优化 该模块为OpenEarable 2.0提供了稳定可靠的无线通信能力，支持高质量音频播放、丰富的传感器数据传输和完整的设备控制功能。"},"/lhfdoc.github.io/embedded_dev/openearable/buttons-module.html":{"title":"OpenEarable 2.0 - 按键模块 (Buttons Module)","content":"# OpenEarable 2.0 按键模块 (Buttons Module) ## 概述 按键模块负责处理OpenEarable设备上的物理按键输入，包括按键事件检测、防抖处理、状态管理和事件分发。该模块为用户提供交互接口，支持播放/暂停、音量控制等功能。 ## 核心组件 ### 1. Button 类 (`Button.h/cpp`) 主要的按键抽象类，处理单个按键的完整生命周期： #### 核心接口 ```cpp class Button { public: Button(gpio_dt_spec spec); void begin(); // 初始化按键 void end(); // 清理按键资源 button_action getState() const; // 获取当前状态 private: k_work_delayable button_work; // 延时工作队列 const struct gpio_dt_spec button; // GPIO规格 static struct gpio_callback button_cb_data; // 中断回调数据 button_action _buttonState; // 当前状态 button_action _temp_buttonState; // 临时状态 static void button_isr(const struct device *dev, struct gpio_callback *cb, uint32_t pins); int update_state(); static void button_work_handler(struct k_work * work); }; ``` #### 状态管理 **BUTTON_RELEASED**: 按键释放状态 **BUTTON_PRESS**: 按键按下状态 使用防抖机制避免误触发 #### 防抖机制 ```cpp #define BUTTON_DEBOUNCE K_MSEC(10) // 10ms防抖延时 ``` 中断触发时启动延时工作 延时结束后确认状态变化 状态未变化时取消延时工作 ### 2. 按键管理器 (`button_manager.h/c`) 负责按键事件的消息队列管理和事件分发： #### 消息队列 ```c K_MSGQ_DEFINE(button_queue, sizeof(struct button_msg), 1, 4); ``` #### ZBus 通道 ```c ZBUS_CHAN_DEFINE(button_chan, struct button_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY, ZBUS_MSG_INIT(0)); ``` #### 发布线程 ```c void button_pub_task() { int ret; struct button_msg msg; while (1) { k_msgq_get(&button_queue, &msg, K_FOREVER); ret zbus_chan_pub(&button_chan, &msg, K_FOREVER); if (ret) { LOG_ERR(\"Failed to publish button msg, ret: %d\", ret); } } } K_THREAD_DEFINE(button_publish, CONFIG_BUTTON_PUBLISH_STACK_SIZE, button_pub_task, NULL, NULL, NULL, K_PRIO_PREEMPT(CONFIG_BUTTON_PUBLISH_THREAD_PRIO), 0, 0); ``` ### 3. 按键分配 (`button_assignments.h`) 定义按键映射和枚举： ```cpp enum button_pin_names { BUTTON_EARABLE DT_GPIO_PIN(DT_ALIAS(sw0), gpios), BUTTON_VOLUME_UP, // 预留 BUTTON_VOLUME_DOWN, // 预留 BUTTON_4, // 预留 BUTTON_5, // 预留 }; #define BUTTON_PLAY_PAUSE BUTTON_EARABLE // 别名定义 ``` ### 4. 按键状态查询 (`button_pressed.cpp`) 提供按键状态查询接口： ```cpp int button_pressed(enum button_pin_names pin, bool * pressed) { switch (pin) { case BUTTON_EARABLE: *pressed (earable_btn.getState() BUTTON_PRESS); return 0; default: *pressed false; return 0; } } ``` ## 工作流程 ### 1. 初始化流程 ``` Button构造 → GPIO配置 → 中断配置 → 回调注册 → 初始状态读取 ``` ### 2. 按键事件处理流程 ``` GPIO中断触发 → button_isr() → 启动延时工作 → button_work_handler() → update_state() → 消息入队 → button_pub_task() → ZBus发布 ``` ### 3. 防抖处理 ``` 中断触发 → 读取临时状态 → 如果状态相同 → 取消延时工作 如果状态不同 → 重新调度延时工作 → 延时后确认状态变化 ``` ## 硬件接口 ### GPIO 配置 使用设备树别名 `sw0` 定义主按键 配置为输入模式 (`GPIO_INPUT`) 启用双边沿中断 (`GPIO_INT_EDGE_BOTH`) ### 中断处理 共享中断回调函数 `button_isr` 支持多按键扩展（当前仅实现主按键） 中断安全的状态更新 ## 配置选项 ### Kconfig 配置 ``` CONFIG_BUTTON_PUBLISH_STACK_SIZE # 发布线程栈大小 CONFIG_BUTTON_PUBLISH_THREAD_PRIO # 发布线程优先级 CONFIG_MODULE_BUTTON_HANDLER_LOG_LEVEL # 日志级别 ``` ### 设备树配置 ```dts aliases { sw0 &button0; // 主按键别名 }; ``` ## 扩展性设计 ### 多按键支持 代码中预留了多个按键的实现框架 可通过取消注释轻松添加音量按键等 支持不同按键的独立处理 ### 按键功能映射 通过 `button_assignments.h` 集中管理按键功能 支持别名定义，便于功能重映射 可扩展复杂按键组合功能 ## 集成接口 ### ZBus 消息 ```cpp struct button_msg { uint32_t button_pin; // 按键引脚 button_action button_action; // 按键动作 }; ``` ### 订阅者接口 其他模块可通过ZBus订阅按键事件： ```c ZBUS_SUBSCRIBER_DEFINE(button_sub, 1); ZBUS_CHAN_ADD_OBS(button_chan, button_sub, 0); ``` ## 日志和调试 ### 日志模块 ```c LOG_MODULE_REGISTER(button, CONFIG_MODULE_BUTTON_HANDLER_LOG_LEVEL); ``` ### 关键日志点 按键状态变化记录 消息队列满警告 GPIO配置错误 中断配置失败 ## 功耗优化 ### 中断驱动 使用GPIO中断而非轮询 按键空闲时零功耗 中断唤醒系统 ### 工作队列优化 使用延时工作队列进行防抖 避免持续CPU占用 适当的线程优先级配置 ## 错误处理 ### GPIO 错误 设备就绪检查 引脚配置失败处理 中断配置错误处理 ### 消息队列错误 队列满时的警告日志 发布失败的错误处理 资源竞争保护 ## 典型使用场景 ### 1. 播放/暂停控制 ```cpp // 在音频模块中订阅按键事件 void audio_button_handler(const struct zbus_channel *chan) { struct button_msg msg; zbus_chan_read(chan, &msg, K_FOREVER); if (msg.button_pin BUTTON_EARABLE && msg.button_action BUTTON_PRESS) { // 执行播放/暂停逻辑 toggle_playback(); } } ``` ### 2. 系统状态切换 ```cpp // 在状态管理模块中处理按键 void state_button_handler(const struct zbus_channel *chan) { struct button_msg msg; zbus_chan_read(chan, &msg, K_FOREVER); if (msg.button_pin BUTTON_EARABLE && msg.button_action BUTTON_PRESS) { // 状态切换或功能激活 switch_system_state(); } } ``` ## 总结 按键模块提供了完整的物理按键交互支持，具有以下特点： 1. **可靠性**: 硬件防抖和软件状态确认 2. **扩展性**: 支持多按键和复杂功能映射 3. **高效性**: 中断驱动和事件发布机制 4. **集成性**: 通过ZBus与其他模块无缝集成 5. **低功耗**: 中断唤醒和适当的线程调度 该模块为OpenEarable设备的用户交互提供了稳定可靠的基础设施。"},"/lhfdoc.github.io/embedded_dev/openearable/deployment.html":{"title":"部署指南","content":"# 部署指南 ## 概述 本指南介绍如何将 OpenEarable 2.0 文档网站部署到各种平台，包括 GitHub Pages、Netlify、Vercel 等。 ## 构建生产版本 在部署之前，需要构建生产版本的文档： ```bash # 进入项目目录 cd my_site # 构建文档 teedoc build # 构建完成后，静态文件位于 out/ 目录 ``` ## GitHub Pages 部署 ### 方法一：GitHub Actions 自动部署 1. **创建 GitHub Actions 工作流** 在项目根目录创建 `.github/workflows/deploy.yml`： ```yaml name: Deploy to GitHub Pages on: push: branches: [ main ] pull_request: branches: [ main ] jobs: build and deploy: runs on: ubuntu latest steps: uses: actions/checkout@v3 name: Setup Python uses: actions/setup python@v4 with: python version: '3.9' name: Install dependencies run: cd docs pip install r requirements.txt name: Build documentation run: cd docs/my_site teedoc build name: Deploy to GitHub Pages uses: peaceiris/actions gh pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs/my_site/out ``` 2. **配置 GitHub Pages** 进入 GitHub 仓库设置 找到 \"Pages\" 选项 选择 \"Deploy from a branch\" 选择 \"gh pages\" 分支 ### 方法二：手动部署 1. **构建文档** ```bash cd docs/my_site teedoc build ``` 2. **推送到 gh pages 分支** ```bash # 创建并切换到 gh pages 分支 git checkout orphan gh pages # 复制构建文件 cp r docs/my_site/out/* . # 提交并推送 git add . git commit m \"Deploy documentation\" git push origin gh pages ``` ## Netlify 部署 ### 方法一：Git 集成部署 1. **连接 GitHub 仓库** 登录 Netlify 选择 \"New site from Git\" 连接 GitHub 仓库 2. **配置构建设置** Build command: `cd docs && pip install r requirements.txt && cd my_site && teedoc build` Publish directory: `docs/my_site/out` Base directory: `/` 3. **创建 netlify.toml** ```toml [build] command \"cd docs && pip install r requirements.txt && cd my_site && teedoc build\" publish \"docs/my_site/out\" [build.environment] PYTHON_VERSION \"3.9\" ``` ### 方法二：手动部署 1. **构建文档** ```bash cd docs/my_site teedoc build ``` 2. **上传到 Netlify** 将 `out/` 目录打包为 zip 文件 在 Netlify 控制台手动上传 ## Vercel 部署 1. **创建 vercel.json** ```json { \"version\": 2, \"builds\": [ { \"src\": \"docs/my_site/build.py\", \"use\": \"@vercel/python\" } ], \"routes\": [ { \"src\": \"/(.*)\", \"dest\": \"/docs/my_site/out/$1\" } ] } ``` 2. **创建构建脚本** ```python # docs/my_site/build.py import subprocess import os os.chdir('docs') subprocess.run(['pip', 'install', ' r', 'requirements.txt']) os.chdir('my_site') subprocess.run(['teedoc', 'build']) ``` ## 自定义域名 ### 配置 CNAME 1. **添加 CNAME 文件** ```bash # 在 out/ 目录创建 CNAME 文件 echo \"docs.openearable.com\" > docs/my_site/out/CNAME ``` 2. **配置 DNS** 在域名服务商添加 CNAME 记录 指向 GitHub Pages 或部署平台的域名 ### 更新配置 修改 `site_config.json`： ```json { \"site_domain\": \"docs.openearable.com\", \"site_protocol\": \"https\", \"site_root_url\": \"/\" } ``` ## 性能优化 ### 启用压缩 大多数托管平台都支持 Gzip 压缩，确保已启用： ```json // netlify.toml [[headers]] for \"/*\" [headers.values] Content Encoding \"gzip\" ``` ### CDN 加速 使用 CDN 加速静态资源： ```json // site_config.json { \"plugins\": { \"teedoc plugin assets\": { \"config\": { \"header_items\": [ \"<link rel \\\"preload\\\" href \\\"/static/css/main.css\\\" as \\\"style\\\">\", \"<link rel \\\"dns prefetch\\\" href \\\"//fonts.googleapis.com\\\">\" ] } } } } ``` ## 监控和维护 ### 构建状态监控 设置 GitHub Actions 通知 监控部署状态 配置错误报告 ### 定期更新 ```bash # 更新依赖 pip install upgrade teedoc # 重新构建 teedoc build ``` ## 故障排除 ### 常见问题 **问题**：构建失败 **解决**：检查 Python 版本和依赖包版本 **问题**：样式丢失 **解决**：检查静态文件路径配置 **问题**：搜索不工作 **解决**：确保搜索索引文件已正确生成 ### 调试技巧 1. **本地测试** ```bash # 本地构建测试 teedoc build teedoc serve ``` 2. **检查日志** ```bash # 查看构建日志 teedoc build verbose ``` 3. **验证配置** ```bash # 验证配置文件 python m json.tool site_config.json ``` ## 备份和恢复 ### 备份策略 1. **源码备份**：定期推送到 Git 仓库 2. **构建备份**：保存构建产物 3. **配置备份**：备份重要配置文件 ### 恢复流程 1. **从 Git 恢复** ```bash git clone <repository> cd docs pip install r requirements.txt cd my_site teedoc build ``` 2. **重新部署** ```bash # 根据选择的部署方式重新部署 ``` ## 参考资源 [GitHub Pages 文档](https://docs.github.com/en/pages) [Netlify 文档](https://docs.netlify.com/) [Vercel 文档](https://vercel.com/docs) [TeeDoc 部署指南](https://teedoc.github.io/)"},"/lhfdoc.github.io/embedded_dev/openearable/teedoc-guide.html":{"title":"TeeDoc 快速启动指南","content":"# TeeDoc 快速启动指南 ## 简介 TeeDoc 是一个基于 Python 的静态文档生成器，可以将 Markdown 文档转换为美观的静态网站。本指南将帮助你快速启动 OpenEarable 2.0 项目的文档网站。 ## 环境要求 Python 3.7 或更高版本 pip 包管理器 ## 快速启动 ### 方法一：使用启动脚本（推荐） 我们提供了自动化的启动脚本，可以一键完成环境配置和文档构建。 #### Windows 用户 ```bash # 双击运行或在命令行中执行 .\\启动TeeDoc服务器.bat ``` #### Linux/macOS 用户 ```bash # 给脚本添加执行权限 chmod +x 启动TeeDoc服务器.sh # 运行脚本 ./启动TeeDoc服务器.sh ``` ### 方法二：手动启动 如果你希望手动控制每个步骤，可以按照以下步骤操作： 1. **创建虚拟环境** ```bash python m venv venv ``` 2. **激活虚拟环境** ```bash # Windows venv\\Scripts\\activate # Linux/macOS source venv/bin/activate ``` 3. **安装依赖包** ```bash pip install r requirements.txt ``` 4. **构建文档** ```bash cd my_site teedoc build ``` 5. **启动服务器** ```bash teedoc serve ``` ## 访问文档 启动成功后，在浏览器中访问： 本地地址：http://127.0.0.1:2333 或者：http://localhost:2333 !!! tip \"小贴士\" 首次启动可能需要几分钟时间安装依赖包，请耐心等待。 ## 文档结构 ``` my_site/ ├── site_config.json # 网站主配置文件 ├── docs/ # 文档目录 │ ├── guide/ # 项目指南 │ │ ├── config.json │ │ ├── sidebar.yaml │ │ └── *.md │ └── modules/ # 模块文档 │ ├── config.json │ ├── sidebar.yaml │ └── *.md ├── static/ # 静态资源 └── out/ # 构建输出目录 ``` ## 编辑文档 1. **添加新文档**：在对应目录下创建 `.md` 文件 2. **修改导航**：编辑 `sidebar.yaml` 文件 3. **更新配置**：修改 `config.json` 文件 4. **重新构建**：运行 `teedoc build` 命令 ## 常见问题 ### 启动失败 **问题**：提示 Python 未找到 **解决**：确保已安装 Python 3.7+ 并添加到系统 PATH **问题**：端口被占用 **解决**：修改 `site_config.json` 中的端口配置 ### 构建错误 **问题**：Markdown 语法错误 **解决**：检查 `.md` 文件的语法，特别是代码块和表格 **问题**：配置文件错误 **解决**：检查 `config.json` 和 `sidebar.yaml` 的 JSON/YAML 语法 ## 更多功能 **搜索功能**：支持全文搜索 **主题切换**：支持暗色/亮色主题 **多语言**：支持中英文切换 **响应式设计**：适配移动设备 ## 参考资源 [TeeDoc 官方文档](https://teedoc.github.io/) [Markdown 语法参考](https://www.markdownguide.org/) [OpenEarable 项目主页](https://github.com/OpenEarable)"},"/lhfdoc.github.io/embedded_dev/openearable/battery-module.html":{"title":"电源管理模块详细分析","content":"# 电源管理模块详细分析 ## 模块概述 电源管理模块是OpenEarable 2.0的核心组件之一，负责整个系统的电源状态管理、电池监控、充电控制等功能。该模块采用了双芯片架构，通过BQ27220燃料计量芯片和BQ25120a充电管理芯片实现完整的电源解决方案。 ## 文件结构 ``` src/Battery/ ├── PowerManager.h/.cpp # 电源管理器主类 ├── BQ27220.h/.cpp # 燃料计量芯片驱动 ├── BQ25120a.h/.cpp # 充电管理芯片驱动 ├── BootState.h/.c # 启动状态管理 ├── CMakeLists.txt # 构建配置 └── Kconfig # 配置选项 ``` ## 核心类分析 ### 1. PowerManager 类 PowerManager是电源管理的核心类，负责协调各个电源组件的工作。 #### 主要功能 **系统电源控制**: 开关机、重启等 **充电状态监控**: 实时监控充电状态变化 **电池状态管理**: 电量、健康状态、温度等 **电源异常处理**: 低电量保护、充电故障处理 **LED状态指示**: 通过LED显示电源状态 #### 关键方法 ```cpp class PowerManager { public: int begin(); // 初始化电源管理器 int power_down(bool fault); // 系统关机 void reboot(); // 系统重启 // 状态查询接口 void get_battery_status(battery_level_status &status); void get_energy_status(battery_energy_status &status); void get_health_status(battery_health_status &status); void set_error_led(int val); // 错误LED控制 }; ``` #### 工作队列架构 PowerManager使用Zephyr的工作队列系统实现异步任务处理： ```cpp // 延迟工作队列定义 K_WORK_DELAYABLE_DEFINE(PowerManager::charge_ctrl_delayable, charge_ctrl_work_handler); K_WORK_DELAYABLE_DEFINE(PowerManager::power_down_work, power_down_work_handler); // 即时工作队列定义 K_WORK_DEFINE(PowerManager::fuel_gauge_work, fuel_gauge_work_handler); K_WORK_DEFINE(PowerManager::battery_controller_work, battery_controller_work_handler); ``` #### 中断处理机制 ```cpp // 燃料计量芯片中断处理 void fuel_gauge_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins); // 充电控制芯片中断处理 void battery_controller_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins); // 电源连接状态中断处理 void power_good_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins); ``` ### 2. BQ27220 燃料计量芯片驱动 BQ27220是德州仪器(TI)的单节锂离子电池燃料计量芯片，提供精确的电池状态信息。 #### 主要功能 **电池状态监控**: 电压、电流、温度、电量百分比 **电池健康评估**: 循环次数、健康状态、剩余容量 **安全保护**: 过压、欠压、过温保护 **校准功能**: 支持电池容量校准 #### 寄存器定义 ```cpp enum registers : uint8_t { CTRL 0x00, // 控制寄存器 TEMP 0x06, // 温度寄存器 VOLT 0x08, // 电压寄存器 AI 0x14, // 平均电流寄存器 FLAGS 0x0A, // 状态标志寄存器 NAC 0x0C, // 标称可用容量 FCC 0x12, // 满充容量 SOC 0x2C, // 电量百分比 SOH 0x2E, // 健康状态 }; ``` #### 电池状态结构 ```cpp struct bat_status { bool DSG; // 放电状态 bool SYSDWN; // 系统关机电压 bool TDA; // 温度数据可用 bool BATTPRES; // 电池存在 bool AUTH_GD; // 认证良好 bool OCVGD; // 开路电压良好 bool TCA; // 温度补偿可用 bool CHGINH; // 充电禁止 bool FC; // 充电完成 bool OTD; // 放电过温 bool OTC; // 充电过温 bool SLEEP; // 睡眠模式 bool OCVFAIL; // 开路电压失败 bool OCVCOMP; // 开路电压补偿 bool FD; // 完全放电 }; ``` #### 关键方法 ```cpp class BQ27220 { public: int begin(); // 初始化芯片 float voltage(); // 读取电压 float current(); // 读取电流 float temperature(); // 读取温度 float state_of_charge(); // 读取电量百分比 float state_of_health(); // 读取健康状态 bat_status battery_status(); // 读取电池状态 gauge_status gauging_state(); // 读取计量状态 int calibration_enter(); // 进入校准模式 int calibration_exit(); // 退出校准模式 int config_update_enter(); // 进入配置更新模式 int config_update_exit(); // 退出配置更新模式 }; ``` ### 3. BQ25120a 充电管理芯片驱动 BQ25120a是TI的低功耗线性充电管理芯片，专为便携式设备设计。 #### 主要功能 **充电控制**: 恒流/恒压充电，充电电流可调 **电源路径管理**: 支持边充边用 **按键检测**: 集成按键检测功能 **负载开关**: 集成LDO和负载开关 **安全保护**: 过压、过流、过温保护 #### 寄存器定义 ```cpp enum registers : uint8_t { CTRL 0x00, // 控制寄存器 FAULT 0x01, // 故障状态寄存器 TS_FAULT 0x02, // 温度传感器故障寄存器 CHARGE_CTRL 0x03, // 充电控制寄存器 TERM_CTRL 0x04, // 终止控制寄存器 BAT_VOL_CTRL 0x05, // 电池电压控制寄存器 LS_LDO_CTRL 0x07, // 负载开关/LDO控制寄存器 BTN_CTRL 0x08, // 按键控制寄存器 ILIM_UVLO 0x09 // 输入限流/欠压锁定寄存器 }; ``` #### 充电状态结构 ```cpp struct chrg_state { float mAh; // 充电电流(mA) bool enabled; // 充电使能 bool high_impedance; // 高阻抗模式 }; struct button_state { bool wake_1; // 唤醒按键1状态 bool wake_2; // 唤醒按键2状态 }; ``` #### 关键方法 ```cpp class BQ25120a { public: int begin(); // 初始化芯片 // 电源控制 bool power_connected(); // 检测电源连接 void enter_high_impedance(); // 进入高阻抗模式 void exit_high_impedance(); // 退出高阻抗模式 // 充电控制 void disable_charge(); // 禁用充电 void enable_charge(); // 使能充电 uint8_t read_charging_state(); // 读取充电状态 // 故障检测 uint8_t read_fault(); // 读取故障状态 uint8_t read_ts_fault(); // 读取温度传感器故障 // 按键检测 button_state read_button_state(); // 读取按键状态 // 回调设置 int set_power_connect_callback(gpio_callback_handler_t handler); int set_int_callback(gpio_callback_handler_t handler); }; ``` ## 电源管理状态机 ### 充电状态定义 ```cpp enum charging_state { DISCHARGING, // 放电状态 POWER_CONNECTED, // 电源已连接 PRECHARGING, // 预充电状态 CHARGING, // 正在充电 TRICKLE_CHARGING, // 涓流充电 FULLY_CHARGED, // 充电完成 BATTERY_LOW, // 电池低电量 BATTERY_CRITICAL, // 电池严重低电量 FAULT // 故障状态 }; ``` ### 状态转换逻辑 ```cpp void PowerManager::charge_task() { // 读取充电状态 uint16_t charging_state battery_controller.read_charging_state() >> 6; switch (charging_state) { case 0: // 放电状态 msg.charging_state DISCHARGING; // 检查低电量状态 gauge_status gs fuel_gauge.gauging_state(); if (gs.edv2) msg.charging_state BATTERY_LOW; if (gs.edv1) msg.charging_state BATTERY_CRITICAL; break; case 1: // 充电状态 // 检查系统关机电压 if (bat.SYSDWN) { msg.charging_state PRECHARGING; break; } // 分析充电参数 float current fuel_gauge.current(); float target_current fuel_gauge.charge_current(); float voltage fuel_gauge.voltage(); // 判断具体充电阶段 if (current > 0.8 * target_current 2 * i_term) { msg.charging_state CHARGING; } else if (voltage > u_term 0.02) { msg.charging_state TRICKLE_CHARGING; } break; case 2: // 充电完成 msg.charging_state FULLY_CHARGED; break; case 3: // 故障状态 msg.charging_state FAULT; break; } } ``` ## LED状态指示 ### 充电状态LED LED状态 描述 🟥 红色常亮 电池故障或深度放电 🔴 红色脉冲 预充电阶段 🟧 橙色常亮 电源连接，充电电流未达到目标 🟠 橙色脉冲 充电电流达到目标的80% 🟢 绿色脉冲 涓流充电 🟩 绿色常亮 充电完成 ### 放电状态LED LED状态 描述 🟠 橙色闪烁 电池低电量(7%剩余) 🔴 红色闪烁 电池严重低电量(3%剩余) ## 配置参数 ### 电池参数配置 ```cpp struct battery_settings { uint16_t capacity_mAh; // 电池容量(mAh) uint16_t nominal_voltage_mV; // 标称电压(mV) uint16_t max_voltage_mV; // 最大电压(mV) uint16_t charge_current_mA; // 充电电流(mA) uint16_t taper_current_mA; // 涓流充电电流(mA) float u_term; // 终止电压(V) float i_term; // 终止电流(mA) }; ``` ### Kconfig配置选项 ```kconfig CONFIG_BATTERY_CHARGE_CONTROLLER_NORMAL_INTERVAL_SECONDS 5 CONFIG_BATTERY_ENABLE_LOW_STATE y CONFIG_BATTERY_ENABLE_TRICKLE_CHARGE y ``` ## 消息总线集成 电源管理模块使用Zephyr的ZBus消息总线与其他模块通信： ```cpp // 定义电池数据通道 ZBUS_CHAN_DEFINE(battery_chan, struct battery_data, NULL, NULL, ZBUS_OBSERVERS_EMPTY, ZBUS_MSG_INIT(0)); // 电池数据结构 struct battery_data { float battery_level; // 电量百分比 enum charging_state charging_state; // 充电状态 }; ``` ## 错误处理机制 ### 故障检测 ```cpp void PowerManager::handle_fault(uint8_t fault_code) { // 设置错误LED set_error_led(1); // 记录故障信息 LOG_ERR(\"Battery fault detected: 0x%02X\", fault_code); // 根据故障类型采取措施 switch (fault_code) { case OVER_TEMP_FAULT: disable_charging(); break; case OVER_VOLTAGE_FAULT: emergency_shutdown(); break; // ... 其他故障处理 } } ``` ### 低电量保护 ```cpp void PowerManager::check_low_battery() { if (power_on && battery_status.SYSDWN) { LOG_WRN(\"Battery reached system down voltage.\"); k_work_reschedule(&power_down_work, K_NO_WAIT); } } ``` ## 性能优化 ### 功耗优化 使用高阻抗模式减少待机功耗 动态调整监控间隔 智能电源路径管理 ### 精度优化 电池参数校准 温度补偿 老化补偿算法 ## 总结 电源管理模块通过双芯片架构实现了完整的电源解决方案，具有以下特点： 1. **完整的电源状态监控**: 电量、电压、电流、温度等参数实时监控 2. **智能充电管理**: 支持多阶段充电和各种保护功能 3. **用户友好的状态指示**: 通过LED直观显示电源状态 4. **系统集成友好**: 通过消息总线与其他模块通信 5. **安全可靠**: 多重保护机制确保系统安全 该模块为OpenEarable 2.0提供了稳定可靠的电源基础，支持长时间运行和安全的充电体验。"},"/lhfdoc.github.io/embedded_dev/openearable/wire-module.html":{"title":"OpenEarable 2.0 - I2C通信模块 (Wire Module)","content":"# OpenEarable 2.0 I2C通信模块 (Wire Module) ## 概述 I2C通信模块为OpenEarable设备提供了Arduino风格的I2C通信接口，基于Zephyr RTOS的I2C驱动实现。该模块封装了底层的I2C硬件操作，为上层驱动和应用提供了简洁易用的通信接口。 ## 核心组件 ### 1. Arduino风格I2C接口 (`Wire.h/cpp`) 提供与Arduino Wire库兼容的I2C接口： #### 核心类定义 ```cpp class MbedI2C { public: MbedI2C(const struct device * master); // 基本操作 virtual void begin(uint32_t speed I2C_SPEED_FAST); virtual void end(); virtual void setClock(uint32_t freq); // 传输操作 virtual void beginTransmission(uint8_t address); virtual uint8_t endTransmission(bool stopBit true); virtual size_t requestFrom(uint8_t address, size_t len, bool stopBit true); // 数据操作 virtual size_t write(uint8_t data); virtual size_t write(const uint8_t* data, int len); virtual int read(); virtual int peek(); virtual void flush(); virtual int available(); // 回调设置 virtual void onReceive(void(*)(int)); virtual void onRequest(void(*)(void)); // 资源管理 void aquire(); void release(); private: const struct device * master; struct k_mutex mutex; // 缓冲区 char buf[BUFFER_RX_SIZE]; RingBufferN<BUFFER_RX_SIZE> rxBuffer; uint8_t txBuffer[BUFFER_TX_SIZE]; uint32_t usedTxBuffer; // 底层操作 int master_read(int address, const char * buf, const uint32_t len, bool no_stop); int master_write(int address, const char * buf, const uint32_t len, bool no_stop); int i2c_message(uint8_t read_write, int address, const char * buf, const uint32_t len, bool no_stop); }; ``` #### 配置参数 ```cpp #define BUFFER_TX_SIZE 256 // 发送缓冲区大小 #define BUFFER_RX_SIZE 512 // 接收缓冲区大小 ``` ### 2. 基础I2C管理 (`TWIM.h/cpp`) 提供更底层的I2C管理接口： ```cpp class TWIM { public: TWIM(const struct device * master); virtual void begin(); virtual void end(); virtual void setClock(uint32_t speed I2C_SPEED_FAST); void aquire(); void release(); const struct device * master; private: struct k_mutex mutex; }; ``` ### 3. 环形缓冲区 (`RingBuffer.h`) 用于I2C数据缓冲的环形缓冲区实现： ```cpp template<int N> class RingBufferN { private: uint8_t _buffer[N]; volatile int _head; volatile int _tail; public: void store_char(uint8_t c); int read_char(); int available(); int peek(); void clear(); bool isFull(); }; ``` ## 工作机制 ### 1. 初始化流程 ```cpp void MbedI2C::begin(uint32_t speed) { // 1. 检查设备就绪状态 if (!device_is_ready(master)) { LOG_ERR(\"I2C device not ready\"); return; } // 2. 配置I2C时钟速度 setClock(speed); // 3. 初始化缓冲区 rxBuffer.clear(); usedTxBuffer 0; // 4. 初始化互斥锁 k_mutex_init(&mutex); } ``` ### 2. 数据传输流程 #### 主机写操作 ```cpp void beginTransmission(uint8_t address) { _address address; usedTxBuffer 0; // 清空发送缓冲区 } size_t write(uint8_t data) { if (usedTxBuffer < BUFFER_TX_SIZE) { txBuffer[usedTxBuffer++] data; return 1; } return 0; } uint8_t endTransmission(bool stopBit) { int ret master_write(_address, (const char*)txBuffer, usedTxBuffer, !stopBit); usedTxBuffer 0; return (ret 0) ? 0 : 4; // 0 成功, 4 其他错误 } ``` #### 主机读操作 ```cpp size_t requestFrom(uint8_t address, size_t len, bool stopBit) { char buffer[len]; int ret master_read(address, buffer, len, !stopBit); if (ret 0) { // 将数据存入环形缓冲区 for (size_t i 0; i < len; i++) { rxBuffer.store_char(buffer[i]); } return len; } return 0; } int read() { return rxBuffer.read_char(); } ``` ### 3. 底层I2C操作 ```cpp int i2c_message(uint8_t read_write, int address, const char * buf, const uint32_t len, bool no_stop) { struct i2c_msg msg; msg.buf (uint8_t*)buf; msg.len len; msg.flags read_write; if (no_stop) { msg.flags I2C_MSG_STOP; } return i2c_transfer(master, &msg, 1, address); } ``` ## 线程安全 ### 互斥锁保护 ```cpp void aquire() { k_mutex_lock(&mutex, K_FOREVER); } void release() { k_mutex_unlock(&mutex); } ``` ### 典型使用模式 ```cpp wire.aquire(); wire.beginTransmission(device_address); wire.write(register_address); wire.write(data); wire.endTransmission(); wire.release(); ``` ## 缓冲区管理 ### 发送缓冲区 固定大小256字节 在 `beginTransmission` 时清空 在 `endTransmission` 时发送 ### 接收缓冲区 使用环形缓冲区，大小512字节 支持流式数据接收 提供 `available()` 查询可读数据量 ### 环形缓冲区操作 ```cpp template<int N> void RingBufferN<N>::store_char(uint8_t c) { int next_head (_head + 1) % N; if (next_head ! _tail) { _buffer[_head] c; _head next_head; } } template<int N> int RingBufferN<N>::read_char() { if (_head _tail) { return 1; // 缓冲区空 } uint8_t c _buffer[_tail]; _tail (_tail + 1) % N; return c; } ``` ## 错误处理 ### 设备状态检查 ```cpp if (!device_is_ready(master)) { LOG_ERR(\"I2C master device %s not ready\", master >name); return ENODEV; } ``` ### 传输错误处理 ```cpp int ret i2c_transfer(master, msgs, num_msgs, addr); if (ret ! 0) { LOG_ERR(\"I2C transfer failed: %d\", ret); return ret; } ``` ### 缓冲区溢出保护 ```cpp size_t write(const uint8_t* data, int len) { size_t written 0; for (int i 0; i < len && usedTxBuffer < BUFFER_TX_SIZE; i++) { txBuffer[usedTxBuffer++] data[i]; written++; } return written; } ``` ## 设备集成 ### 设备树配置 ```dts &i2c0 { status \"okay\"; clock frequency <I2C_BITRATE_FAST>; sensor@48 { compatible \"example,sensor\"; reg <0x48>; }; }; ``` ### 驱动实例化 ```cpp // 获取I2C设备 const struct device *i2c_dev DEVICE_DT_GET(DT_NODELABEL(i2c0)); // 创建Wire实例 MbedI2C wire(i2c_dev); // 初始化 wire.begin(I2C_SPEED_FAST); ``` ## 典型应用场景 ### 1. 传感器数据读取 ```cpp // 读取传感器寄存器 uint8_t readSensorRegister(uint8_t addr, uint8_t reg) { wire.aquire(); wire.beginTransmission(addr); wire.write(reg); wire.endTransmission(false); // 重复启动 wire.requestFrom(addr, 1); uint8_t data wire.read(); wire.release(); return data; } ``` ### 2. 传感器配置写入 ```cpp // 写入传感器寄存器 void writeSensorRegister(uint8_t addr, uint8_t reg, uint8_t value) { wire.aquire(); wire.beginTransmission(addr); wire.write(reg); wire.write(value); wire.endTransmission(); wire.release(); } ``` ### 3. 批量数据传输 ```cpp // 读取多个连续寄存器 void readMultipleRegisters(uint8_t addr, uint8_t startReg, uint8_t* buffer, size_t len) { wire.aquire(); wire.beginTransmission(addr); wire.write(startReg); wire.endTransmission(false); wire.requestFrom(addr, len); for (size_t i 0; i < len; i++) { buffer[i] wire.read(); } wire.release(); } ``` ## 性能优化 ### 时钟配置 ```cpp void setClock(uint32_t freq) { struct i2c_config config; config.frequency freq; config.flags I2C_MODE_MASTER; i2c_configure(master, &config); } ``` ### 支持的时钟速度 **I2C_SPEED_STANDARD**: 100 kHz **I2C_SPEED_FAST**: 400 kHz **I2C_SPEED_FAST_PLUS**: 1 MHz ### 缓冲区优化 合理的缓冲区大小配置 避免频繁的小数据传输 批量操作提高效率 ## 调试支持 ### 日志记录 ```cpp #include <zephyr/logging/log.h> LOG_MODULE_REGISTER(wire, CONFIG_WIRE_LOG_LEVEL); LOG_DBG(\"I2C write to 0x%02x: %d bytes\", address, len); LOG_ERR(\"I2C transfer failed: %d\", ret); ``` ### 状态监控 传输成功/失败统计 缓冲区使用情况监控 设备响应时间测量 ## 总结 I2C通信模块提供了完整的I2C通信支持，具有以下特点： 1. **兼容性**: Arduino Wire库兼容接口 2. **可靠性**: 完整的错误处理和状态检查 3. **高效性**: 优化的缓冲区管理和批量传输 4. **线程安全**: 互斥锁保护的并发访问 5. **灵活性**: 支持多种时钟速度和传输模式 该模块为OpenEarable设备的传感器和外设通信提供了稳定可靠的I2C通信基础设施。"},"/lhfdoc.github.io/embedded_dev/openearable/project-overview.html":{"title":"OpenEarable 2.0 项目总结","content":"# OpenEarable 2.0 项目总结 ## 项目概述 OpenEarable 2.0 是世界上第一个完全开源的人工智能耳戴式传感应用平台，具备真正的无线音频功能。该项目基于 nRF5340 系统级芯片构建，集成了史无前例的高精度传感器阵列，为可穿戴技术重新定义了可能性。OpenEarable 专为开发和研究应用而设计，具有模块化、可重构的特点，面向未来。 ### 开发架构说明 !!! note \"重要理解\" OpenEarable 项目采用了基于 Nordic nRF5340 Audio DK 的开发模式： **基础平台**: 复用了 nRF5340 Audio DK 的音频处理固件和协议栈 **硬件定制**: 在自定义的 OpenEarable v2 PCB 上实现 **功能扩展**: 在成熟音频功能基础上，添加了丰富的传感器集成和AI处理能力 这种开发模式的优势是能够快速获得稳定的音频处理能力，同时专注于传感器数据处理和应用层创新。 ## 硬件架构 ### 核心硬件 **主控芯片**: nRF5340 双核处理器 应用核心：运行 Bluetooth LE 主机和应用层 网络核心：运行 SoftDevice 控制器 **参考开发板**: nRF5340 Audio DK (PCA10121) 用于固件开发和验证 **目标硬件**: OpenEarable v2 自定义PCB 最终产品硬件 **音频编解码器**: ADAU1860 硬件编解码器 **传感器**: 集成多种高精度传感器（这是相对于标准Audio DK的主要扩展） ### 硬件开发策略 项目采用\"参考设计 → 自定义硬件\"的开发模式： 1. **第一阶段**: 在 nRF5340 Audio DK 上开发和验证音频功能 2. **第二阶段**: 设计 OpenEarable v2 自定义PCB，增加传感器阵列 3. **第三阶段**: 将在DK上验证的固件适配到自定义硬件 !!! info \"关键区别\" **nRF5340 Audio DK**: 标准音频开发板，主要用于音频应用开发 **OpenEarable v2**: 自定义硬件，在音频功能基础上集成了丰富的传感器 ### 支持的音频模式 1. **Connected Isochronous Stream (CIS)** 单播模式 双向通信协议 支持立体声同步播放 网关到耳机的连接音频流 2. **Broadcast Isochronous Stream (BIS)** 广播模式 单向通信协议 支持 Auracast™ 广播 无限制接收器数量 ## 软件架构 ### 固件架构 基于 Zephyr RTOS 的模块化架构： ``` ┌─────────────────────────────────────────────────────────────┐ │ 应用层 (Application Layer) │ ├─────────────────────────────────────────────────────────────┤ │ 单播服务器 │ 广播接收器 │ 传感器管理 │ AI推理 │ │ (Unicast) │ (Broadcast) │ (Sensors) │ (EdgeML) │ ├─────────────────────────────────────────────────────────────┤ │ 中间件层 (Middleware) │ ├─────────────────────────────────────────────────────────────┤ │ 音频处理 │ 蓝牙协议栈 │ 传感器融合 │ 数据存储 │ │ (Audio) │ (Bluetooth) │ (Fusion) │ (Storage) │ ├─────────────────────────────────────────────────────────────┤ │ 驱动层 (Driver Layer) │ ├─────────────────────────────────────────────────────────────┤ │ ADAU1860 │ IMU传感器 │ I2C/SPI │ GPIO控制 │ │ (Codec) │ (Sensors) │ (Comm) │ (Control) │ ├─────────────────────────────────────────────────────────────┤ │ 硬件抽象层 (HAL) │ ├─────────────────────────────────────────────────────────────┤ │ Zephyr RTOS │ └─────────────────────────────────────────────────────────────┘ ``` ### 关键软件组件 #### 音频处理系统 **LE Audio 协议栈**: 完整的 Bluetooth LE Audio 实现 **流控制**: 音频流的启动、停止、同步控制 **编解码处理**: 硬件加速的音频编解码 **质量控制**: 自适应音频质量和错误恢复 #### 传感器管理系统 **多传感器融合**: IMU、环境传感器、生物传感器 **实时处理**: 高频数据采集和处理 **AI推理**: 边缘机器学习模型推理 **数据存储**: 高效的数据记录和管理 #### 通信系统 **GATT服务**: 标准化的设备信息和传感器数据服务 **数据同步**: 实时数据传输和同步 **连接管理**: 多设备连接和状态管理 ## 主要功能特性 ### 🎵 音频功能 **LE Audio 支持**: 完整的 Bluetooth LE Audio 协议栈 **立体声播放**: 左右声道同步播放 **双向通信**: 支持语音通话和音频传输 **低延迟**: 优化的音频延迟控制 **高音质**: 硬件加速的音频处理 ### 📡 传感器功能 **多传感器融合**: 集成多种高精度传感器 **实时数据处理**: 高频传感器数据采集 **AI边缘推理**: 本地机器学习模型推理 **数据存储**: 支持 SD 卡数据记录 **低功耗设计**: 优化的传感器功耗管理 ### 🔗 连接功能 **蓝牙 5.3**: 最新的蓝牙标准支持 **多设备连接**: 支持同时连接多个设备 **自动重连**: 智能的连接恢复机制 **数据同步**: 实时传感器数据传输 ### ⚡ 电源管理 **电池监控**: 实时电池状态监测 **充电管理**: 智能充电控制 **功耗优化**: 多级功耗管理策略 **低电量保护**: 自动低功耗模式 ## 开发环境 ### 必需工具 **nRF Connect SDK**: Nordic 官方开发套件 **Zephyr RTOS**: 实时操作系统 **West工具**: 项目管理和构建工具 **Python 3.7+**: 构建脚本和工具链 **CMake**: 构建系统 **Git**: 版本控制 ### 支持的开发环境 **VS Code**: 推荐的集成开发环境 **JLink调试器**: 硬件调试支持 **串口终端**: 日志输出和调试 **nRF Connect**: 蓝牙测试和调试工具 ### 构建配置 项目支持多种构建配置： ```bash # 单播服务器模式（默认） west build b nrf5340_audio_dk_nrf5340_cpuapp # 广播接收器模式 west build b nrf5340_audio_dk_nrf5340_cpuapp DCONFIG_AUDIO_SINK y # 调试版本 west build b nrf5340_audio_dk_nrf5340_cpuapp DCONFIG_DEBUG y # 发布版本 west build b nrf5340_audio_dk_nrf5340_cpuapp DCONFIG_RELEASE y ``` ## 应用配置 ### 音频配置 项目支持多种音频配置模式： ```c // 在 prj.conf 中配置 CONFIG_AUDIO_SAMPLE_RATE_48000_HZ y CONFIG_AUDIO_BIT_DEPTH_16 y CONFIG_AUDIO_CHANNELS_STEREO y ``` ### 传感器配置 ```c // 传感器采样配置 CONFIG_SENSOR_IMU_SAMPLE_RATE 100 CONFIG_SENSOR_PPG_SAMPLE_RATE 25 CONFIG_SENSOR_TEMPERATURE_SAMPLE_RATE 1 ``` ### 蓝牙配置 ```c // 蓝牙 LE Audio 配置 CONFIG_BT_AUDIO y CONFIG_BT_BAP_UNICAST_SERVER y CONFIG_BT_BAP_BROADCAST_SINK y ``` ## 用户界面 ### LED状态指示 设备通过 RGB LED 提供丰富的状态反馈： 状态 LED 颜色 说明 启动中 白色闪烁 系统正在启动 等待配对 蓝色闪烁 等待蓝牙配对 已连接 青色常亮 蓝牙已连接 音频播放 绿色呼吸 正在播放音频 充电中 红色常亮 电池正在充电 充电完成 绿色常亮 电池充电完成 低电量 红色闪烁 电池电量不足 错误状态 红色快闪 系统错误 ### 按键控制 **单击**: 播放/暂停音频 **双击**: 接听/挂断电话 **长按**: 进入配对模式 **超长按**: 设备重启 ### 移动应用支持 OpenEarable 配套移动应用功能： **音频控制**: 音量、均衡器、音效设置 **传感器监控**: 实时传感器数据显示 **健康分析**: 基于传感器数据的健康指标 **设备管理**: 固件更新、设置同步 **数据导出**: 传感器数据导出和分析 ## 构建和烧录 ### 环境准备 ```bash # 1. 安装 nRF Connect SDK # 2. 设置环境变量 export ZEPHYR_BASE path/to/zephyr export ZEPHYR_SDK_INSTALL_DIR path/to/zephyr sdk # 3. 安装 Python 依赖 pip install r requirements.txt ``` ### 构建流程 ```bash # 1. 初始化项目 west init m https://github.com/OpenEarable/open earable 2.git west update # 2. 构建固件 cd open earable 2 west build b nrf5340_audio_dk_nrf5340_cpuapp # 3. 烧录固件 west flash # 4. 查看日志 west attach ``` ### 调试支持 ```bash # GDB 调试 west debug # RTT 日志输出 west attach # 性能分析 west build DCONFIG_PROFILING y ``` ## 项目文档结构 本项目的完整技术文档包括： ### 📖 核心文档 **[项目总结](index.html)**: 项目概览和快速入门 **[架构分析](architecture.html)**: 详细的系统架构分析 **[部署指南](deployment.html)**: 构建、烧录和部署指南 ### 🔧 模块文档 **[电源管理模块](/modules/battery module.md)**: 电池和充电管理 **[音频处理模块](/modules/audio module.md)**: 音频采集和处理 **[传感器管理模块](/modules/sensor module.md)**: 多传感器融合 **[蓝牙通信模块](/modules/bluetooth module.md)**: 蓝牙协议和服务 **[数据存储模块](/modules/storage module.md)**: 数据记录和管理 **[硬件驱动模块](/modules/drivers module.md)**: 底层硬件驱动 ### 🛠️ 开发文档 **API 参考**: 详细的 API 文档 **示例代码**: 常用功能的示例实现 **故障排除**: 常见问题和解决方案 **贡献指南**: 开源贡献流程 ## 开源社区 ### 项目链接 **GitHub 仓库**: https://github.com/OpenEarable/open earable 2 **官方网站**: https://open earable.teco.edu/ **文档网站**: https://docs.open earable.teco.edu/ **社区论坛**: https://community.open earable.teco.edu/ ### 许可证 项目采用 MIT 许可证，允许自由使用、修改和分发。 ### 贡献方式 欢迎社区贡献： **Bug 报告**: 在 GitHub Issues 中报告问题 **功能请求**: 提出新功能建议 **代码贡献**: 提交 Pull Request **文档改进**: 完善项目文档 **测试反馈**: 提供测试结果和反馈 OpenEarable 2.0 代表了可穿戴技术的未来，结合了先进的音频处理、丰富的传感器集成和强大的AI能力。通过开源的方式，我们致力于推动整个行业的创新和发展。"},"/lhfdoc.github.io/embedded_dev/openearable/sensor-module.html":{"title":"传感器管理模块详细分析","content":"# 传感器管理模块详细分析 ## 模块概述 传感器管理模块是OpenEarable 2.0的核心创新组件，负责管理集成的多种高精度传感器，包括IMU、PPG、温度、气压、麦克风等传感器。该模块提供统一的传感器接口、数据采集、处理和传输功能，是OpenEarable区别于普通音频设备的关键特性。 ## 文件结构 ``` src/SensorManager/ ├── SensorManager.h/.cpp # 传感器管理器核心 ├── EdgeMLSensor.h/.cpp # 传感器基类定义 ├── IMU.h/.cpp # 惯性测量单元传感器 ├── PPG.h/.cpp # 光电容积脉搏波传感器 ├── Baro.h/.cpp # 气压传感器 ├── Temp.h/.cpp # 温度传感器 ├── BoneConduction.h/.cpp # 骨传导传感器 ├── Microphone.h/.cpp # 麦克风传感器 ├── BMX160/ # BMX160 IMU驱动 ├── MAXM86161/ # MAXM86161 PPG驱动 ├── BMP388/ # BMP388 气压计驱动 ├── MLX90632/ # MLX90632 红外温度计驱动 ├── BMA580/ # BMA580 加速度计驱动 ├── CMakeLists.txt # 构建配置 └── Kconfig # 配置选项 ``` ## 核心架构 ### 1. SensorManager 传感器管理器 SensorManager是整个传感器系统的核心控制组件，负责传感器的生命周期管理、数据流控制和系统协调。 #### 主要功能 **传感器生命周期管理**: 初始化、启动、停止传感器 **数据流管理**: 传感器数据的采集、缓冲和分发 **配置管理**: 动态配置传感器参数 **消息总线集成**: 通过ZBus与其他模块通信 **存储管理**: 控制数据的本地存储和蓝牙传输 #### 核心接口 ```cpp // 传感器管理器状态 enum sensor_manager_state { INIT, // 初始化状态 RUNNING, // 运行状态 SUSPENDED, // 挂起状态 }; // 主要控制接口 void init_sensor_manager(); // 初始化传感器管理器 void start_sensor_manager(); // 启动传感器管理器 void stop_sensor_manager(); // 停止传感器管理器 void config_sensor(struct sensor_config *config); // 配置传感器 enum sensor_manager_state get_state(); // 获取管理器状态 ``` #### 工作队列架构 ```cpp // 传感器专用工作队列 extern struct k_work_q sensor_work_q; // 消息队列定义 K_MSGQ_DEFINE(sensor_queue, sizeof(struct sensor_msg), 256, 4); K_MSGQ_DEFINE(config_queue, sizeof(struct sensor_config), 16, 4); // ZBus通道定义 ZBUS_CHAN_DEFINE(sensor_chan, struct sensor_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY, ZBUS_MSG_INIT(0)); ``` ### 2. EdgeMLSensor 传感器基类 EdgeMLSensor是所有传感器类的抽象基类，定义了统一的传感器接口和行为模式。 #### 设计特点 **纯虚函数接口**: 强制子类实现核心功能 **统一的生命周期**: 标准化的初始化、启动、停止流程 **配置化采样率**: 支持多档位采样率配置 **双重数据流**: 支持SD卡存储和蓝牙传输 #### 核心接口 ```cpp template <size_t N> struct SampleRateSetting { uint8_t reg_vals[N]; // 寄存器配置值 float sample_rates[N]; // 标称采样率 float true_sample_rates[N]; // 实际采样率 }; class EdgeMlSensor { public: // 纯虚函数接口 virtual bool init(struct k_msgq *queue) 0; // 初始化传感器 virtual void start(int sample_rate_idx) 0; // 启动传感器 virtual void stop() 0; // 停止传感器 // 状态查询和控制 bool is_running(); // 检查运行状态 void sd_logging(bool enable); // 控制SD卡记录 void ble_stream(bool enable); // 控制蓝牙流传输 protected: k_work sensor_work; // 传感器工作项 k_timer sensor_timer; // 传感器定时器 static k_msgq *sensor_queue; // 传感器消息队列 bool _sd_logging false; // SD卡记录标志 bool _ble_stream true; // 蓝牙传输标志 bool _running false; // 运行状态标志 }; ``` ## 传感器实现详解 ### 1. IMU 传感器 (BMX160) IMU传感器基于Bosch BMX160九轴传感器，提供加速度计、陀螺仪和磁力计数据。 #### 技术规格 **加速度计**: ±2g/±4g/±8g/±16g量程，14位分辨率 **陀螺仪**: ±125°/s到±2000°/s量程，16位分辨率 **磁力计**: ±1300μT量程，高精度磁场测量 #### 采样率配置 ```cpp class IMU : public EdgeMlSensor { public: const static SampleRateSetting<6> sample_rates; private: static DFRobot_BMX160 imu; // BMX160驱动实例 }; // 支持的采样率设置 const SampleRateSetting<6> IMU::sample_rates { .reg_vals {0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C}, .sample_rates {25.0, 50.0, 100.0, 200.0, 400.0, 800.0}, .true_sample_rates {25.32, 50.64, 101.28, 202.56, 405.12, 810.24} }; ``` #### 数据结构 ```cpp struct imu_data { float accel_x, accel_y, accel_z; // 加速度 (m/s²) float gyro_x, gyro_y, gyro_z; // 角速度 (rad/s) float mag_x, mag_y, mag_z; // 磁场强度 (μT) uint64_t timestamp; // 时间戳 (μs) } __attribute__((packed)); ``` ### 2. PPG 传感器 (MAXM86161) PPG传感器基于Maxim MAXM86161光学传感器，用于心率监测、血氧测量和生理信号分析。 #### 技术规格 **光源**: 红光、红外光、绿光LED **光电二极管**: 高灵敏度光电检测器 **采样率**: 最高3200Hz **分辨率**: 19位ADC #### LED配置 ```cpp enum led_order { red, // 红光LED (660nm) green, // 绿光LED (537nm) ir, // 红外LED (880nm) ambient // 环境光检测 }; class PPG : public EdgeMlSensor { public: const static SampleRateSetting<16> sample_rates; private: static MAXM86161 ppg; // MAXM86161驱动实例 ppg_sample data_buffer[64]; // 数据缓冲区 }; ``` #### 数据结构 ```cpp struct ppg_sample { uint32_t red; // 红光通道数据 uint32_t ir; // 红外通道数据 uint32_t green; // 绿光通道数据 uint32_t ambient; // 环境光数据 uint64_t timestamp; // 时间戳 } __attribute__((packed)); ``` ### 3. 温度传感器 (MLX90632) 温度传感器基于Melexis MLX90632非接触式红外温度计，可测量物体温度和环境温度。 #### 技术规格 **测量范围**: 20°C到85°C (环境), 20°C到200°C (物体) **精度**: ±0.2°C (典型值) **响应时间**: <1秒 **接口**: I2C #### 数据结构 ```cpp struct temp_data { float ambient_temp; // 环境温度 (°C) float object_temp; // 物体温度 (°C) uint64_t timestamp; // 时间戳 } __attribute__((packed)); ``` ### 4. 气压传感器 (BMP388) 气压传感器基于Bosch BMP388高精度气压计，用于高度测量和环境监测。 #### 技术规格 **压力范围**: 300 1250 hPa **精度**: ±0.08 hPa (典型值) **高度分辨率**: ±8 cm **温度补偿**: 集成温度传感器 #### 数据结构 ```cpp struct baro_data { float pressure; // 大气压力 (hPa) float temperature; // 温度 (°C) float altitude; // 海拔高度 (m) uint64_t timestamp; // 时间戳 } __attribute__((packed)); ``` ### 5. 骨传导传感器 骨传导传感器通过检测颅骨振动来感知语音和咀嚼等生理活动。 #### 实现原理 **振动检测**: 高灵敏度加速度计检测骨传导振动 **信号处理**: 数字滤波和特征提取 **模式识别**: 语音活动检测(VAD) #### 数据结构 ```cpp struct bone_conduction_data { float vibration_x, vibration_y, vibration_z; // 三轴振动数据 float rms_amplitude; // RMS振幅 bool voice_activity; // 语音活动标志 uint64_t timestamp; // 时间戳 } __attribute__((packed)); ``` ## 数据流架构 ### 传感器数据流 ``` [传感器硬件] → [驱动层] → [EdgeMLSensor] → [SensorManager] → [数据分发] ↓ [SD卡存储] ↓ [蓝牙传输] ``` ### 消息队列系统 ```cpp // 传感器消息结构 struct sensor_msg { bool sd; // SD卡存储标志 bool stream; // 蓝牙传输标志 struct sensor_data data; // 传感器数据 }; // 传感器数据结构 struct sensor_data { uint8_t id; // 传感器ID uint8_t size; // 数据大小 uint64_t time; // 时间戳 uint8_t data[36]; // 数据载荷 } __attribute__((packed)); ``` ### 配置系统 ```cpp // 传感器配置结构 struct sensor_config { uint8_t sensorId; // 传感器ID uint8_t sampleRateIndex; // 采样率索引 uint8_t storageOptions; // 存储选项 } __attribute__((packed)); // 传感器ID枚举 enum sensor_id { ID_IMU 0, // 惯性测量单元 ID_TEMP_BARO 1, // 温度气压传感器 ID_MICRO 2, // 麦克风 ID_PPG 4, // 光电容积脉搏波 ID_PULSOX 5, // 脉搏血氧 ID_OPTTEMP 6, // 光学温度计 ID_BONE_CONDUCTION 7, // 骨传导传感器 }; ``` ## 定时器和中断系统 ### 定时器驱动的数据采集 ```cpp class IMU : public EdgeMlSensor { private: // 定时器中断处理函数 static void sensor_timer_handler(struct k_timer *dummy) { k_work_submit_to_queue(&sensor_work_q, &sensor.sensor_work); } // 传感器数据更新工作项 static void update_sensor(struct k_work *work) { // 1. 读取传感器数据 bmx160_data_t raw_data; imu.read_sensor_data(&raw_data); // 2. 数据格式转换 struct sensor_data sensor_data; format_imu_data(&raw_data, &sensor_data); // 3. 发送到消息队列 struct sensor_msg msg { .sd sensor._sd_logging, .stream sensor._ble_stream, .data sensor_data }; k_msgq_put(&sensor_queue, &msg, K_NO_WAIT); } }; ``` ### 中断驱动的事件检测 ```cpp // PPG传感器的FIFO中断处理 void ppg_fifo_interrupt_handler() { // 1. 读取FIFO数据 uint8_t fifo_samples ppg.get_fifo_samples(); for (int i 0; i < fifo_samples; i++) { // 2. 处理每个样本 ppg_sample sample; ppg.read_fifo_sample(&sample); // 3. 质量检查和处理 if (is_valid_ppg_sample(&sample)) { process_ppg_data(&sample); } } } ``` ## 功耗管理 ### 动态功耗控制 ```cpp void sensor_power_management() { // 根据活跃传感器数量调整功耗 if (active_sensors 0) { // 无活跃传感器，进入低功耗模式 set_sensor_power_mode(POWER_MODE_SLEEP); } else if (active_sensors < 2) { // 少量传感器，中等功耗模式 set_sensor_power_mode(POWER_MODE_NORMAL); } else { // 多传感器，高性能模式 set_sensor_power_mode(POWER_MODE_HIGH_PERFORMANCE); } } ``` ### 采样率自适应 ```cpp void adaptive_sampling_rate() { // 根据电池电量和数据需求调整采样率 uint8_t battery_level get_battery_level(); if (battery_level < 20) { // 低电量时降低采样率 reduce_sensor_sampling_rates(); } else if (battery_level > 80) { // 电量充足时恢复正常采样率 restore_sensor_sampling_rates(); } } ``` ## 数据处理和分析 ### 实时信号处理 ```cpp // IMU数据的运动检测 bool detect_motion(imu_data *data) { // 计算加速度向量的幅值 float accel_magnitude sqrt(data >accel_x * data >accel_x + data >accel_y * data >accel_y + data >accel_z * data >accel_z); // 判断是否有显著运动 return (accel_magnitude > MOTION_THRESHOLD); } // PPG数据的心率检测 float calculate_heart_rate(ppg_sample *samples, int count) { // 1. 信号预处理 filter_ppg_signal(samples, count); // 2. 峰值检测 int peak_count detect_peaks(samples, count); // 3. 心率计算 float sampling_period 1.0f / PPG_SAMPLE_RATE; float heart_rate (peak_count * 60.0f) / (count * sampling_period); return heart_rate; } ``` ### 传感器融合 ```cpp // 多传感器融合的姿态估计 void sensor_fusion_update(imu_data *imu, mag_data *mag) { // 1. 加速度计姿态估计 float accel_roll atan2(imu >accel_y, imu >accel_z); float accel_pitch atan2( imu >accel_x, sqrt(imu >accel_y * imu >accel_y + imu >accel_z * imu >accel_z)); // 2. 陀螺仪姿态积分 integrate_gyroscope_data(imu); // 3. 磁力计偏航角计算 float mag_yaw atan2(mag >mag_y, mag >mag_x); // 4. 互补滤波器融合 complementary_filter_update(accel_roll, accel_pitch, mag_yaw); } ``` ## 校准和补偿 ### 传感器校准 ```cpp // IMU零偏校准 void calibrate_imu_bias() { const int calibration_samples 1000; float accel_bias[3] {0, 0, 0}; float gyro_bias[3] {0, 0, 0}; // 收集校准数据 for (int i 0; i < calibration_samples; i++) { imu_data data; read_imu_data(&data); accel_bias[0] + data.accel_x; accel_bias[1] + data.accel_y; accel_bias[2] + data.accel_z 9.81f; // 重力补偿 gyro_bias[0] + data.gyro_x; gyro_bias[1] + data.gyro_y; gyro_bias[2] + data.gyro_z; k_sleep(K_MSEC(1)); } // 计算平均偏差 for (int i 0; i < 3; i++) { accel_bias[i] / calibration_samples; gyro_bias[i] / calibration_samples; } // 存储校准参数 store_calibration_data(accel_bias, gyro_bias); } ``` ### 温度补偿 ```cpp // PPG温度补偿 void temperature_compensation_ppg(ppg_sample *sample, float temperature) { // 基于温度的增益补偿 float temp_coeff 1.0f + (temperature 25.0f) * 0.001f; sample >red (uint32_t)(sample >red * temp_coeff); sample >ir (uint32_t)(sample >ir * temp_coeff); sample >green (uint32_t)(sample >green * temp_coeff); } ``` ## 配置选项 ### Kconfig配置 ```kconfig # 传感器管理器配置 CONFIG_SENSOR_WORK_QUEUE_STACK_SIZE 2048 CONFIG_SENSOR_WORK_QUEUE_PRIO 5 CONFIG_SENSOR_PUB_STACK_SIZE 1024 CONFIG_SENSOR_PUB_THREAD_PRIO 6 # 传感器使能 CONFIG_SENSOR_IMU y CONFIG_SENSOR_PPG y CONFIG_SENSOR_TEMPERATURE y CONFIG_SENSOR_BAROMETER y CONFIG_SENSOR_BONE_CONDUCTION y # 采样率配置 CONFIG_IMU_DEFAULT_SAMPLE_RATE 100 CONFIG_PPG_DEFAULT_SAMPLE_RATE 400 CONFIG_TEMP_DEFAULT_SAMPLE_RATE 10 # 数据缓冲配置 CONFIG_SENSOR_QUEUE_SIZE 256 CONFIG_SENSOR_BUFFER_SIZE 64 ``` ## 错误处理和诊断 ### 传感器健康监控 ```cpp void sensor_health_check() { // 检查各传感器状态 for (int id 0; id < NUM_SENSORS; id++) { EdgeMlSensor *sensor get_sensor((sensor_id)id); if (sensor && sensor >is_running()) { // 检查数据更新频率 if (sensor_data_rate[id] < expected_rate[id] * 0.8f) { LOG_WRN(\"Sensor %d data rate low: %.1f Hz\", id, sensor_data_rate[id]); // 尝试重启传感器 sensor >stop(); k_sleep(K_MSEC(100)); sensor >start(sensor_config[id].sample_rate_idx); } } } } ``` ### 数据质量检查 ```cpp bool validate_sensor_data(struct sensor_data *data) { switch (data >id) { case ID_IMU: return validate_imu_data((imu_data*)data >data); case ID_PPG: return validate_ppg_data((ppg_sample*)data >data); case ID_TEMP_BARO: return validate_temp_baro_data((temp_baro_data*)data >data); default: return true; } } ``` ## 总结 传感器管理模块是OpenEarable 2.0的核心创新特性，具有以下关键优势： 1. **多传感器集成**: 支持IMU、PPG、温度、气压等多种传感器 2. **统一管理接口**: 通过EdgeMLSensor基类提供统一的传感器接口 3. **高效数据流**: 基于消息队列和ZBus的高效数据传输 4. **灵活配置**: 支持动态配置采样率和存储选项 5. **实时处理**: 低延迟的数据采集和处理能力 6. **功耗优化**: 智能的功耗管理和自适应采样 7. **数据质量**: 完善的校准、补偿和质量检查机制 8. **模块化设计**: 易于扩展新的传感器类型 该模块为OpenEarable 2.0提供了强大的传感器数据采集和处理能力，支持各种生理监测、运动追踪和环境感知应用，是实现智能耳戴式设备功能的核心基础。"}}